<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"baimohui.github.io",root:"/",images:"/images",scheme:"Muse",version:"8.2.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12},copycode:!1,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"}}</script><meta name="description" content="AJAX（一）AJAX 概述AJAX（Asynchronous JavaScript And XML，异步的 JavaScript 和 XML），是一种实现无页面刷新获取服务器数据的混合技术。它能够使浏览器在不刷新页面的情况下获取服务器响应，这将大大提升互联网用户的使用体验，同时，由于 AJAX 请求获取的是数据而不是 HTML 文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅"><meta property="og:type" content="article"><meta property="og:title" content="异步请求方法总结"><meta property="og:url" content="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/index.html"><meta property="og:site_name" content="白抹灰"><meta property="og:description" content="AJAX（一）AJAX 概述AJAX（Asynchronous JavaScript And XML，异步的 JavaScript 和 XML），是一种实现无页面刷新获取服务器数据的混合技术。它能够使浏览器在不刷新页面的情况下获取服务器响应，这将大大提升互联网用户的使用体验，同时，由于 AJAX 请求获取的是数据而不是 HTML 文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210614225916.png"><meta property="article:published_time" content="2023-02-02T15:18:54.602Z"><meta property="article:modified_time" content="2023-02-02T15:18:54.603Z"><meta property="article:author" content="mohui"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="异步"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210614225916.png"><link rel="canonical" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>异步请求方法总结 | 白抹灰</title><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">白抹灰</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#AJAX"><span class="nav-text">AJAX</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89AJAX-%E6%A6%82%E8%BF%B0"><span class="nav-text">（一）AJAX 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-XML-%E5%92%8C-JSONP"><span class="nav-text">1. XML 和 JSONP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%97%A0%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0"><span class="nav-text">2. 无页面刷新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%B7%B7%E5%90%88%E6%8A%80%E6%9C%AF"><span class="nav-text">3. 混合技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8E%9F%E7%94%9F-AJAX-%E4%BD%BF%E7%94%A8"><span class="nav-text">（二）原生 AJAX 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-XMLHttpRequest-%E5%AF%B9%E8%B1%A1"><span class="nav-text">1. XMLHttpRequest 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%87%86%E5%A4%87-AJAX-%E8%AF%B7%E6%B1%82"><span class="nav-text">2. 准备 AJAX 请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="nav-text">3. 设置请求头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="nav-text">4. 发送请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94"><span class="nav-text">5. 处理响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%8F%96%E6%B6%88%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="nav-text">6. 取消异步请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-XMLHttpRequest-2-%E7%BA%A7%E8%A7%84%E8%8C%83"><span class="nav-text">7. XMLHttpRequest 2 级规范</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0-FormData-%E7%B1%BB%E5%9E%8B"><span class="nav-text">① FormData 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1-%E8%B6%85%E6%97%B6%E8%AE%BE%E5%AE%9A"><span class="nav-text">② 超时设定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2-overrideMimeType-%E6%96%B9%E6%B3%95"><span class="nav-text">③ overrideMimeType() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3-%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6"><span class="nav-text">④ 进度事件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89jQuery-AJAX-%E4%BD%BF%E7%94%A8"><span class="nav-text">（三）jQuery AJAX 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-jQuery-%E5%8A%A0%E8%BD%BD"><span class="nav-text">1. jQuery 加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-jQuery-GET-POST"><span class="nav-text">2. jQuery GET&#x2F;POST</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fetch"><span class="nav-text">Fetch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89Fetch-%E5%AE%9E%E7%8E%B0"><span class="nav-text">（一）Fetch 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Fetch-%E5%AE%9E%E4%BE%8B"><span class="nav-text">（二）Fetch 实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89Fetch-%E4%BD%BF%E7%94%A8"><span class="nav-text">（三）Fetch 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Headers"><span class="nav-text">Headers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request"><span class="nav-text">Request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Response"><span class="nav-text">Response</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89Fetch-%E7%BC%BA%E7%82%B9"><span class="nav-text">（四）Fetch 缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Axios"><span class="nav-text">Axios</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89Axios-%E4%BD%BF%E7%94%A8"><span class="nav-text">（一）Axios 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="nav-text">1. 发送请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B7%BB%E5%8A%A0%E6%8B%A6%E6%88%AA%E5%99%A8%E5%87%BD%E6%95%B0"><span class="nav-text">2. 添加拦截器函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%92%A4%E9%94%80-HTTP-%E8%AF%B7%E6%B1%82"><span class="nav-text">3. 撤销 HTTP 请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Axios-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="nav-text">（二）Axios 核心模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97"><span class="nav-text">HTTP 请求模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A8%A1%E5%9D%97"><span class="nav-text">拦截器模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E9%94%80%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97"><span class="nav-text">撤销请求模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axios-%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">axios 这样设计的好处是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="nav-text">发送请求函数的处理逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="nav-text">适配器的处理逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E9%94%80-HTTP-%E8%AF%B7%E6%B1%82%E7%9A%84%E9%80%BB%E8%BE%91"><span class="nav-text">撤销 HTTP 请求的逻辑</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">mohui</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">73</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">73</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">异步请求方法总结</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-02-02 23:18:54" itemprop="dateCreated datePublished" datetime="2023-02-02T23:18:54+08:00">2023-02-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>22k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>20 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="（一）AJAX-概述"><a href="#（一）AJAX-概述" class="headerlink" title="（一）AJAX 概述"></a>（一）AJAX 概述</h2><p>AJAX（Asynchronous JavaScript And <strong>XML</strong>，异步的 JavaScript 和 XML），是一种实现<strong>无页面刷新</strong>获取服务器数据的<strong>混合技术</strong>。它能够使浏览器在不刷新页面的情况下获取服务器响应，这将大大提升互联网用户的使用体验，同时，由于 AJAX 请求获取的是数据而不是 HTML 文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。<a id="more"></a></p><h3 id="1-XML-和-JSONP"><a href="#1-XML-和-JSONP" class="headerlink" title="1. XML 和 JSONP"></a>1. XML 和 JSONP</h3><p>XML（Extensible Markup Language，可拓展标记语言）是一种类似 HTML，用来描述数据是什么，并承载数据的标记语言。</p><p>而 JSON 仅仅是一种数据格式，在 JSON 发明之前，人们大量使用 XML 作为数据传输的载体，也正因如此，AJAX 技术的最后一个字母为“X”。而如今情况则发生了些变化，JSON 这种类似于字符串对象的轻量级的数据格式越来越受到开发者青睐，几乎变成了 AJAX 技术的标准数据格式。需要注意的是，JSON 并不是 XML 的替代品，两者各自有其适应的场景。</p><h3 id="2-无页面刷新"><a href="#2-无页面刷新" class="headerlink" title="2. 无页面刷新"></a>2. 无页面刷新</h3><p>互联网最主要的功能在于资源交换，虽然在互联网中资源交换的主体都是计算机，但为了方便交流，我们通常将获取资源的一方称为客户端（主要的工具是浏览器），而将派发资源的一方称为服务端。</p><p>在 AJAX 技术出现之前，如果浏览器需要从服务器请求资源，其交互模式为“客户端发出请求 -&gt; 服务端接收请求并返回相应 HTML 文档 -&gt; 页面刷新，客户端加载新的 HTML 文档”。这种交互模式简洁明了，但是随着时代的进步，越来越多商业化网站的出现，使互联网不再局限于满足人们资源交换的需求，人们开始期待能够在互联网中获得更好的<strong>使用体验</strong>，而这种用户每次点击都会刷新页面的交互方式显然不够妥当。当用户点击页面中的某个按钮向服务器发送请求时，页面本质上可能只是一些数据发生了变化，而此时服务器却要将重绘的整个页面再返回给浏览器加载，这显然有悖于程序员的“DRY”原则，而且明明只是一些数据的变化却迫使服务器要返回整个 HTML 文档，这本身也会给网络带宽带来不必要的开销。</p><p>而 AJAX 能够在页面数据变动时，只向服务器请求新的数据，并且在阻止页面刷新的情况下，动态替换页面中展示的数据。AJAX 技术的问世，不仅通过阻止浏览器接受响应时刷新页面提升了互联网用户的使用体验，还使开发者能够以更加微观的视角重新思考互联网应用的构建，在数据层面而非资源层面以更高的自由度构建网站和 Web 应用。</p><h3 id="3-混合技术"><a href="#3-混合技术" class="headerlink" title="3. 混合技术"></a>3. 混合技术</h3><p>AJAX 技术并不只是操作<code>XMLHttpRequest</code>对象发起异步请求，而是为了实现<strong>无页面刷新的资源获取</strong>的一系列技术的统称，这些技术包括了：</p><ul><li>JavaScript：用来在获取数据后，通过操作 DOM 或其他方式达成目标；</li><li>客户端（即浏览器）提供的实现异步服务器通信的<code>XMLHttpRequest</code>对象；</li><li>服务器端允许浏览器向其发起 AJAX 请求的相关设置；</li></ul><p>明白 AJAX 并不只是操作<code>XMLHttpRequest</code>对象，对于初学者而言是十分必要的。</p><h2 id="（二）原生-AJAX-使用"><a href="#（二）原生-AJAX-使用" class="headerlink" title="（二）原生 AJAX 使用"></a>（二）原生 AJAX 使用</h2><h3 id="1-XMLHttpRequest-对象"><a href="#1-XMLHttpRequest-对象" class="headerlink" title="1. XMLHttpRequest 对象"></a>1. XMLHttpRequest 对象</h3><p><code>XMLHttpRequest</code>对象是浏览器提供的一个 API，用来向服务器发送请求并解析服务器响应，整个过程中浏览器页面不会被刷新。<code>XMLHttpRequest</code>只是一个 JavaScript 对象，或者说是一个<strong>构造函数</strong>，它是由客户端 (即浏览器) 提供的（而不是 JavaScript 原生的）。它有属性和方法，需要通过<code>new</code>关键字进行实例化。</p><p><code>XMLHttpRequest</code>对象是不断被扩展的。随着 XML 对象被广泛的接收，W3C 也开始着手制定相应的标准来规范其行为。目前，<code>XMLHttpRequest</code>有两个级别：1 级提供了 XML 对象的实现细节，2 级进一步发展了 XML 对象，额外添加了一些方法，属性和数据类型。但是并非所有浏览器都实现了 XML 对象 2 级的内容。</p><p>从一个 XML 对象的实例来剖析<code>XMLHttpRequest</code>实例的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br></pre></td></tr></table></figure><p>该实例的方法有：</p><ul><li><code>.open()</code>：准备启动一个 AJAX 请求；</li><li><code>.setRequestHeader()</code>：设置请求头部信息；</li><li><code>.send()</code>：发送 AJAX 请求；</li><li><code>.getResponseHeader()</code>: 获得响应头部信息；</li><li><code>.getAllResponseHeader()</code>：获得一个包含所有头部信息的长字符串；</li><li><code>.abort()</code>：取消异步请求；</li></ul><p>该实例的属性有：</p><ul><li><code>.responseText</code>：包含响应主体返回文本；</li><li><code>.responseXML</code>：如果响应的内容类型时<code>text/xml</code>或<code>application/xml</code>，该属性将保存包含着相应数据的 XML DOM 文档；</li><li><code>.status</code>：响应的 HTTP 状态；</li><li><code>.statusText</code>：HTTP 状态的说明；</li><li><code>.readyState</code>：表示请求/响应过程的当前活动阶段</li></ul><p>浏览器还为该对象提供了一个<code>onreadystatechange</code>监听事件，每当 XML 实例的<code>readyState</code>属性变化时，就会触发该事件。</p><p>至此，关于 XMLHttpRequest 实例对象的属性方法就全部罗列完毕了，接下来，我们将更进一步的探究如何使用这些方法，属性完成发送 AJAX 请求的流程。</p><h3 id="2-准备-AJAX-请求"><a href="#2-准备-AJAX-请求" class="headerlink" title="2. 准备 AJAX 请求"></a>2. 准备 AJAX 请求</h3><p><code>.open()</code>方法接收三个参数：<strong>请求方式</strong>，<strong>请求 URL 地址</strong>和<strong>是否为异步请求的布尔值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该段代码会启动一个针对“example.php”的 GET 同步请求。</span></span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p><strong>① GET 与 POST</strong></p><ul><li>GET 请求</li></ul><p>GET 请求用于<strong>获取数据</strong>，有时需要获取的数据得通过查询参数进行定位，在这种情况下应将查询参数追加到 URL 的末尾，令服务器解析。查询参数是指一个由<code>?</code>号起始，由<code>&amp;</code>符号分割的包含相应键值对的字符串，用来告知浏览器所要查询的特定资源。查询字符串中每个参数的名和值都必须使用 encodeURIComponent() 进行编码（这是因为 URL 中有些字符会引起歧义，例如“&amp;”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> query = <span class="string">&quot;example.php?name=tom&amp;age=24&quot;</span> <span class="comment">// &quot;?name=tom&amp;age=24&quot;即是一个查询参数</span></span><br></pre></td></tr></table></figure><ul><li>POST 请求</li></ul><p>POST 请求用于<strong>向服务器发送应该被保存的数据</strong>，因此 POST 请求比 GET 请求多一份<strong>需要被保存的数据</strong>。需要发送的数据会作为<code>.send()</code>方法的参数最终被发往服务器，该数据可以是任意大小，任意类型。</p><p>这里需要注意以下两点：</p><ul><li><code>.send()</code>方法的参数是不可为空的，对于无需发送任何数据的 GET 请求，也需要在调用<code>.send()</code>方法时，向其传入<code>null</code>值；</li><li>服务器对待<strong>表单提交</strong>以及<strong>发送 POST 请求</strong>并不一视同仁，这意味着服务器需要有相应的代码专门处理 POST 请求发送来的原始数据。</li></ul><p>但好在我们可以通过 POST 请求模拟表单提交，只需要简单两步：</p><ol><li>设置请求头参数：<code>Content-Type: application/x-www-form-urlencoded</code>（表单提交时的内容类型）；</li><li>将表单数据序列化为查询字符串形式，传入<code>.send()</code>方法；</li></ol><p><strong>② 请求 URL 地址</strong></p><p>这里需要注意若使用相对路径，请求 URL 是<strong>相对于执行代码的当前页面</strong>。</p><p><strong>③ 同步请求与异步请求</strong></p><p>AJAX 并非总是异步的，AJAX 是避免页面在获取数据后刷新的一种技术，至于等待服务器响应的方式是同步还是异步，需要开发人员结合业务需求进行配置（虽然通常是异步的）。</p><h3 id="3-设置请求头"><a href="#3-设置请求头" class="headerlink" title="3. 设置请求头"></a>3. 设置请求头</h3><p>每个 HTTP 请求和响应都会带有一些与数据，收发者网络环境与状态相关的头部信息。XMLHttpRequest 对象提供的<code>.setRequestHeader()</code>方法为开发者提供了一个操作这两种头部信息的方法，并允许开发者自定义请求头的头部信息。</p><p>默认情况下，当发送 AJAX 请求时，会附带以下头部信息：</p><ul><li><code>Accept</code>：浏览器能够处理的内容类型；</li><li><code>Accept-Charset</code>: 浏览器能够显示的字符集；</li><li><code>Accept-Encoding</code>：浏览器能够处理的压缩编码；</li><li><code>Accept-Language</code>：浏览器当前设置的语言；</li><li><code>Connection</code>：浏览器与服务器之间连接的类型；</li><li><code>Cookie</code>：当前页面设置的任何 Cookie；</li><li><code>Host</code>：发出请求的页面所在的域；</li><li><code>Referer</code>：发出请求的页面 URI；</li><li><code>User-Agent</code>：浏览器的用户代理字符串；</li></ul><p>部分浏览器不允许使用<code>.setRequestHeader()</code>方法重写默认请求头信息，因此自定义请求头信息是更加安全的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;myHeader&quot;</span>, <span class="string">&quot;MyValue&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-发送请求"><a href="#4-发送请求" class="headerlink" title="4. 发送请求"></a>4. 发送请求</h3><p>我们已经通过<code>.open()</code>方法确定了请求方式，等待响应的方式和请求地址，还通过<code>.setRequestHeader()</code>自定义了响应头，接下来需要使用<code>.send()</code>方法发送 AJAX 请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AJAX 发送 get 请求</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;myHeader&quot;</span>, <span class="string">&quot;goodHeader&quot;</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AJAX 发送 post 请求</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;myHeader&quot;</span>, <span class="string">&quot;bestHeader&quot;</span>)</span><br><span class="line">xhr.send(some_data)</span><br></pre></td></tr></table></figure><h3 id="5-处理响应"><a href="#5-处理响应" class="headerlink" title="5. 处理响应"></a>5. 处理响应</h3><p>处理一个同步的 GET 请求响应：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;myHeader&quot;</span>, <span class="string">&quot;goodHeader&quot;</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 由于是同步的 AJAX 请求，因此只有当服务器响应后才会继续执行下面的代码</span></span><br><span class="line"><span class="comment">// 因此 xhr.status 的值一定不为默认值</span></span><br><span class="line"><span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">    alert(xhr.responseText)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xhr<code>.status</code>属性存储着响应的 HTTP 状态，判断请求是否成功。如果成功，就将读取 xhr<code>.responseText</code>属性中存储的返回值。但当请求为异步时，在<code>xhr.send(null)</code>语句被执行后，JavaScript 引擎会紧接着执行下面的判断语句，而由于尚未来得及响应，此时会得到一个默认的 xhr.status 值，而不能获取到请求的资源。</p><p>所以我们需要通过为 XMLHTTPRequest 实例添加<code>onreadystatechange</code>事件处理程序（也可以直接使用 DOM2 级规范规定的<code>.addEventListener()</code>方法，但 IE8 不支持该方法）。</p><p>xhr 实例的<code>readystatechange</code>事件会监听 xhr<code>.readyState</code>属性的变化，你可以将这个属性想象为一个计数器，随着 AJAX 流程的推进而不断累加，其可取的值如下：</p><ul><li><strong>0</strong>：未初始化 – 尚未调用<code>.open()</code>方法；</li><li><strong>1</strong>：启动 – 已经调用<code>.open()</code>方法，但尚未调用<code>.send()</code>方法；</li><li><strong>2</strong>：发送 – 已经调用<code>.send()</code>方法，但尚未接收到响应；</li><li><strong>3</strong>：接收 – 已经接收到部分响应数据；</li><li><strong>4</strong>：完成 – 已经接收到全部响应数据，而且已经可以在客户端使用了；</li></ul><p>有了这个时间处理程序对 AJAX 进程做监听，剩下的事就简单多了，一个异步的 GET 请求代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readystate == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：为了确保跨浏览器的兼容性，必须要在调用<code>.open()</code>方法之前指定事件处理程序，毕竟<code>.open()</code>方法的执行也包含在该事件处理程序的监听范围之内。</p><hr><h3 id="6-取消异步请求"><a href="#6-取消异步请求" class="headerlink" title="6. 取消异步请求"></a>6. 取消异步请求</h3><p>有时可能要在接收到响应前取消异步请求，这时需要调用<code>.abort()</code>方法。该方法会令 XHR 对象实例停止触发事件，并且不再允许访问任何和响应有关的对象属性。当终止 AJAX 请求后，你需要手动对 XHR 对象实例进行解绑以释放内存空间。</p><h3 id="7-XMLHttpRequest-2-级规范"><a href="#7-XMLHttpRequest-2-级规范" class="headerlink" title="7. XMLHttpRequest 2 级规范"></a>7. XMLHttpRequest 2 级规范</h3><p>W3C 提出了 XMLHttpRequest 2 级规范，虽然并非所有浏览器都实现了该规范所规定的内容。</p><h4 id="①-FormData-类型"><a href="#①-FormData-类型" class="headerlink" title="① FormData 类型"></a>① FormData 类型</h4><p>FormData 是 XMLHttpRequest 2 级提供的新数据类型（构造函数），它能让 POST 请求伪装成表单进行提交的过程更加轻松，因为 XHR 对象能够识别传入的数据类型是 FormData 的实例，并自动配置适当的头部信息。</p><p>FormData 的使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line"><span class="keyword">let</span> data1 = <span class="keyword">new</span> FormData()</span><br><span class="line">data1.append(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">xhr.send(data1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取表单数据</span></span><br><span class="line"><span class="keyword">let</span> data2 = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>])</span><br><span class="line">xhr.send(data2)</span><br></pre></td></tr></table></figure><p>FormData 的另一个好处是相较于传统 AJAX 请求，它允许我们上传二进制数据（图片，视频，音频等），详情可查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects">链接</a>。</p><p>FormData 的浏览器兼容性：</p><ul><li>桌面端：IE 10+ 与其他浏览器均支持</li><li>移动端：Android，Firefox Mobile，OperaMobile 均支持，其余浏览器未知</li></ul><h4 id="②-超时设定"><a href="#②-超时设定" class="headerlink" title="② 超时设定"></a>② 超时设定</h4><p>为了避免发送 AJAX 请求后出现迟迟得不到服务器响应的情况，2 级规范提供了一个额外的属性和事件监听事件：</p><ul><li><code>timeout</code>属性：设置超时时间，单位为毫秒；</li><li><code>timeout</code>事件：当响应时间超出实例对象 timeout 属性时被触发；</li></ul><p>使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当响应时间超过 1 秒时，请求中止，弹出提示框</span></span><br><span class="line">xhr.timeout = <span class="number">1000</span></span><br><span class="line">xhr.ontimeout = <span class="function">() =&gt;</span> &#123; alert(<span class="string">&quot;Request did not return in a second.&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>当请求终止时，会调用<code>ontimeout</code>事件处理程序，此时 xhr 的<code>readyState</code>属性的值可能已变为 4，这意味着会继续调用<code>onreadystatechange</code>事件处理程序，但是当超时中止请求后再访问 xhr 的<code>status</code>属性会使浏览器抛出一个错误，因此需要将检查<code>status</code>属性的语句放入<code>try-catch</code>语句中。虽然这带来了一些麻烦，但却对 XMLHttpRequest 对象有了更多的控制。</p><p>浏览器兼容性：</p><ul><li>桌面端：IE 10+ 与其他浏览器均支持</li><li>移动端：IE Mobile 10+ 与其他浏览器均支持</li></ul><h4 id="③-overrideMimeType-方法"><a href="#③-overrideMimeType-方法" class="headerlink" title="③ overrideMimeType() 方法"></a>③ overrideMimeType() 方法</h4><p>响应返回的响应头里，描述了返回数据的 MIME 类型，浏览器通过识别该类型，告知 XMLHttpRequest 实例处理该数据的方式。如果我们想要以其它方式处理响应数据（例如将 XML 类型数据当做纯文本处理），可以使用<code>.overrideMimeType()</code>方法，该方法可以覆写响应头所描述数据的 MIME 类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.overrideMimeType(<span class="string">&quot;text/xml&quot;</span>) <span class="comment">// 强迫浏览器将响应数据以指定类型方式解读</span></span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>浏览器兼容性：</p><ul><li>桌面端：IE 7+ 与其他浏览器均支持</li><li>移动端：Firefox Mobile，Chrome for Android 均支持，其余浏览器未知</li></ul><h4 id="④-进度事件"><a href="#④-进度事件" class="headerlink" title="④ 进度事件"></a>④ 进度事件</h4><p>Progress Events 规范是 W3C 制定的一个工作草案。该规范定义了客户端与服务器通信相关的一系列事件，这些事件监听了通信进程中的各个关键节点，使我们能够以更细的颗粒度掌控数据传输过程中的细节。目前共有 6 个进度事件，他们会随数据传输进展被顺序触发（除了 error，abort 事件），让我们看看他们的定义和浏览器兼容情况：</p><p><strong>loadstart</strong>：在接收到响应数据的第一个字节时触发；</p><ul><li>桌面端：除 Safari Mobile 未知外，其他浏览器均支持</li><li>移动端：除 Safari Mobile 未知外，其他浏览器均支持</li></ul><p><strong>progress</strong>：在接收响应期间持续不断地触发；</p><ul><li>桌面端：IE10+ 与其他浏览器均支持</li><li>移动端：均支持</li></ul><p><strong>error</strong>：在请求发生错误时触发；</p><ul><li>桌面端：所有浏览器均支持（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent">信息来源</a>）</li><li>移动端：除 IE Mobile 不支持外，其他浏览器均支持（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent">信息来源</a>）</li></ul><p><strong>abort</strong>：再因为调用 abort() 方法时触发；</p><ul><li>桌面端：未知</li><li>移动端：未知</li></ul><p><strong>load</strong>：在接收到完整的响应数据时触发；</p><ul><li>桌面端：IE7+ 与其他浏览器均支持</li><li>移动端：Chrome for Android，Edge，Firefox Mobile 支持，其余浏览器未知</li></ul><p><strong>loadend</strong>：在通信完成或者触发 error，abort 或 load 事件后触发；</p><ul><li>桌面端：所有浏览器不支持</li><li>移动端：所有浏览器不支持</li></ul><p>这里着重讲解以下两个事件：</p><p>① load 事件</p><p>该事件帮助我们节省了<code>readstatechange</code>事件，我们不必在 XHR 对象实例上绑定该事件监听函数以追踪实例上<code>readState</code>属性的变化，而是可以直接使用以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt;<span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">        alert(xhr.responseText)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;Something wrong!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>② progress 事件</p><p>该事件可以实现加载进度条效果。因为<code>onprogress</code>事件处理程序会接收到一个<code>event</code>对象，其<code>target</code>属性为 XHR 对象实例，但却额外包含着三个属性：</p><ul><li><code>lengthComputable</code>：表示进度信息是否可用的布尔值；</li><li><code>position</code>：表示目前接收的字节数；</li><li><code>totalSize</code>：表示根据 Content-Length 响应头部确定的预期字节数；</li></ul><p>显然加载进度条所需的一切资源都准备就绪，只需写出下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt;<span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">        alert(xhr.responseText)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;Something wrong!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载进度条</span></span><br><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> divStatus = <span class="built_in">document</span>.getElementById(<span class="string">&quot;status&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">        divStatus.innerHTML = <span class="string">`Received <span class="subst">$&#123;event.postion&#125;</span> of <span class="subst">$&#123;event.totalSize&#125;</span> bytes`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>要在<code>.open()</code>方法前调用<code>onprogress</code>事件处理程序。</p><h2 id="（三）jQuery-AJAX-使用"><a href="#（三）jQuery-AJAX-使用" class="headerlink" title="（三）jQuery AJAX 使用"></a>（三）jQuery AJAX 使用</h2><p>jQuery Ajax 是对原生 XHR 的封装，除此以外还增添了对 JSONP 的支持。通过 jQuery AJAX 方法，能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON，同时还能把这些外部数据直接载入网页的被选元素中。</p><p>如果没有 jQuery，AJAX 编程还是有些难度的。编写常规的 AJAX 代码并不容易，因为不同的浏览器对 AJAX 的实现并不相同。这意味着必须编写额外的代码对浏览器进行测试。借助 jQuery，只需要一行简单的代码就可以实现 AJAX 功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">   type: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">   url: url,</span><br><span class="line">   data: data,</span><br><span class="line">   dataType: dataType,</span><br><span class="line">   success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">   error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实例演示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../jquery/jquery-3.5.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">      $(<span class="built_in">document</span>).ready( <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;#b01&quot;</span>).click( <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          htmlobj = $.ajax(&#123; <span class="attr">url</span>: <span class="string">&quot;../code/02 CSS/index1-intro.html&quot;</span>, <span class="attr">async</span>: <span class="literal">false</span> &#125;);</span></span><br><span class="line"><span class="javascript">          $(<span class="string">&quot;#myDiv&quot;</span>).html(htmlobj.responseText);</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过 AJAX 改变文本<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;b01&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>改变内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而 jQuery Ajax 美中不足的是：</p><ul><li>本身是针对 MVC 的编程，不符合现在前端 MVVM 的浪潮</li><li>基于原生的 XHR 开发，XHR 本身的架构不清晰，已经有了 fetch 的替代方案</li><li>JQuery 整个项目太大，单纯使用 ajax 却要引入整个 JQuery 非常不合理（采取个性化打包的方案又不能享受 CDN 服务）</li></ul><p>尽管 JQuery 对前端的开发工作曾有着（现在也仍然有着）深远的影响，但随着 VUE，REACT 新一代框架的兴起，以及 ES 规范的完善，更多 API 的更新，JQuery 这种大而全的 JS 库，未来的路会越走越窄。</p><h3 id="1-jQuery-加载"><a href="#1-jQuery-加载" class="headerlink" title="1. jQuery 加载"></a>1. jQuery 加载</h3><p>jQuery load() 方法从服务器加载数据，并把返回的数据放入被选元素中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).load(URL,data,callback);</span><br></pre></td></tr></table></figure><ul><li>必需的 <em>URL</em> 参数规定要加载的 URL。</li><li>可选的 <em>data</em> 参数规定与请求一同发送的查询字符串键/值对集合。</li><li>可选的 <em>callback</em> 参数是 load() 方法完成后所执行的回调函数。</li></ul><p>① 把文件 “demo_test.txt” 的内容加载到指定的</p><div>元素中：<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;);</span><br></pre></td></tr></table></figure><p>② 把 “demo_test.txt” 文件中 id=”p1” 的元素的内容，加载到指定的</p><div>元素中：<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#div1&quot;).load(&quot;demo_test.txt #p1&quot;);</span><br></pre></td></tr></table></figure><p>③ 可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数：</p><ul><li><em>responseTxt</em>：调用成功时的结果内容</li><li><em>statusTXT</em> ：调用的状态</li><li><em>xhr</em>：XMLHttpRequest 对象</li></ul><p>下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示“外部内容加载成功！”，而如果失败，则显示错误消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;#div1&quot;</span>).load(<span class="string">&quot;demo_test.txt&quot;</span>,<span class="function">(<span class="params">responseTxt,statusTxt,xhr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(statusTxt==<span class="string">&quot;success&quot;</span>)</span><br><span class="line">      alert(<span class="string">&quot;外部内容加载成功！&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(statusTxt==<span class="string">&quot;error&quot;</span>)</span><br><span class="line">      alert(<span class="string">&quot;Error: &quot;</span>+xhr.status+<span class="string">&quot;: &quot;</span>+xhr.statusText);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-jQuery-GET-POST"><a href="#2-jQuery-GET-POST" class="headerlink" title="2. jQuery GET/POST"></a>2. jQuery GET/POST</h3><p><strong>jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。</strong></p><ul><li><em>GET</em> - 从指定的资源请求数据</li><li><em>POST</em> - 向指定的资源提交要处理的数据</li></ul><p>GET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据。POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。</p><p><strong>jQuery $.get() 方法</strong></p><p>$.get() 方法通过 HTTP GET 请求从服务器上请求数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get(URL,callback);</span><br></pre></td></tr></table></figure><p>必需的 <em>URL</em> 参数规定您希望请求的 URL。可选的 <em>callback</em> 参数是请求成功后回调的函数。</p><p>下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $.get(<span class="string">&quot;demo_test.asp&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data,status</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;Data: &quot;</span> + data + <span class="string">&quot;\nStatus: &quot;</span> + status);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>$.get() 的第一个参数是我们希望请求的 URL（”demo_test.asp”）。第二个参数是回调函数。第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态。</p><p><strong>jQuery $.post() 方法</strong></p><p>$.post() 方法通过 HTTP POST 请求从服务器上请求数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.post(URL,data,callback);</span><br></pre></td></tr></table></figure><p>必需的 <em>URL</em> 参数规定您希望请求的 URL。可选的 <em>data</em> 参数规定连同请求发送的数据。可选的 <em>callback</em> 参数是回调函数。</p><p>下面的例子使用 $.post() 连同请求一起发送数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $.post(<span class="string">&quot;demo_test_post.asp&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    name:<span class="string">&quot;Donald Duck&quot;</span>,</span><br><span class="line">    city:<span class="string">&quot;Duckburg&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (data,status) =&gt; &#123;</span><br><span class="line">    alert(<span class="string">&quot;Data: &quot;</span> + data + <span class="string">&quot;\nStatus: &quot;</span> + status);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h1><h2 id="（一）Fetch-实现"><a href="#（一）Fetch-实现" class="headerlink" title="（一）Fetch 实现"></a>（一）Fetch 实现</h2><p>fetch 号称是 ajax 的替代品，它的 API 是基于 Promise 设计的，旧版本的浏览器不支持 Promise，需要使用 polyfill es6-promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        ajax(url, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            resolve(res);</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（二）Fetch-实例"><a href="#（二）Fetch-实例" class="headerlink" title="（二）Fetch 实例"></a>（二）Fetch 实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 XHR</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText)   <span class="comment">//从服务器获取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch</span></span><br><span class="line">fetch(url)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">            <span class="keyword">return</span> response.json(); <span class="comment">//服务器返回的是 json 格式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>由于 Fetch 底层是用 Promise 实现，可以直接用 async 来优化上面的代码，减少回调，使其更加语义化、容易理解。async/await 是 ES7 的 API，目前还在试验阶段，还需要使用 babel 进行转译成 ES5 代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（三）Fetch-使用"><a href="#（三）Fetch-使用" class="headerlink" title="（三）Fetch 使用"></a>（三）Fetch 使用</h2><p>两种调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, options)</span><br><span class="line">fetch(req, options)</span><br></pre></td></tr></table></figure><p>推荐使用第一种，一眼就可以看到 url，更加直观。</p><p>options 是一个对象，可设置以下字段：</p><ol><li><strong>method</strong>：请求方法，默认 GET；</li><li><strong>headers</strong>：请头信息，可以是简单的对象，也可以是 <code>Headers</code> 的实例；</li><li><strong>body</strong>：发送数据。<code>Blod</code>、<code>bufferSource</code>、<code>FormData</code>、<code>URLSearchParams</code>、<code>USVstring</code>（GET、HEAD 没有 body）；</li><li><strong>mode</strong>：请求模式。<ul><li>cors：跨域请求；</li><li>no-cors：只允许使用<code>GET</code>、<code>HEAD</code>、<code>POST</code>；</li><li>same-origin：同源请求；</li><li>navigate：支持页面导航。</li></ul></li><li><strong>credentials</strong>：是否发送 cookies<ul><li>omit：不发送，默认；</li><li>same-origin：同源发送；</li><li>include：发送。</li></ul></li><li><strong>cache</strong>：缓存策略：<ul><li>default：请求之前检查缓存；</li><li>no-cache：有缓存，发送一个查询请求，缓存失效，再发送正常请求；</li><li>no-store：不检查缓存，直接请求；</li><li>reload：忽略缓存，拿到响应后，更新缓存；</li><li>force-cache：强制读取缓存，缓存过期，再发送正常请求；</li><li>only-if-cached：读取缓存，过期就报网络错误。mode 设置为 <code>same-origin</code> 时有效。</li></ul></li><li><strong>redirect</strong>：重定向时的处理方法：<ul><li>follow：跟随；</li><li>error：报错；</li><li>manual：用户手动跟随。</li></ul></li><li><strong>integrity</strong>：包含一个验证资源完整性的字符串。</li></ol><p>fetch 是比较底层的 API，很多情况下都需要我们再次封装。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jquery ajax</span></span><br><span class="line">$.post(url, &#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch</span></span><br><span class="line">fetch(url, &#123;</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    body: <span class="built_in">Object</span>.keys(&#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;).map(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">encodeURIComponent</span>(key) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(params[key]);</span><br><span class="line">    &#125;).join(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于 fetch 是比较底层的 API，所以需要我们手动将参数拼接成’name=test’的格式，而 jquery ajax 已经封装好了。所以 fetch 并不是开箱即用的。</p><h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>Headers 用于构造请求头信息，构造函数接收一个对象，对象的<code>key-value</code>就是请求头的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> headers = <span class="keyword">new</span> Headers(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&#x27;content-type&#x27;</span>:<span class="string">&#x27;text/plain&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;content-length&#x27;</span>:data.toString().length</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">headers.append(<span class="string">&#x27;X-Custom-header&#x27;</span>,<span class="string">&#x27;AnotherValue&#x27;</span>); <span class="comment">//追加</span></span><br><span class="line">headers.has(<span class="string">&#x27;content-type&#x27;</span>); <span class="comment">//true 查询</span></span><br><span class="line">headers.get(<span class="string">&#x27;content-type&#x27;</span>); <span class="comment">//&#x27;text/plain&#x27; 获取</span></span><br><span class="line"><span class="comment">// headers.getAll(&#x27;content-type&#x27;); //[&#x27;text/plain&#x27;] getAll 被移除了</span></span><br><span class="line">headers.delete(<span class="string">&#x27;content-type&#x27;</span>); <span class="comment">//删除</span></span><br><span class="line">headers.set(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;json&#x27;</span>); <span class="comment">//重写</span></span><br></pre></td></tr></table></figure><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>请求对象。可以新建一个，也可以从已有的对象中继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Url = <span class="string">&#x27;/users&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> req = <span class="keyword">new</span> Request(Url, &#123;<span class="attr">method</span>:<span class="string">&#x27;GET&#x27;</span>, headers&#125;)</span><br><span class="line"><span class="comment">// 扩展 request</span></span><br><span class="line"><span class="keyword">let</span> postReq= <span class="keyword">new</span> Requset(req, &#123;<span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>Response 实例是 fertch 处理完 promise 之后的返回的。也可以手动创建，在<code>servoceWorkers</code> 中才真实有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = <span class="keyword">new</span> Response(body, init)</span><br></pre></td></tr></table></figure><p>body 可以是<code>Blob</code>、<code>BufferSource</code>、<code>FormData</code>、<code>URLSearchParams</code>、<code>USVString</code> 这些值。</p><p>init 是一个对象，可包含以下字段：</p><ul><li>status：响应状态码；</li><li>statusText：状态文本；</li><li>headers：头部信息，普通对象或 Headers 的实例。</li></ul><p>response 的实例还有一些可读属性：</p><ul><li>ok：请求是否成功，状态码为 2xx 都为 <code>true</code> ；</li><li>status：状态码；</li><li>statusText：状态文本；</li><li>bodyUsed：响应数据是否被用过；</li><li>headers：头部信息；</li><li>url：响应地址；</li><li>type：响应类型：<ul><li>basic：同源；</li><li>cors：跨域；</li><li>error：出错；</li><li>opaque：Request mode 设置为 <code>no-cors</code> 的响应。</li></ul></li></ul><blockquote><p>当发起一个 Fetch 请求时，返回的 response 响应会自带一个 response.type 属性（basic、cors、opaque）。response.type 属性说明了异步资源的来源和其相应的处理方式。</p><p>当我们发起一个同源请求时，response.type 为 basic，我们可以从 response 读取全部信息。</p><p>当访问一个非同源域名，并且有返回相应的 CORs 响应头时，那么该请求类型是 cors。在 cors 响应里无法访问<code>Cache-Control</code>，<code>Content-Language</code>，<code>Content-Type</code>，<code>Expires</code>，<code>Last-Modified</code>和<code>Pragma</code>。</p><p>当对一个不同源的域名发起请求时，如果返回的响应头部没有 CORS 信息，那么这个 response 对应的类型就是 opaque 类型。一个 opaque 响应是无法读取返回的数据、状态，甚至无法确定这个请求是否成功。</p><p>我们可以自定义 Fetch 请求的模式，要求返回对应类型的响应，有以下几种响应：</p><ol><li>same-origin 只返回同源请求，其他类型会被 reject</li><li>cors 接收同源、非同源请求，返回有 CORs 头部的响应</li><li>cors-with-forced-preflight 在发出请求前会先做一次安全性检查</li><li>no-cors 用来发起没有 CORS 头部并且非同源请求，并且会返回 opaque 响应。但是目前这种类型只能在 Service Worker 里使用，在 window.fetch 里不能用</li></ol></blockquote><p>response 有一些方法来 reslove 响应信息。</p><ul><li>json，解析响应信息为对象，resolve promise；</li><li>text</li><li>blob</li><li>formData</li><li>arrayBuffer</li></ul><h2 id="（四）Fetch-缺点"><a href="#（四）Fetch-缺点" class="headerlink" title="（四）Fetch 缺点"></a>（四）Fetch 缺点</h2><ul><li>当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject，即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve（但是会将 resolve 的返回值的 ok 属性设置为 false），仅当网络故障时或请求被阻止时才会标记为 reject；</li><li>默认情况下，fetch 不会从服务端发送或接收任何 cookies，如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）；</li><li>POST 的数据需要转为 JSON;</li><li>不能设置超时和取消请求，可以通过<code>Promise.race</code>，模拟两者；</li><li>文件上传和下载获取不到进度。response.body 是可读流，具有<code>getReader</code>，可根据这个来获取下载进度；</li><li>不能直接获取到响应数据，需要调用响应方法，resolve 一下；</li></ul><h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>axios 是 Vue 官方推荐使用的，它也是对原生 XHR 的封装。它有以下几大特性：</p><ul><li>可以在 node.js 中使用</li><li>提供了并发请求的接口</li><li>支持 Promise API</li></ul><h2 id="（一）Axios-使用"><a href="#（一）Axios-使用" class="headerlink" title="（一）Axios 使用"></a>（一）Axios 使用</h2><h3 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1. 发送请求"></a>1. 发送请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  url:<span class="string">&#x27;http://bit.ly/2mTM3nY&#x27;</span>,</span><br><span class="line">  responseType:<span class="string">&#x27;stream&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.data.pipe(fs.createWriteStream(<span class="string">&#x27;ada_lovelace.jpg&#x27;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>axios 的用法与 jQuery 的 <code>ajax</code> 方法非常类似，两者都返回一个 Promise 对象（在这里也可以使用成功回调函数，但更推荐使用 <code>Promise</code> 或 <code>await</code>），然后再进行后续操作。</p><h3 id="2-添加拦截器函数"><a href="#2-添加拦截器函数" class="headerlink" title="2. 添加拦截器函数"></a>2. 添加拦截器函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个请求拦截器。注意，这里面有两个函数：分别是成功和失败时的回调函数，这样设计的原因会在之后介绍</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 发起请求前执行一些处理任务</span></span><br><span class="line">    <span class="keyword">return</span> config; <span class="comment">// 返回配置信息</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 请求错误时的处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理响应数据</span></span><br><span class="line">    <span class="keyword">return</span> response; <span class="comment">// 返回响应数据</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 响应出错后所做的处理工作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>发送请求之前，我们可以对请求的配置参数（<code>config</code>）做处理；在请求得到响应之后，我们可以对返回数据做处理。当请求或响应失败时，我们还能指定对应的错误处理函数。</p><h3 id="3-撤销-HTTP-请求"><a href="#3-撤销-HTTP-请求" class="headerlink" title="3. 撤销 HTTP 请求"></a>3. 撤销 HTTP 请求</h3><p>在开发与搜索相关的模块时，我们经常要频繁地发送数据查询请求。一般来说，当发送下一个请求时，需要撤销上个请求。因此，能撤销相关请求的功能非常有用。axios 撤销请求的示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子一</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求撤销了&#x27;</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子二</span></span><br><span class="line">axios.post(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  name: <span class="string">&#x27;新名字&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销请求 (信息参数是可选的)</span></span><br><span class="line">source.cancel(<span class="string">&#x27;用户撤销了请求&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在 axios 中，使用基于 <code>CancelToken</code> 的撤销请求方案。然而该提案现已撤回，详情 <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-cancelable-promises">点这里</a>。具体的撤销请求的实现方法，将在后面的源代码分析的中解释。</p><h2 id="（二）Axios-核心模块"><a href="#（二）Axios-核心模块" class="headerlink" title="（二）Axios 核心模块"></a>（二）Axios 核心模块</h2><p>下面将根据模块分析 axios 的设计和实现。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210614225916.png" alt="image-20210409195435367" style="zoom:67%"><h3 id="HTTP-请求模块"><a href="#HTTP-请求模块" class="headerlink" title="HTTP 请求模块"></a>HTTP 请求模块</h3><p>请求模块的代码放在了 <code>core/dispatchRequest.js</code> 文件中，这里只展示了一些关键代码来简单说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    throwIfCancellationRequested(config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他源码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认适配器是一个模块，可以根据当前环境选择使用 Node 或者 XHR 发送请求。</span></span><br><span class="line">    <span class="keyword">var</span> adapter = config.adapter || defaults.adapter; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adapter(config).then(<span class="function"><span class="keyword">function</span> <span class="title">onAdapterResolution</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        throwIfCancellationRequested(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他源码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> <span class="title">onAdapterRejection</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isCancel(reason)) &#123;</span><br><span class="line">            throwIfCancellationRequested(config);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其他源码</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们能够知道 <code>dispatchRequest</code> 方法是通过 <code>config.adapter</code> 获得发送请求模块的。可以通过传递符合规范的适配器函数来替代原来的模块（一般不会这样做，但它是一个松散耦合的扩展点）。</p><p>在 <code>defaults.js</code> 文件中，我们可以看到相关适配器的选择逻辑——根据当前容器的一些独特属性和构造函数，来确定使用哪个适配器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDefaultAdapter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> adapter;</span><br><span class="line">    <span class="comment">// 只有在 Node.js 中包含 process 类型对象时，才使用它的请求模块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> process !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(process) === <span class="string">&#x27;[object process]&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// Node.js 请求模块</span></span><br><span class="line">        adapter = <span class="built_in">require</span>(<span class="string">&#x27;./adapters/http&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 浏览器请求模块</span></span><br><span class="line">        adapter = <span class="built_in">require</span>(<span class="string">&#x27;./adapters/xhr&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>axios 中的 XHR 模块相对简单，它是对 <code>XMLHTTPRequest</code> 对象的封装，源码位于 <code>adapters/xhr.js</code> 文件中。</p><h3 id="拦截器模块"><a href="#拦截器模块" class="headerlink" title="拦截器模块"></a>拦截器模块</h3><p>现在让我们看看 axios 是如何处理请求和响应拦截器函数的。这就涉及到了 axios 中的统一接口 ——<code>request</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他源码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">        promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数是 axios 发送请求的接口。因为函数实现代码相当长，这里简单讨论相关设计思想：</p><ol><li><code>chain</code> 是一个执行队列。队列的初始值是一个携带配置（<code>config</code>）参数的 Promise 对象。</li><li>在执行队列中，初始函数 <code>dispatchRequest</code> 用来发送请求，为了与 <code>dispatchRequest</code>对应，我们添加了一个 <code>undefined</code>。添加 <code>undefined</code> 的原因是需要给 Promise 提供成功和失败的回调函数，从<code>promise = promise.then(chain.shift(), chain.shift());</code> 就能看出来。因此，函数 <code>dispatchRequest</code> 和 <code>undefiend</code> 可以看成是一对函数。</li><li>在执行队列 <code>chain</code> 中，发送请求的 <code>dispatchReqeust</code> 函数处于中间位置。它前面是请求拦截器，使用 <code>unshift</code> 方法插入；它后面是响应拦截器，使用 <code>push</code> 方法插入，在 <code>dispatchRequest</code> 之后。需要注意的是，这些函数都是成对的，也就是一次会插入两个。</li></ol><h3 id="撤销请求模块"><a href="#撤销请求模块" class="headerlink" title="撤销请求模块"></a>撤销请求模块</h3><p>与撤销请求相关的模块位于 <code>Cancel/</code> 文件夹下，现在我们来看下相关核心代码。</p><p>首先，我们来看下基础 <code>Cancel</code> 类。它是一个用来记录撤销状态的类，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cancel</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cancel.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Cancel&#x27;</span> + (<span class="built_in">this</span>.message ? <span class="string">&#x27;: &#x27;</span> + <span class="built_in">this</span>.message : <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Cancel.prototype.__CANCEL__ = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>使用 <code>CancelToken</code> 类时，需要向它传递一个 Promise 方法，用来实现 HTTP 请求的撤销，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CancelToken</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> executor !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;executor must be a function.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resolvePromise;</span><br><span class="line">    <span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">promiseExecutor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        resolvePromise = resolve;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> token = <span class="built_in">this</span>;</span><br><span class="line">    executor(<span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (token.reason) &#123;</span><br><span class="line">            <span class="comment">// 已经被撤销了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        token.reason = <span class="keyword">new</span> Cancel(message);</span><br><span class="line">        resolvePromise(token.reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CancelToken.source = <span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cancel;</span><br><span class="line">    <span class="keyword">var</span> token = <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        cancel = c;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        token: token,</span><br><span class="line">        cancel: cancel</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>adapters/xhr.js</code> 文件中，撤销请求的地方是这样写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line">    <span class="comment">// 等待撤销</span></span><br><span class="line">    config.cancelToken.promise.then(<span class="function"><span class="keyword">function</span> <span class="title">onCanceled</span>(<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.abort();</span><br><span class="line">        reject(cancel);</span><br><span class="line">        <span class="comment">// 重置请求</span></span><br><span class="line">        request = <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的撤销 HTTP 请求的例子，让我们简要地讨论一下相关的实现逻辑：</p><ol><li>在需要撤销的请求中，调用 <code>CancelToken</code> 类的 <code>source</code> 方法类进行初始化，会得到一个包含 <code>CancelToken</code> 类实例 A 和 <code>cancel</code> 方法的对象。</li><li>当 source 方法正在返回实例 A 的时候，一个处于 pending 状态的 <code>promise</code> 对象初始化完成。在将实例 A 传递给 axios 之后，<code>promise</code> 就可以作为撤销请求的触发器使用了。</li><li>当调用通过 <code>source</code> 方法返回的 <code>cancel</code> 方法后，实例 A 中 <code>promise</code> 状态从 pending 变成 fulfilled，然后立即触发 <code>then</code> 回调函数。于是 axios 的撤销方法——<code>request.abort()</code> 被触发了。</li></ol><h2 id="axios-这样设计的好处是什么？"><a href="#axios-这样设计的好处是什么？" class="headerlink" title="axios 这样设计的好处是什么？"></a>axios 这样设计的好处是什么？</h2><h3 id="发送请求函数的处理逻辑"><a href="#发送请求函数的处理逻辑" class="headerlink" title="发送请求函数的处理逻辑"></a>发送请求函数的处理逻辑</h3><p>如前几章所述，axios 不将用来发送请求的 <code>dispatchRequest</code> 函数看做一个特殊函数。实际上，<code>dispatchRequest</code> 会被放在队列的中间位置，以便保证队列处理的一致性和代码的可读性。</p><h3 id="适配器的处理逻辑"><a href="#适配器的处理逻辑" class="headerlink" title="适配器的处理逻辑"></a>适配器的处理逻辑</h3><p>在适配器的处理逻辑上，<code>http</code> 和 <code>xhr</code> 模块（一个是在 Node.js 中用来发送请求的，一个是在浏览器里用来发送请求的）并没有在 <code>dispatchRequest</code> 函数中使用，而是各自作为单独的模块，默认通过 <code>defaults.js</code> 文件中的配置方法引入的。因此，它不仅确保了两个模块之间的低耦合，而且还为将来的用户提供了定制请求发送模块的空间。</p><h3 id="撤销-HTTP-请求的逻辑"><a href="#撤销-HTTP-请求的逻辑" class="headerlink" title="撤销 HTTP 请求的逻辑"></a>撤销 HTTP 请求的逻辑</h3><p>在撤销 HTTP 请求的逻辑中，axios 设计使用 Promise 来作为触发器，将 <code>resolve</code> 函数暴露在外面，并在回调函数里使用。它不仅确保了内部逻辑的一致性，而且还确保了在需要撤销请求时，不需要直接更改相关类的样例数据，以避免在很大程度上入侵其他模块。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JavaScript/" rel="tag"># JavaScript</a> <a href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag"># 异步</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E7%B1%BB%E5%9E%8B/%E6%95%B0%E7%BB%84/" rel="prev" title="JS 数组常见需求"><i class="fa fa-chevron-left"></i> JS 数组常见需求</a></div><div class="post-nav-item"><a href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/eslint%20%E9%85%8D%E7%BD%AE/" rel="next" title="eslint 和 prettier 配置">eslint 和 prettier 配置 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></div></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){const e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">mohui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">557k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">8:26</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>