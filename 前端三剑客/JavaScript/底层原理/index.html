<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"baimohui.github.io",root:"/",images:"/images",scheme:"Muse",version:"8.2.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12},copycode:!1,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"}}</script><meta name="description" content="一、原型和原型链"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript 底层原理"><meta property="og:url" content="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.html"><meta property="og:site_name" content="白抹灰"><meta property="og:description" content="一、原型和原型链"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233852.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233853.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233854.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233855.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233856.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233857.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233858.png"><meta property="article:published_time" content="2023-04-01T05:49:11.804Z"><meta property="article:modified_time" content="2023-07-11T05:41:31.047Z"><meta property="article:author" content="mohui"><meta property="article:tag" content="JavaScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233852.png"><link rel="canonical" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>JavaScript 底层原理 | 白抹灰</title><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">白抹灰</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-text">一、原型和原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">二、作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-text">三、执行上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A0-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88"><span class="nav-text">① 执行上下文栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A1-%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="nav-text">② 变量对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="nav-text">全局上下文中的全局对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="nav-text">函数上下文中的活动对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="nav-text">块作用域与暂时性死区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#let%E3%80%81const-%E5%92%8C-var-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">let、const 和 var 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-text">练习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A2-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="nav-text">③ 作用域链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A3-this-%E6%8C%87%E5%90%91"><span class="nav-text">④ this 指向</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A0-Reference"><span class="nav-text">Ⅰ. Reference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A1-%E5%A4%8D%E6%9D%82%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">Ⅱ. 复杂表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A2-%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="nav-text">Ⅲ. 判定方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-1"><span class="nav-text">练习题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E9%97%AD%E5%8C%85"><span class="nav-text">四、闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%8F%82%E6%95%B0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-text">五、参数按值传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">六、类数组对象</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">mohui</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">75</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">77</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JavaScript 底层原理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-04-01 13:49:11" itemprop="dateCreated datePublished" datetime="2023-04-01T13:49:11+08:00">2023-04-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-07-11 13:41:31" itemprop="dateModified" datetime="2023-07-11T13:41:31+08:00">2023-07-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>22k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>20 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="一、原型和原型链"><a href="#一、原型和原型链" class="headerlink" title="一、原型和原型链"></a>一、原型和原型链</h2><a id="more"></a><p><strong>prototype</strong></p><p>如下所示，我们用构造函数 <code>Person()</code> new 了一个实例对象 person。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">&#x27;Kevin&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>每个 JS 对象（null 除外）在创建时会与一个叫做原型的对象关联，每个对象都会从原型继承属性。prototype 是函数独有的属性，它指向该构造函数所创建的实例对象的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Person 的 prototype 指向 person1 和 person2 的原型</span></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Kevin&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>用<code>Person.prototype</code>表示实例原型，则构造函数和实例原型的关系如下：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233852.png" alt="image-20210515091954495" style="zoom:67%"><p><strong><code>__proto__</code></strong></p><p>每个 JS 对象（null 除外）都有一个叫做 <code>__proto__</code> 的属性，这个属性会指向该对象的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>于是关系图更新如下：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233853.png" alt="image-20210515095146933" style="zoom:67%"><p><strong>constructor</strong></p><p>每个实例原型都有一个 constructor 属性指向关联的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>关系图更新如下：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233854.png" alt="image-20210515095646355" style="zoom:67%"><p>综上我们已经得出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个 ES5 的方法，可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>原型的原型</strong></p><p>当读取实例的属性时，如果实例没有该属性，那么就会去查找实例原型中的属性，如果还查不到，就去找实例原型的原型，一直找到最顶层为止。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Kevin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">&#x27;Daisy&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Daisy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>在上例中，给实例对象 person 添加了 name 属性，当打印 person.name 时，结果自然为 Daisy。但是当删除了 person 的 name 属性时，再次读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 <code>person.__proto__</code> ，即<code>Person.prototype</code>中查找，结果为 Kevin。但如果还没有找到，则会去查找原型的原型。</p><p>因为实例原型本身就是一个对象，既然是对象，就可以用最原始的方式创建它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">&#x27;Kevin&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>原型对象就是通过 Object 构造函数生成的，根据实例的 <code>__proto__</code> 指向构造函数的 prototype，关系图更新如下：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233855.png" alt="image-20210515103525663" style="zoom:67%"><p><strong>原型链</strong></p><p><code>Object.prototype</code> 的原型则指向 null：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>null 表示没有对象，即该处不应有值。 <code>Object.prototype.__proto__</code> 的值为 null，也就说明 <code>Object.prototype</code> 没有原型。最终的关系图更新如下，图中的蓝线即为原型链。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233856.png" alt="image-20210515104256297" style="zoom:67%"><p><strong>补充</strong></p><p>① 当获取 <code>person.constructor</code> 时，其实 person 中并没有 constructor 属性。当不能读取到 constructor 属性时，会从 person 的原型也就是 <code>Person.prototype</code> 中读取到该属性，所以 <code>person.constructor === Person.prototype.constructor</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>② 绝大多数浏览器都支持用 <code>__proto__</code> 访问原型，但这个属性其实来自于 <code>Object.prototype</code>。与其说它是一个属性，不如说是一个 getter/setter，当使用 <code>obj.__proto__</code> 时，可以理解成返回了 <code>Object.getPrototypeOf(obj)</code>。</p><p>③ 前面讲到每个对象都会从原型继承属性，实际上继承是个具有迷惑性的说法。继承意味着复制操作，然而 JS 默认并不会复制对象的属性，相反 JS 只是在两个对象间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。</p><p>④ Objects created using <code>Object.create()</code></p><p>空对象也有原型，但 <code>Object.create(null)</code> 创造的对象没有。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> literalObject = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> nullObject  = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">nullObject.name = <span class="string">&#x27;My object&#x27;</span>;</span><br><span class="line"></span><br><span class="line">literalObject <span class="keyword">instanceof</span> <span class="built_in">Object</span>;   </span><br><span class="line"><span class="comment">// true, every object literal has Object.prototype as prototype</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span>;   </span><br><span class="line"><span class="comment">// true, same case as above</span></span><br><span class="line">nullObject <span class="keyword">instanceof</span> <span class="built_in">Object</span>;   </span><br><span class="line"><span class="comment">// false, prototype is end of prototype chain (null)</span></span><br></pre></td></tr></table></figure><h2 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h2><p>作用域是指一个<strong>变量和函数的作用范围</strong>，它分为词法作用域和动态作用域。JS 采用词法作用域（lexical scoping，也称静态作用域）。</p><ul><li>静态作用域：函数的作用域在函数定义时就确定。</li><li>动态作用域：函数的作用域在函数调用时才确定。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><p>JS 采用静态作用域，所以上例 foo 函数在执行时，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据定义的位置查找上一层的代码 <code>var value = 1;</code>，所以结果打印 1。</p><p>注意，上一层的代码范围是包含在 foo 函数后面才声明的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(a+b); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>假设 JS 采用动态作用域，则执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用该函数的作用域，即 bar 函数内查找 value 变量，所以结果打印 2。</p><p>注：有时候会想通过在外部引入的自定义 js 方法里面来修改当前页面的一些属性值，然而由于 js 采用静态作用域，外部函数方法中的 this 并不能获取到当前页面的属性。所以不能这么做。</p><p><strong>题目</strong>：两个函数的打印结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>两段代码都会打印：<code>local scope</code>，因为 JS 采用词法作用域，函数的作用域基于其创建的位置。</p><h2 id="三、执行上下文"><a href="#三、执行上下文" class="headerlink" title="三、执行上下文"></a>三、执行上下文</h2><h3 id="①-执行上下文栈"><a href="#①-执行上下文栈" class="headerlink" title="① 执行上下文栈"></a>① 执行上下文栈</h3><p>JS 的可执行代码（executable code）分为三种：全局代码、函数代码、eval 代码。每当执行一个函数，就会创建一个执行上下文（execution contexts）。每个执行上下文包含三个重要属性：变量对象（Variable object，VO）、作用域链（Scope chain）、this。为了方便管理这些执行上下文，JS 引擎创建了执行上下文栈（execution context stack，ECStask）。</p><p>在此假设执行上下文栈是一个数组，以便模拟其行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [];</span><br></pre></td></tr></table></figure><p>JS 解释执行代码时最先遇到全局代码，所以初始化时先向 ECStack 压入全局执行上下文 <code>globalContext</code>。只有当整个程序结束时 <code>ECStack</code> 才会被清空，即 <code>ECStack</code> 栈底只能放 <code>globalContext</code>。当执行一个函数时，就会创建一个 EC，并将其压入 ECStack。当函数执行完毕时，就将其从栈中弹出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>当 JS 遇到如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fun3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure><p>其执行上下文栈经历的过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 fun1()，将其 EC 入栈</span></span><br><span class="line">ECStack.push(&lt;fun1&gt; functionContext);</span><br><span class="line"><span class="comment">// fun1 中调用了 fun2，将 fun2 的 EC 入栈</span></span><br><span class="line">ECStack.push(&lt;fun2&gt; functionContext);</span><br><span class="line"><span class="comment">// 同理，将 func3 的 EC 入栈</span></span><br><span class="line">ECStack.push(&lt;fun3&gt; functionContext);</span><br><span class="line"><span class="comment">// fun3 执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"><span class="comment">// fun2 执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"><span class="comment">// fun1 执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"><span class="comment">// js 接着执行接下来的代码，但 ECStack 栈底永远有个 globalContext</span></span><br></pre></td></tr></table></figure><p><strong>题目</strong>：两个函数在处理执行上下文的区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ECStack.push(&lt;checkscope&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.push(&lt;f&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ECStack.push(&lt;checkscope&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br><span class="line"><span class="comment">// ECStack.push(&lt;f&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br></pre></td></tr></table></figure><h3 id="②-变量对象"><a href="#②-变量对象" class="headerlink" title="② 变量对象"></a>② 变量对象</h3><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。全局上下文和函数上下文的变量对象稍有不同，这里分开讨论。</p><h4 id="全局上下文中的全局对象"><a href="#全局上下文中的全局对象" class="headerlink" title="全局上下文中的全局对象"></a>全局上下文中的全局对象</h4><p>由 <code>var</code> 声明的全局变量会作为全局对象的成员被脚本创建。<strong>全局对象就是全局上下文中的变量对象</strong>，即作用域链的头。在 web 浏览器中，<code>window</code> 对象就是浏览器的全局对象，任何全局变量或全局函数都能作为 <code>window</code> 的属性来访问。</p><p>Ⅰ. 全局对象可以通过 this 引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); </span><br><span class="line"><span class="comment">// Window &#123;0: Window, window: Window, self: Window, document: document, name: &#x27;&#x27;, location: Location, …&#125;</span></span><br></pre></td></tr></table></figure><p>Ⅱ. 全局对象是 Object 构造函数的一个实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Ⅲ. 全局对象预定义了许多函数和属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.Math.random());</span><br></pre></td></tr></table></figure><p>Ⅳ. 全局对象作为全局变量的宿主。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br></pre></td></tr></table></figure><p>Ⅴ. 浏览器的全局对象有 window 属性指向自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line"><span class="built_in">this</span>.window.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br></pre></td></tr></table></figure><h4 id="函数上下文中的活动对象"><a href="#函数上下文中的活动对象" class="headerlink" title="函数上下文中的活动对象"></a>函数上下文中的活动对象</h4><p>在函数上下文中，用活动对象（activation object, AO）来表示变量对象。两者本质相同，区别在于变量对象是规范上或引擎实现上的，不能在 JS 环境中访问。当进入一个 EC 时，EC 的变量对象会被激活为 AO，这时其上的各种属性（如形参、变量声明）才能被访问。</p><p>所有的 JS 代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能只有几微秒不到），紧接着这段代码就会被执行。</p><p>函数上下文的变量对象在初始化时只包含 Arguments 对象。在进入 EC 进行编译时，js 引擎会搜集形参以及<strong>变量和函数的声明</strong>，并提前将其赋给变量对象。在代码执行阶段，会按照执行顺序依次修改变量对象的属性值。</p><p><strong>Ⅰ. 进入 EC</strong></p><p>当刚进入 EC，还未执行代码时，变量对象的属性包括：</p><p>① 函数形参（如果是函数上下文）：由名称和对应值组成。如果没有实参，对应值设为 undefined</p><p>② 函数声明：由名称和对应值（函数对象，function-object）组成。如果变量对象已存在同名的属性，则将其完全替换</p><p>③ var 变量声明：由名称和对应值（undefined）组成。变量声明不会干扰到已声明的同名形参或函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，上例的 AO 是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Ⅱ. 代码执行</strong></p><p>在代码执行阶段会顺序执行代码，根据代码修改变量对象的值。当代码执行完后，上例的 AO 变为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression <span class="string">&#x27;d&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="块作用域与暂时性死区"><a href="#块作用域与暂时性死区" class="headerlink" title="块作用域与暂时性死区"></a>块作用域与暂时性死区</h4><p>与 var 不同，let 和 const 不存在变量提升。这是因为早期的声明提升机制可能会带来误操作：那些忘记被声明的变量无法在开发阶段被明显地察觉出来，而是以 undefined 这样危险的形式藏匿在你的代码里。为了减少运行时错误，防止带来不可预知的问题，ES6 特意将<strong>声明前不可用</strong>这一点做了强约束。</p><p>块作用域是伴随 ES6 而生的一个概念。我们把被一对花括号括起来的代码称为一个代码块，被这个代码块圈起来的变量集，就是块作用域。</p><p>当用 let 和 const 声明变量时，变量会被绑定到块作用域上，而 var 是不感知块作用域的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Terry&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// &#x27;Terry&#x27; </span></span><br><span class="line"><span class="built_in">console</span>.log(gender) <span class="comment">// Uncaught ReferenceError: gender is not defined</span></span><br></pre></td></tr></table></figure><p>如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。当在声明前去使用这类变量时，就会报错，哪怕作用域链中有父级 EC 存在同名的变量。这个区块中位于变量声明前的区域就叫<strong>暂时性死区</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Terry&#x27;</span>;</span><br><span class="line">&#123;</span><br><span class="line">  name = <span class="string">&#x27;lee&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Cannot access &#x27;name&#x27; before initialization</span></span><br></pre></td></tr></table></figure><h4 id="let、const-和-var-的区别"><a href="#let、const-和-var-的区别" class="headerlink" title="let、const 和 var 的区别"></a>let、const 和 var 的区别</h4><ul><li>var 定义的变量，不存在块作用域，可以跨块访问，但不能跨函数访问；let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问；const 用来定义常量，使用时必须初始化，只能在块作用域里访问，不能修改</li><li>var 可以先使用后声明，因为存在变量提升；let 必须先声明后使用，并且会出现暂时性死区</li><li>var 允许在相同作用域内重复声明同一个变量</li><li>在全局上下文中，基于 let 声明的全局变量和全局对象 GO（window）没有任何关系。var 声明的变量会和 GO 有映射关系</li><li>let 和 const 会把当前所在的大括号 (除函数之外) 作为一个全新的块级上下文。当遇到循环事件绑定等类似需求，无需再构建闭包来存储，只要基于 let 的块作用特征即可解决<h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4></li></ul><p><strong>题目一</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fin(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">bts(); <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>foo()</code>：报错是因为函数中的 <code>a</code> 没有通过 var 关键字声明，也就没有产生变量提升，因而没有被存放在 AO 中。当执行到 console，此时 AO 的值如下。没有 a 的值，然后就到全局去找，全局也没有，所以报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        length: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fin()</code>：函数中的 a 通过变量提升，相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fin</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> a; </span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">    a=<span class="number">1</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><code>bar()</code>：当执行到 console 时，bar 函数的活动对象已经添加了 a 属性，所以打印 1。</p><p><strong>题目二</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 打印：[Function: foo]</span></span><br></pre></td></tr></table></figure><p>在进入 EC 时，首先处理函数声明，其次处理变量声明。如果变量跟函数重名，则变量声明不会干扰函数声明，相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> foo; <span class="comment">//这里只是声明，并不会影响 foo 的值 </span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//输出 foo 函数 </span></span><br><span class="line">foo = <span class="number">1</span>; </span><br></pre></td></tr></table></figure><p><strong>题目三</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="comment">// 打印：1</span></span><br></pre></td></tr></table></figure><p>先函数提升，再变量提升，相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> foo; <span class="comment">//这里只是声明，并不会影响 foo 的值 </span></span><br><span class="line">foo = <span class="number">1</span>; </span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p><strong>题目四</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Rose&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Say &#x27;</span> + name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：Say Jack</span></span><br><span class="line"><span class="comment">// 函数表达式内的 var 变量声明也会产生变量提升，会被提升到该函数作用域的顶部并初始化为 undefined</span></span><br></pre></td></tr></table></figure><h3 id="③-作用域链"><a href="#③-作用域链" class="headerlink" title="③ 作用域链"></a>③ 作用域链</h3><p>当查找变量时，会先从当前 EC 的变量对象中查找，如果没有找到，就会从父级 EC 的变量对象中查找，一直找到全局上下文的变量对象（即全局对象）。这样由多个 EC 的<strong>变量对象</strong>构成的链表就叫作用域链。</p><p>下面以函数的创建和激活两个阶段来说明作用域链是如何创建和变化的。</p><p><strong>函数创建阶段</strong></p><p>JS 采用静态作用域，函数的作用域在函数定义时便已确定。这是因为当函数被创建时，函数有一个内部属性 <code>[[scope]]</code> 会保存所有父级 EC 的变量对象。注意，它不是完整的作用域链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数创建时，各自的 <code>[[scope]]</code> 为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>函数激活阶段</strong></p><p>当进入函数上下文后，会将新创建的 AO 添加到作用域链的头部。即该 EC 最终完整的作用域链为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><hr><p><strong>题目</strong>：分析 <code>checkscope()</code> 的执行过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope2 = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>Ⅰ. <code>checkscope</code> 函数被创建，在其 <code>[[scope]]</code> 属性中添加父级 EC 的变量对象；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>Ⅱ. 创建 <code>checkscope</code> 函数的 EC，并将其压入 ECStack；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>Ⅲ. 执行函数前，复制函数的 <code>[[scope]]</code> 属性到 EC 中，创建作用域链；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>活动对象由 arguments 初始化，随后加入形参、函数声明、变量声明；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: checkscope.[[scope]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将该 EC 的 AO 压入 <code>checkscope</code> 作用域链头部；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ⅳ. 开始执行函数，修改 AO 的属性值；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: <span class="string">&#x27;local scope&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ⅴ. 返回 scope2 的值后函数执行完毕，将该 EC 从 ECStack 中弹出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="④-this-指向"><a href="#④-this-指向" class="headerlink" title="④ this 指向"></a>④ this 指向</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar());</span><br></pre></td></tr></table></figure><p>简述：<code>foo.bar()</code>的复杂表达式为 foo.bar，不涉及计算，所以属于 reference。其 basevalue 为 foo，属于对象，则 this 指向该对象。</p><h4 id="Ⅰ-Reference"><a href="#Ⅰ-Reference" class="headerlink" title="Ⅰ. Reference"></a>Ⅰ. Reference</h4><p>ECMAScript 规范定义的类型分为语言类型和规范类型。</p><ul><li>语言类型是开发者能使用 ECMAScript 语言直接操作其值的，分为 Undefined、Null、Boolean、String、Number 和 Object。</li><li>规范类型可以使用算法来描述 ECMAScript 语言结构和语言类型。规范类型包括：Reference、List、Completion、Property Descriptor、Property Identifier、Lexical Environment 和 Environment Record。</li></ul><p>由上可知，ECMAScript 规范中定义了一种不存在实际 js 代码中的类型，它的作用是为了更好地描述语言底层行为逻辑。而其中的 Reference 类型便与 this 的指向密切相关，它用来解释诸如 delete、<code>typeof</code> 和赋值等操作行为。</p><p>Reference 由如下三个部分构成：</p><ul><li>base value：属性所在的对象，该值的类型只能是 Undefined、Object、Boolean、String、Number 或 <code>EnvironmentRecord</code>。</li><li>reference name：属性名。</li><li>strict reference</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的 Reference</span></span><br><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    strict: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar(); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bar 对应的 Reference</span></span><br><span class="line"><span class="keyword">var</span> BarReference = &#123;</span><br><span class="line">    base: foo,</span><br><span class="line">    propertyName: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">    strict: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>GetValue()</code></strong></p><p>该方法返回 Reference 对象真正的值，而非 Reference 自身。当<u>函数调用表达式</u>中包含位运算符（如&amp;）、逻辑运算符（如&amp;&amp;）、条件运算符（a?b:c)、赋值运算符（如=）、等值运算符（如==）、比较运算符（如&lt;）、移位运算符（如&lt;&lt;）、逗号运算符、加减乘除运算符，也就是涉及计算时，都会使用到该方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    strict: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line">GetValue(fooReference) <span class="comment">// 1;</span></span><br></pre></td></tr></table></figure><p>创建 Reference 有两种途径：<strong>标识符解析</strong>和<strong>属性访问</strong>。比如 foo 和 foo.bar 能创建 Reference，而字面量和函数表达式以及包含上述运算符的表达式却不会。具体可参考下图：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233857.png" alt="image-20210516093949501" style="zoom:67%"><h4 id="Ⅱ-复杂表达式"><a href="#Ⅱ-复杂表达式" class="headerlink" title="Ⅱ. 复杂表达式"></a>Ⅱ. 复杂表达式</h4><p>原始表达式（PrimaryExpression）是表达式的最小单位，它不再包含其他表达式。原始表达式分为字面量、关键字和变量，具体包括 this 关键字、标识符引用、字面量引用、数组初始化、对象初始化和分组表达式。</p><p>而<strong>复杂表达式</strong>（MemberExpression）由原始表达式和操作符组成，包括属性访问表达式、对象创建表达式和函数表达式。</p><ul><li><code>FunctionExpression</code> 函数定义</li><li><code>MemberExpression[Expression]</code> 属性访问</li><li><code>MemberExpression.IdentifierName</code> 属性访问</li><li><code>new MemberExpression(Arguments)</code> 对象创建</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// MemberExpression 是 foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo()(); <span class="comment">// MemberExpression 是 foo()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.bar(); <span class="comment">// MemberExpression 是 foo.bar</span></span><br></pre></td></tr></table></figure><p>可以认为 MemberExpression 是函数调用时<code>()</code>左边的部分。</p><h4 id="Ⅲ-判定方法"><a href="#Ⅲ-判定方法" class="headerlink" title="Ⅲ. 判定方法"></a>Ⅲ. 判定方法</h4><p>ECMAScript 规范说明了当函数被调用时，如何确定 this 的取值。将 ref 作为 MemberExpression 的计算结果，则有：</p><ul><li><p>如果 ref 是 Reference 类型，并且 base value 值是一个对象，那么 this 值为 base value；</p></li><li><p>如果 ref 是 Reference 类型，并且 base value 值是 <code>EnvironmentRecord</code>，那么 this 值为 undefined；</p></li><li><p>如果 ref 不是 Reference 类型，那么 this 值为 undefined。</p><hr></li></ul><h4 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例 1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar());</span><br><span class="line"><span class="comment">//例 2</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar)());</span><br><span class="line"><span class="comment">//例 3</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar = foo.bar)());</span><br><span class="line"><span class="comment">//例 4</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">false</span> || foo.bar)());</span><br><span class="line"><span class="comment">//例 5</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar, foo.bar)());</span><br><span class="line"><span class="comment">//例 6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">fin();</span><br></pre></td></tr></table></figure><p><strong>例 1：<code>foo.bar()</code></strong></p><p>ME 计算结果为 foo.bar，属于 Reference 类型，值为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BarReference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  name: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  strict: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>base value 为 foo，是一个对象，所以 this 指向 <code>foo &#123; value: 2, bar: [Function: bar] &#125;</code>。打印 2。</p><p><strong>例 2：<code>(foo.bar)()</code></strong></p><p><code>()</code>并没有对 ME 进行计算，所以结果跟例 1 一样。</p><p><strong>例 3：<code>(foo.bar = foo.bar)()</code></strong></p><p>存在赋值运算符，即运算过程中会使用<code>GetValue()</code>，所以返回值不是 Reference 类型，则 this 指向 undefined，undefined 自然不存在 value 属性，则打印 undefined。非严格模式下，当 this 值为 undefined 时，其值会被隐式转换为全局对象，打印 1。</p><p><strong>例 4：<code>(false || foo.bar)()</code></strong></p><p>存在逻辑运算符，即运算过程中会使用<code>GetValue()</code>，所以返回值不是 Reference 类型，则 this 指向 undefined，打印 undefined。非严格模式下打印 1。</p><p><strong>例 5：<code>(foo.bar, foo.bar)()</code></strong></p><p>存在逗号运算符，即运算过程中会使用<code>GetValue()</code>，所以返回值不是 Reference 类型，则 this 指向 undefined，打印 undefined。非严格模式下打印 1。</p><p><strong>例 6：<code>fin()</code></strong></p><p>ME 计算结果为 fin，属于 Reference 类型，值为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    strict: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>base value 为 <code>EnvironmentRecord</code>，所以 this 指向 undefined，打印 undefined。非严格模式打印 1。</p><p><strong>例 7：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    doSth: doSth</span><br><span class="line">&#125;</span><br><span class="line">ming.doSth()</span><br></pre></td></tr></table></figure><p><strong>例 8：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">let</span> fn = create();</span><br><span class="line">fn(); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 在全局上下文中，基于 let 声明的全局变量和全局对象 GO（window）没有任何关系。</span></span><br></pre></td></tr></table></figure><p><strong>例 9：<code>setTimeout()</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   num: <span class="number">20</span>,</span><br><span class="line">   hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.num);    <span class="comment">// 20</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.num);    <span class="comment">// 10</span></span><br><span class="line">    &#125;);</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// setTimeout 里匿名函数没有直接调用者，this 指向 window</span></span><br></pre></td></tr></table></figure><p><strong>例 10：箭头函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    a: <span class="string">&#x27;bbb&#x27;</span>,</span><br><span class="line">    test1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    test2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">a</span>: <span class="string">&#x27;ccc&#x27;</span> &#125;</span><br><span class="line">obj2.test2 = obj1.test2</span><br><span class="line">obj1.test1() <span class="comment">// aaa</span></span><br><span class="line">obj1.test2() <span class="comment">// bbb</span></span><br><span class="line">obj2.test2() <span class="comment">// ccc</span></span><br><span class="line"><span class="comment">// 箭头函数没有自己的 this，它的 this 是捕获其所在上下文的 this 值，作为自己的 this 值</span></span><br></pre></td></tr></table></figure><p><strong>例 11：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 JavaScript 中，下面选项关于 this 描述正确的是（A）</span><br><span class="line">A. 在使用 new 实例化对象时，this 指向这个实例对象</span><br><span class="line">B. 将对象的方法赋值给变量 A。执行 A() 时，该方法中的 this 指向这个对象 </span><br><span class="line">C. 在函数定义时，this 指向全局变量</span><br><span class="line">D. 在浏览器下的全局范围内，this 指向全局对象</span><br></pre></td></tr></table></figure><p>在浏览器的 JavaScript 中，在全局范围内，this 指向全局对象 (通常是 window 对象)。在非严格模式下，如果没有明确指定，this 会被默认绑定到全局对象上。在严格模式下，this 将是 undefined。</p><h2 id="四、闭包"><a href="#四、闭包" class="headerlink" title="四、闭包"></a>四、闭包</h2><p>MDN 将闭包定义为能够访问自由变量的函数。而自由变量是指在函数中使用的，但不是函数参数或函数局部变量的变量。即闭包 = 函数 + 函数能够访问的自由变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上例中，foo 函数可以访问变量 a，但 a 既非 foo 函数的局部变量，也不是函数参数，所以 a 是自由变量，foo 函数和其访问的 a 便构成了闭包。理论上所有的 JS 函数都是闭包，因为它们都在创建时保存了父级 EC 的变量对象。而从实际开发角度看，以下函数才算闭包：</p><ul><li>即使创建闭包的上下文已经销毁，它仍然存在（比如内部函数从父函数中返回）</li><li>在代码中引用了自由变量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = checkscope();</span><br><span class="line">foo(); <span class="comment">// &#x27;local scope&#x27;</span></span><br></pre></td></tr></table></figure><p>上例中 EC 的简要变化过程如下：</p><ol><li>进入全局代码，创建全局执行上下文，并将其压入 ECStack；</li><li>全局执行上下文初始化；</li><li>执行 <code>checkscope()</code>，创建该函数的 EC，并将其压入 ECStack；</li><li>checkscope 的 EC 初始化，创建变量对象、作用域链、this 等；</li><li>checkscope 函数执行完毕，将其 EC 从 ECStack 中弹出；</li><li>执行 <code>f()</code>，创建 f 函数的 EC，并将其压入 ECStack；</li><li>f 的 EC 初始化，创建变量对象、作用域链、this 等；</li><li>f 函数执行完毕，将其 EC 从 ECStack 中弹出。</li></ol><p>当执行 f 函数时，checkscope 的 EC 已被销毁（从 ECStack 中弹出），但仍能读取到 checkscope 作用域下的 scope 属性。这是因为 f 函数的 EC 保存了作用域链：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使 checkscopeContext 被销毁，但 JS 仍会把 f 函数引用的 checkscopeContext.AO 保留在内存中，f 函数也就能通过其作用域链找到 checkscopeContext.AO 的值。闭包正因此机制才得以实现。</p><p><strong>应用</strong><br>闭包最⼤的作⽤就是隐藏变量，闭包的⼀⼤特性就是内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被销毁之后。基于此特性，JavaScript 可以实现私有变量、特权变量、储存变量等。就以实现私有变量举例：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903748997742605">浅谈 class 私有变量</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;bobby&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.getName =</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> guy = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(guy.getName()) <span class="comment">// bobby</span></span><br><span class="line">guy.setName(<span class="string">&#x27;jenifer&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(guy.getName()) <span class="comment">// jenifer</span></span><br></pre></td></tr></table></figure><p>函数体内的 name 只有 getName 和 setName 两个函数可以访问，外部⽆法访问，相对于将变量私有化。</p><p><strong>题目 1</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数前，全局上下文的 VO 为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数时，data[0] 函数的作用域链为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    Scope: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 没有 i 值，所以从 globalContext.VO 中查找到 i，打印 3。data[1] 和 data[2] 同理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包版本</span></span><br><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    data[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数前，全局上下文的 VO 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext &#x3D; &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数时，data[0] 函数的作用域链发生改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    Scope: [AO, 匿名函数Context.AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数的 EC 的 AO 添加了函数参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匿名函数Context = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        i: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 没有 i 值，于是沿着作用域链从匿名函数 Context.AO 中查找到 i，打印 0。data[1] 和 data[2] 同理，分别打印 1 和 2。</p><p><strong>题目 2</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Rose&#x27;</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span>, name)</span><br></pre></td></tr></table></figure><h2 id="五、参数按值传递"><a href="#五、参数按值传递" class="headerlink" title="五、参数按值传递"></a>五、参数按值传递</h2><p>ECMAScript 中所有函数的参数都是<strong>按值传递</strong>：函数的形参是被调用时所传实参的副本，修改形参的值并不会影响实参。下例中，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 _value，则函数中修改的都是 _value 的值，不会影响到 value 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    v = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(value);</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但当值是一个复杂的数据结构时，拷贝会产生性能问题。所以还有一种传递方式叫<strong>按引用传递</strong>：传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o.value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(o.value); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>前面说 ECMAScript 中所有函数的参数都是按值传递，而上例看起来却像是按引用传递。其实这是<strong>按共享传递</strong>：当传递的是对象时，传递对象的引用的副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(o); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>所以修改 o.value 时，可以通过引用找到原值。但直接修改 o，不会影响到原值。**参数如果是基本类型则按值传递，如果是引用类型则按共享传递’**但因为拷贝副本本身也是一种值拷贝，所以也可认为是按值传递。</p><h2 id="六、类数组对象"><a href="#六、类数组对象" class="headerlink" title="六、类数组对象"></a>六、类数组对象</h2><p>类数组对象包含 length 属性和若干索引属性。在客户端 JS 中，一些 DOM 方法（如<code>document.getElementsByTagName()</code>）返回的就是类数组对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组对象</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>];</span><br><span class="line"><span class="comment">// 类数组对象</span></span><br><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;age&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;sex&#x27;</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从读写、获取长度、遍历三方面来看，数组与类数组并无二致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]); <span class="comment">// name</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayLike[<span class="number">0</span>]); <span class="comment">// name</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">&#x27;new name&#x27;</span>;</span><br><span class="line">arrayLike[<span class="number">0</span>] = <span class="string">&#x27;new name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度</span></span><br><span class="line"><span class="built_in">console</span>.log(array.length); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayLike.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arrayLike.length; i &lt; len; i++) &#123; &#125;</span><br></pre></td></tr></table></figure><p>但类数组对象不能使用数组的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayLike.push(<span class="string">&#x27;4&#x27;</span>); <span class="comment">//error: arrayLike.push is not a function</span></span><br></pre></td></tr></table></figure><p>可以使用 <code>Array.prototype.func.call()</code> 让类数组间接调用数组方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;<span class="number">0</span>: <span class="string">&#x27;name&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;age&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;sex&#x27;</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(arrayLike, <span class="string">&#x27;&amp;&#x27;</span>); <span class="comment">// name&amp;age&amp;sex</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.map.call(arrayLike, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item.toUpperCase();</span><br><span class="line">&#125;); <span class="comment">// [&#x27;NAME&#x27;, &#x27;AGE&#x27;, &#x27;SEX&#x27;]</span></span><br></pre></td></tr></table></figure><p>数组的一些方法还能让类数组转成数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;<span class="number">0</span>: <span class="string">&#x27;name&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;age&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;sex&#x27;</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike); </span><br><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike)</span><br><span class="line"><span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;sex&#x27;] </span></span><br></pre></td></tr></table></figure><p>其实 Arguments 对象也是一种类数组对象。它只定义在函数体中，包括了函数的参数和其他属性。在函数体中，<code>arguments</code> 指代该函数的 Arguments 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上例打印结果如下：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233858.png" alt="image-20210519225713752" style="zoom:50%"><p><strong>length 属性</strong></p><p>Arguments 对象的 length 属性，表示实参的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b, c, d</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;实参的长度为：&#x27;</span> + <span class="built_in">arguments</span>.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;形参的长度为：&#x27;</span> + foo.length)</span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参的长度为：3</span></span><br><span class="line"><span class="comment">// 实参的长度为：1</span></span><br></pre></td></tr></table></figure><p><strong>callee 属性</strong></p><p>Arguments 对象的 callee 属性，通过它可以调用函数自身。讲个闭包经典面试题使用 callee 的解决方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.i) </span><br><span class="line">    &#125;).i = i;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>arguments 和对应参数的绑定</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name, age, sex, hobbit</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name, <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// name name</span></span><br><span class="line">    <span class="comment">// 改变形参</span></span><br><span class="line">    name = <span class="string">&#x27;new name&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name, <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// new name new name</span></span><br><span class="line">    <span class="comment">// 改变 arguments</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="string">&#x27;new age&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(age, <span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">// new age new age</span></span><br><span class="line">    <span class="comment">// 测试未传入的是否会绑定</span></span><br><span class="line">    <span class="built_in">console</span>.log(sex); <span class="comment">// undefined</span></span><br><span class="line">    sex = <span class="string">&#x27;new sex&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(sex, <span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// new sex undefined</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">3</span>] = <span class="string">&#x27;new hobbit&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(hobbit, <span class="built_in">arguments</span>[<span class="number">3</span>]); <span class="comment">// undefined new hobbit</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在非严格模式下，传入的实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享。在严格模式下，实参和 arguments 不会共享。</p><p><strong>传递参数</strong></p><p>将参数从一个函数传递到另一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 apply 将 foo 的参数传递给 bar</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>使用 ES6 的 … 运算符，可以轻松将其转成数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JavaScript/" rel="tag"># JavaScript</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E4%B8%9A%E5%8A%A1/%E5%85%83%E7%B4%A0%E7%9B%B8%E4%BA%A4%E6%A3%80%E6%B5%8B/" rel="prev" title="IntersectionObserver 检测元素是否可见或元素间是否相交"><i class="fa fa-chevron-left"></i> IntersectionObserver 检测元素是否可见或元素间是否相交</a></div><div class="post-nav-item"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/" rel="next" title="异步操作">异步操作 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){const e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">mohui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">570k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">8:38</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>