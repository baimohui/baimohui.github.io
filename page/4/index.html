<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"baimohui.github.io",root:"/",images:"/images",scheme:"Muse",version:"8.2.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12},copycode:!1,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"}}</script><meta property="og:type" content="website"><meta property="og:title" content="白抹灰"><meta property="og:url" content="https://baimohui.github.io/page/4/index.html"><meta property="og:site_name" content="白抹灰"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="mohui"><meta property="article:tag" content="前端,JavaScript,html5,css3,Vue"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://baimohui.github.io/page/4/"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>白抹灰</title><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">白抹灰</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">mohui</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">50</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/" class="post-title-link" itemprop="url">前后端的分离</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:47:58" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.2k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h2 id="（一）前后端分离"><a href="#（一）前后端分离" class="headerlink" title="（一）前后端分离"></a>（一）前后端分离</h2><p>前后端分离是指前后端根据 AJAX 接口进行数据的交互，目前常见的是后端直接将数据以<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/JSON">JSON</a>的格式返回给前端，前端根据后端服务器返回的数据操作DOM。</p><p><strong>主要优点</strong></p><ul><li>分工明确，前后端各司其职，后端专注业务逻辑和功能的实现，前端专注页面设计。</li><li>接口明确，并行开发，在后端接口没有实现好之前，前端完全可以自己通过<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://nodejs.org/en/">Node.js</a>的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://expressjs.com/zh-cn/">Express</a>和<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://koa.bootcss.com/">koa</a>等的Web框架模拟接口，提供测试数据。</li><li>提高开发效率，一定程度上减少了前后端的<del>沟通成本</del>撕逼</li></ul><p>在前后端分离中，后端一般提供<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.zhihu.com/question/28557115">RESTful</a> API，常将数据以JSON格式返回；而前端一般使用什么呢，这里便是引出了我们讨论的主题之一：SPA。</p><h2 id="（二）SPA"><a href="#（二）SPA" class="headerlink" title="（二）SPA"></a>（二）SPA</h2><p>SPA（Single Page App）是一种<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://en.wikipedia.org/wiki/Web_application">网络应用程序</a>（Web App）模型。在传统网站中，切换到不同页面需要从服务器加载一整个新的页面，而在 SPA 中只要动态重写页面需要发生变化的部分（如下图知乎页面的导航栏），从而避免了过多的数据交换，提高了响应速度。</p><p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174748.png" alt="image-20210513125706473" style="zoom:70%"><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174749.png" alt="image-20210513125723203" style="zoom:67%"></p><p>目前常见的几个SPA框架有Angular、React、Vue。</p><p><strong>SPA的优点</strong></p><p>除了上文所说的前后端分离，SPA还有如下一些优点：</p><ul><li>页面之间的切换非常快</li><li>一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染）</li><li>后端程序只需要提供API，完全不用管客户端到底是Web界面还是手机等</li></ul><p><strong>SPA的缺点</strong></p><ul><li>首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面。</li><li>不利于SEO</li></ul><p>根据这几个缺点，接下来讨论的两个主题就是SEO和SSR。</p><h2 id="（三）SEO"><a href="#（三）SEO" class="headerlink" title="（三）SEO"></a>（三）SEO</h2><p><strong>SEO</strong>（<strong>Search Engine Optimization</strong>）也称搜索引擎优化。它是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。</p><p><strong>常用技术</strong></p><p>搜索引擎优化中的技术大致可以分两类：白帽技术与黑帽技术，<br>SEO涉及细节也很多，以下是<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://en.wikipedia.org/wiki/Search_engine_optimization">维基百科</a>对于一些白帽技术的介绍：</p><blockquote><ul><li>在每页使用一个短、独特和相关的标题。</li><li>编辑网页，用与该页的主题。有关的具体术语替换隐晦的字眼。这有助于该站诉求的观众群，在搜索引擎上搜索而被正确导引至该站。</li><li>在该站点增加相当数量的原创内容。</li><li>使用合理大小、准确描述的汇标，而不过度使用关键字、惊叹号、或不相关标题术语。</li><li>注意网址字眼，有助于搜索引擎优化。</li><li>确认所有页可透过正常的链接来访问，而非只能透过Java 、JavaScript或Adobe Flash应用程序访问。这可透过使用一个专属列出该站所有内容的网页达成（网站地图）</li><li>透过自然方式开发链接：Google不花功夫在这有点混淆不清的指南上。写封电子邮件给网站员，告诉他：您刚刚贴了一篇挺好的文章，并且请求链接，这种做法很可能为搜索引擎所认可。</li><li>参与其他网站的网络集团（译按：web ring 指的是有相同主题的结盟站群）──只要其它网站是独立的、分享同样题目和可比较的品质。</li></ul></blockquote><p>除去非开发细节，我们大该可以提炼出以下的信息：</p><ul><li>标题： 即HTML的 <code>&lt;title&gt;&lt;/title&gt;</code> 标签，例如： <code>&lt;title&gt;浅谈SPA、SEO、SSR | XXX 的博客&lt;/title&gt;</code> ，在Google的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://support.google.com/webmasters/answer/79812?hl=en">相关文档</a>中已经说明了不再使用<code>&lt;title&gt;</code> 标签作为Meta，但是经常会配合 <code>description</code>出现在搜索的结果上</li></ul><blockquote><p>While technically not a meta tag, this tag is often used together with the “description”. The contents of this tag are generally shown as the title in search results (and of course in the user’s browser)</p></blockquote><ul><li>描述： 即HTML<code>&lt;meta&gt;</code>标签的<code>description</code>，例如百度百科的一个词条的 <code>description</code>：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;通常所说的META标签，是在HTML网页源代码中一个重要的html标签。META标签用来描述一个HTML网页文档的属性，例如作者、日期和时间、网页描述、关键词、页面刷新等。...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>关键字： 即HTML<code>&lt;meta&gt;</code>标签的<code>keywords</code>， 例如</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;META标签 META标签作用 META标签组成 META标签属性 META标签描述设计 META标签错误 META标签标签&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Google的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://support.google.com/webmasters/answer/79812?hl=en">相关文档</a>中也没有提到过使用<code>meta keywords</code>， Quora也讨论过Google是否还在使用<code>meta keywords</code>这个<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.quora.com/Does-Google-use-meta-keywords-in-2018">问题</a>，大部分的回答都是谷歌已经不再使用它了，但是其它的一些搜索引擎比如百度等还在使用<code>meta keywords</code>。</p><p><strong>SPA与SEO的冲突</strong></p><p>前面我们谈到的SPA不利于SEO，因为就目前而言，部分搜索引擎如Google、bing等，它们的爬虫虽然已经支持执行JS甚至是通过AJAX获取数据了，但是对于异步数据的支持也还不足(也可能是搜索引擎提供商觉得没必要)，<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://ssr.vuejs.org/zh/">Vue SSR</a>中是这样说的</p><blockquote><p>如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。</p></blockquote><p>前面也谈到过SPA应用中，通常通过AJAX获取数据，而这里就难以保证我们的页面能被搜索引擎正常收录到。并且有一些搜索引擎不支持执行JS和通过AJAX获取数据，那就更不用提SEO了。<br>对于有些网站而言，SEO显得至关重要，例如主要以内容输出为主的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.quora.com/">Quora</a>、<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://stackoverflow.com/">stackoverflow</a>、<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.zhihu.com/">知乎</a>和<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.douban.com/">豆瓣</a>等等，那如何才能正常使用SPA而又不影响SEO呢？</p><p>此时，SSR便闪亮登场了</p><h2 id="（四）SSR"><a href="#（四）SSR" class="headerlink" title="（四）SSR"></a>（四）SSR</h2><p><strong>SSR</strong>是 <strong>Server-Side Rendering</strong>（服务器端渲染）的缩写，在普通的 SPA 中，一般是将框架及网站页面代码发送到浏览器，然后在浏览器中生成和操作DOM（在同等带宽及网络延迟下，初次访问 SPA 网站比传统的在后端生成 HTML 发送到浏览器要更慢的主要原因）。但我们可以将 SPA 应用打包到服务器上，在服务器上渲染出 HTML 再发送到浏览器，这样的 HTML 页面还不具备交互能力，所以还需要与 SPA 框架配合，在浏览器上混合成可交互的应用程序。所以只要能合理地运用SSR技术，不仅能一定程度上解决首屏慢的问题，还能获得更好的SEO。</p><p><strong>SSR的优点</strong></p><ul><li>更快的响应时间，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面。</li><li>更好的SSR，我们可以将SEO的关键信息直接在后台就渲染成HTML，而保证搜索引擎的爬虫都能爬取到关键数据。</li></ul><p><strong>SSR的缺点</strong></p><ul><li>相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序自然会占用更多的CPU和内存资源</li><li>一些常用的浏览器API可能无法正常使用，比如<code>window</code>、<code>document</code>和<code>alert</code>等，如果使用的话需要对运行的环境加以判断</li><li>开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂</li><li>可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致。</li></ul><p><strong>SSR常用框架</strong></p><ul><li>React 的 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://nextjs.org/">Next</a></li><li>Vue.js 的 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://nuxtjs.org/">Nuxt</a></li></ul><p>不熟悉React及Next，不作评价，我的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://chengfy.com">博客</a>便是使用了Nuxt做服务器端渲染，在此不得不说Nuxt的用法实在是太漂亮了，既有一定的约束（无规矩不成方圆），又不失扩展性，官网的文档也非常不错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>前后端分离降低了前端和后端的耦合度，提高了开发效率；<br>SPA是前后端分离中前端的一种解决方案；<br>SEO对与很多网站很重要而普通的SPA又不利于SEO；<br>SSR的出现一定程度上解决了SPA中首屏慢的问题，又极大减少了普通SPA对于SEO的不利影响。</strong></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/web%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E6%8F%90%E5%8D%87%E6%8C%87%E5%8D%97/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/web%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E6%8F%90%E5%8D%87%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Web 用户体验设计提升指南</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：16:57:54" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>用户体验设计秉承着<strong>以用户为中心的思想</strong>，以用户需求为目标。设计过程注重以用户为中心，用户体验的概念从开发的最早期就开始进入整个流程，并贯穿始终。良好的用户体验设计，是产品每一个环节共同努力的结果。</p><p>除去一些很难一蹴而就的，本文将就<strong>页面展示</strong>、<strong>交互细节</strong>、<strong>可访问性</strong>三个方面入手，罗列一些在实际的开发过程中，积攒的一些有益的经验。通过本文，你将能收获到：</p><ul><li><p>了解到一些小细节是如何影响用户体验的</p></li><li><p>了解到如何在尽量小的开发改动下，提升页面的用户体验</p></li><li><p>了解到一些优秀的交互设计细节</p></li><li><p>了解基本的无障碍功能及页面可访问性的含义</p></li><li><p>了解基本的提升页面可访问性的方法</p><div class="post-button"><a class="btn" href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/web%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E6%8F%90%E5%8D%87%E6%8C%87%E5%8D%97/#more" rel="contents">阅读全文 &raquo;</a></div></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%90%8E%E7%AB%AF/Linux/%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%90%8E%E7%AB%AF/Linux/%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">Linux 课后练习题</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-11-21 17:18:30" itemprop="dateModified" datetime="2021-11-21T17:18:30+08:00">2021-11-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>21k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>19 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h4 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h4><p>一、判断题<br>1、Linux 内核是单内核结构，执行效率高，可维护性好。（ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么要使用模块？</span><br><span class="line">linux内核之所以提供模块机制，是因为它本身是一个单内核。而单内核的最大优点就是效率高，因为所有的内容都集成在一起，但其缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</span><br></pre></td></tr></table></figure><p>2、Linux 内核模块不属于 Linux 的子系统。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux 内核主要由5个子系统组成：进程调度（SCHED），内存管理（MM），虚拟文件系统（VFS），网络接口（NET），进程间通信（IPC）。内核模块是linux内核向外部提供的一个插口，是内核的一部分，但是并没有被编译到内核里面去，其全称为动态可加载内核模块(Loadable Kernel Module,LKM)，简称模块。</span><br><span class="line">（1）进程调度－控制着进程对CPU的访问。当需要选择一个进程运行时，由调度程序选择最值得运行的进程。Linux 使用了比较简单的基于优先级和时间片的进程调度算法选择新的进程。</span><br><span class="line">（2）内存管理－允许多个进程安全地共享主内存区域 。Linux的内存管理支持虚拟内存，即在计算机中运行的程序，其代码、数据和堆栈的总量可以超过实际内存的大小，操作系统只将当前使用的程序块保留在内存中，其余的程序块则保留在磁盘上。必要时，操作系统负责在磁盘和内存之间交换程序块。因为虚拟内存管理需要硬件支持，因此内存管理从逻辑上可以分为硬件无关的部分和硬件相关的部分。详细内容看第四章。</span><br><span class="line">（3）虚拟文件系统－隐藏各种不同硬件的具体细节，为所有设备提供统一的接口。虚拟文件系统支持多达数十种不同的文件系统，这也是Linux较有特色的一部分。虚拟文件系统可分为逻辑文件系统和设备驱动程序。逻辑文件系统指Linux所支持的文件系统，如ext2, fat等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。详细内容参看第八章和第九章。</span><br><span class="line">（4）网络－提供了对各种网络标准协议的存取和各种网络硬件的支持。网络子系统可分为网络协议和网络驱动程序两部分。网络协议部分负责实现每一种可能的网络传输协议，网络设备驱动程序负责与硬件设备进行通信，每一种可能的硬件设备都有相应的设备驱动程序。因为这部分内容相对独立和复杂，本书不做详细介绍。</span><br><span class="line">（5）进程间通信(IPC)－ 支持进程间各种通信机制，包括共享内存、消息队列及管道等。这部分内容也相对独立，本书不做详细介绍。</span><br><span class="line">处于中心位置的是进程调度，所有其它的子系统都依赖于它，因为每个子系统都需要挂起或恢复进程。一般情况下，当一个进程等待硬件操作完成时，它被挂起；当操作真正完成时，进程恢复执行。例如，当一个进程通过网络发送一条消息时，发送进程被挂起，一直到硬件成功地完成消息的发送。其它子系统(内存管理，虚拟文件系统及进程间通信)以相似的理由依赖于进程调度。</span><br></pre></td></tr></table></figure><p>3、当一个操作系统满足 POSIX 标准时，在该系统上写的应用程序都能在任何UNIX系统中运行。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POSIX 表示可移植操作系统接口（Portable Operating System Interface）。任何操作系统只有符合这一标准，才有可能运行Unix程序。</span><br></pre></td></tr></table></figure><p>4、硬件性价比比较低的时候，操作系统设计追求低成本高性能。（ √ ）<br>5、硬件性价比比较高以后，操作系统设计不再考虑硬件成本需求，着力在充分利用硬件的性能上。（ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在硬件的性价比较低的时候，操作系统设计完成了追求硬件使用率的理论探索，从批处理到分时系统</span><br><span class="line">在硬件性价比越来越高后，操作系统的设计开始追求系统的可靠和稳定，出现了多处理器系统和分布式系统。</span><br></pre></td></tr></table></figure><p>6、Linux 系统的设备管理功能通过虚拟文件系统实现。（ √ ）</p><p>二、单选题<br>1、（ d ）不属于 Linux 的子系统。<br>A 进程管理 B 内存管理 C 文件系统 D 模块<br>2、Linux 操作系统遵循（ c ）标准。<br>A GNU B GPL C POSIX D MMU<br>3、struct list_head 无法表达（ b ）种数据结构。<br>A 队列和堆栈 B 图 C 树 D 集合</p><h4 id="第二章-内存寻址"><a href="#第二章-内存寻址" class="headerlink" title="第二章 内存寻址"></a>第二章 内存寻址</h4><p>一、判断题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">intel的80286处理器于1982年问世，地址总线位数增加到了24位，从此开始引进了一个全新理念—保护模式：访问内存时不能直接从段寄存器中获得段的起始地址了，而需要经过额外转换和检查 。段寄存器中存放段号，而不是基地址。80286处理器一些致命的缺陷注定不能长久，它很快被天资卓越的兄弟——80386代替了。80386是一个32位的CPU，其寻址能力达到4GB 。Intel选择了在段寄存器的基础上构筑保护模式，并且保留段寄存器16位 。在保护模式下，它的段范围不再受限于64K，可以达到4G。</span><br><span class="line"></span><br><span class="line">为什么能达到保护这些对象的目的？</span><br><span class="line">访问内存时不能直接从段寄存器中获得段的起始地址，而需要经过额外的转换和检查。</span><br><span class="line">保护模式的实现：通过分页机制及CR0~CR3控制寄存器的设置</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、操作系统启动时，处理器处于保护模式。（ × ）</p><p>2、分页机制是在保护模式下开启的。（ √ ）</p><p>3、在保护模式下，段的大小可以达到4GB。（ √ ）</p><p>4、CR3寄存器存放的是页目录基地址。（ √ ）</p><p>5、X86的保护模式就是来保护操作系统的。（ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">保护模式保护物理内存的访问。</span><br><span class="line">Linux操作系统引入保护模式，是因为实模式下从段寄存器中可以获得段的起始地址，不能保护保护对物理内存的访问，因此需要保护模式。</span><br></pre></td></tr></table></figure><p>6、分页的原理使得每个进程可以拥有自己独立的虚拟内存空间。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux主要采用分页机制来实现虚拟存储器管理，因为Linux的分段机制使得所有的进程都使用相同的段寄存器值，这就使得内存管理变得简单，也就是说，所有的进程都使用同样的线性地址空间（0~4G）。</span><br></pre></td></tr></table></figure><p>7、Linux之所以巧妙地绕过了段机制，主要是因为将段的基地址设为0，即偏移量等于线性地址。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在x86上，设计者要求必须使用段机制，而Linux为了可移植性，巧妙的绕过段机制，将段机制和分页机制合并。主要设定如下完成：设定段的基地址为0，段的界限设为4GB，这时段内偏移地址就等于线性地址。</span><br></pre></td></tr></table></figure><p>8、在X86 中，启用分页机制是通过启用保护允许位PE达到的。（ × ）</p><p>9、链接以后形成的地址空间是虚拟地址空间。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个程序编译连接后形成的地址空间是一个虚拟地址空间，但是程序最终还是要运行在物理内存中。因此，应用程序所给出的任何虚地址最终必须被转化为物理地址，所以，虚拟地址空间必须被映射到物理内存空间中，这个映射关系需要通过硬件体系结构所规定的数据结构来建立。这就是我们所说的段描述符表和页表，Linux主要通过页表来进行映射。</span><br></pre></td></tr></table></figure><p>10、CPU访问的是虚拟地址。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU发出对虚拟地址的数据访问，虚拟地址经过MMU转换成物理地址，最终从这个物理地址读取数据。因此cache的硬件设计既可以采用虚拟地址也可以采用物理地址甚至是取两者地址部分组合作为查找cache的依据。</span><br></pre></td></tr></table></figure><p>11、80X86的控制寄存器主要用于分段机制。（ × ）</p><p>12、80X86的分段机制是必选的，分页机制是可选的。（ √ ）</p><p>13、页面高速缓存是一种硬件机制，专门用来支持地址转换的。（ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于在分页情况下，页表是放在内存中的，这使CPU在每次存取一个数据时，都要至少两次访问内存,从而大大降低了访问速度。所以，为了提高速度，在IA32中设置一个最近存取页的高速缓存硬件机制，它自动保持32项处理器最近使用的页表项，因此，可以覆盖128K字节的内存地址。当访问线性地址空间的某个地址时，先检查对应的页表项是否在高速缓存中，如果在，就不必经过两级访问了，如果不在，再进行两级访问。平均来说，页面高速缓存大约有90%的命中率，也就是说每次访问存储器时，只有10%的情况必须访问两级分页机构。这就大大加快了速度，</span><br></pre></td></tr></table></figure><p>14、Intel 的保护模式是在80386处理器中首次出现的。（ × ）</p><p>15、虚拟地址是程序访问存储器所使用的逻辑地址，线性地址是逻辑地址到物理地址变换的中间层，物理地址是每一个字节单元的一个唯一的存储器地址。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux采用分页存储管理。虚拟地址空间划分成固定大小的“页”，由MMU在运行时将虚拟地址映射（变换）成某个物理页面中的地址 </span><br><span class="line">IA32的MMU对程序中的虚拟地址先进行段式映射（虚拟地址转换为线性地址），然后才能进行页式映射（线性地址转换为物理地址）</span><br></pre></td></tr></table></figure><p>二、单选题</p><p>1、一个32位的虚拟地址分为a,b,c三个域，其中a,b用于一个二级页表系统，c为页内偏移地址，则页面数为 （ D ）</p><p>A a+b B axb C 2^a+b D 2^(a+b)</p><p>2、以下（ C ）处理器不是冯. 诺依曼体系结构。</p><p>A Intel X86 B AMD C ARM D MIPS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图灵机模型分为冯诺依曼结构和哈佛结构，其中ARM属于哈佛结构。</span><br></pre></td></tr></table></figure><p>3、“段：偏移量”的形式描述的是（ B ）。</p><p>A 物理地址 B 虚拟地址 C 线性地址 D 段地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">硬件地址：将主板上的物理内存条所提供的内存空间定义为物理内存空间，其中每个内存单元的实际地址就是物理地址</span><br><span class="line">虚拟地址：将应用程序员看到的内存空间定义为虚拟地址空间(或地址空间)，其中的地址就叫虚拟地址(或虚地址)， 一般用“段：偏移量”的形式来描述 </span><br><span class="line">线性地址：线性地址空间是指一段连续的，不分段的，范围为0到4GB的地址空间，一个线性地址就是线性地址空间的一个绝对地址。 </span><br></pre></td></tr></table></figure><p>4、在80x86中，可供一般用户访问的寄存器：（ A ）</p><p>A 段寄存器 B 调试寄存器 C 系统地址寄存器 D 测试寄存器</p><p>5、分页机制中页的大小由（ A ）决定。</p><p>A 硬件设计者 B 操作系统设计者 C 用户 D A和B</p><h4 id="第三章-进程"><a href="#第三章-进程" class="headerlink" title="第三章 进程"></a>第三章 进程</h4><p>一、判断题</p><p>1、进程上下文是指进程的执行环境。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux是多任务操作系统，也就是说可以有多个程序同时装入内存并运行，操作系统为每个程序建立一个运行环境即创建进程。从逻辑上说，每个进程拥有它自己的虚拟CPU。当然，实际上真正的CPU在各进程之间来回切换。但如果我们想研究这种系统，而去跟踪CPU如何在程序间来回切换将会是一件相当复杂的事情，于是换个角度，集中考虑在（伪）并行情况下运行的进程集就使问题变得简单、清晰得多。这种快速的切换称作多道程序执行。在一些Unix书籍中，又把“进程切换”（Process Switching）称为“环境切换”或“上下文切换”（Context Switching）。这里“进程的上下文”就是指进程的执行环境。</span><br></pre></td></tr></table></figure><p>2、进程处于浅度睡眠状态不可由其他进程通过信号和时钟中断唤醒。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内核实现了操作系统的三大功能，分别为进程管理、内存管理和文件系统。Linux会用一个数据结构来描述进程，这个数据结构包括进程的状态，进程的pid，父进程等信息，Linux会维护这一个数据结构来实现对进程的状态管理。而每个进程都由其父进程来创建，最初的父进程由Linux的内核创建。Linux进程状态有以下五种:</span><br><span class="line">可运行态：运行态和就绪态的合并，表示进程正在运行或准备运行，Linux 中使用 TASK_RUNNING 宏表示此状态。</span><br><span class="line">浅度睡眠态：进程正在睡眠(被阻塞)，等待资源到来是唤醒，也可以通过其他进程信号或时钟中断唤醒，进入运行队列。Linux 使用 TASK_INTERRUPTIBLE 宏表示此状态。</span><br><span class="line">深度睡眠态：其和浅度睡眠基本类似，但有一点就是不可其他进程信号或时钟中断唤醒。Linux 使用TASK_UNINTERRUPTIBLE 宏表示此状态。</span><br><span class="line">暂停状态：进程暂停执行接受某种处理。如正在接受调试的进程处于这种状态，Linux 使用 TASK_STOPPED 宏表示此状态。</span><br><span class="line">僵死状态：进程已经结束但未释放PCB，Linux 使用 TASK_ZOMBIE 宏表示此状态。</span><br></pre></td></tr></table></figure><p>3、<code>fork()</code> 后，写时复制技术发生时，主要完成复制父进程的页表工作。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">写时复制技术：指在创建新进程时没有把全部的父进程资源给子进程复制一份，而是将这些内容设置为只读状态，当父进程或子进程试图修改某些内容时，内核才在修改前将要修改的部分拷贝出来。当父子进程共享的资源越多时，写时复制技术越有优势。</span><br><span class="line">子进程请求父进程把所有资源给自己复制一份 ，父进程只是假装复制一下，用一个指针指过去，等真正需要时需要利用写时复制技术。父子进程，不管谁想写一个页面，这个页面都要被复制一份。父进程并不是把自己的所有东西马上都给儿子，而是直到儿子真正需要时才给它。也就是当父进程或子进程试图修改某些内容时，内核才在修改之前将被修改的部分进行拷贝－这叫做写时复制。</span><br><span class="line">fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的PCB。</span><br></pre></td></tr></table></figure><p>4、当进程处于就绪态，还需要被唤醒才能执行。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">为了对进程从产生到消亡的这个动态变化过程进行捕获和描述，就需要定义进程各种状态并制定相应的状态转换策略，以此来控制进程的运行。因为不同操作系统对进程的管理方式和对进程的状态解释可以不同，所以不同操作系统中描述进程状态的数量和命名也会有所不同，但最基本的进程状态有三种：</span><br><span class="line">(1) 运行态: 进程占有CPU，并在CPU上运行。</span><br><span class="line">(2) 就绪态: 进程已经具备运行条件, 但由于CPU忙而暂时不能运行</span><br><span class="line">(3) 阻塞态（或等待态）:  进程因等待某种事件的发生而暂时不能运行。(即使CPU空闲, 进程也不可运行)。  </span><br><span class="line">进程在生命期内处于且仅处于三种基本状态之一,如图3.2。</span><br><span class="line">这三种状态之间有四种可能的转换关系： </span><br><span class="line">① 运行态-&gt;阻塞态： 进程发现它不能运行下去时发生这种转换。这是因为进程发生I&#x2F;O请求或等待某件事情。</span><br><span class="line">② 运行态-&gt;就绪态：在系统认为运行进程占用CPU的时间已经过长,决定让其它进程占用CPU时发生这种转换。这是由调度程序引起的。调度程序是操作系统的一部分，进程甚至感觉不到它的存在。</span><br><span class="line">③ 就绪态-&gt;运行态：运行进程已经用完分给它的CPU时间，调度程序从处于就绪态的进程中选择一个投入运行。</span><br><span class="line">④ 阻塞态-&gt;就绪态：当一个进程等待的一个外部事件发生时（例如输入数据到达），则发生这种转换。如果这时没有其它进程运行，则转换③立即被触发，该进程便开始运行。</span><br><span class="line">调度程序的主要工作是决定哪个进程应当运行，以及它应当运行多长时间。</span><br></pre></td></tr></table></figure><p>5、用户进程执行时处于用户态。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在执行系统调用前，用户进程运行在用户态；在执行系统调用过程中，用户进程运行在核心态。</span><br></pre></td></tr></table></figure><p>6、调度程序的作用是从磁盘上选取一个进程占用CPU，并分配其占用CPU的时间。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调度程序的主要工作是决定哪个进程应当运行，以及它应当运行多长时间。</span><br></pre></td></tr></table></figure><p>7、一个进程一旦创建就可以为其分配CPU并运行。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程执行时的间断性决定了进程可能具有多种状态，最基本的三种状态如下</span><br><span class="line">① 就绪状态，当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，就可以立即运行，进程这时的状态称为就绪状态。在一个系统中可能多个进程处于就绪状态，通常将它们排成一个队列，称为就绪队列。</span><br></pre></td></tr></table></figure><p>8、用户进程一旦建立，就将所有程序和数据装入内存。 （ × ）</p><p>9、进程的等待队列不是共享队列，因此不需要保护。 （ × ）</p><p>10、Linux的调度器采用机制与策略分析的机制。 （ √ ）</p><p>二、单选题</p><p>1、进程的上下文属于进程控制的（ D ）类型信息。</p><p>A 状态 B 链接 C 虚拟内存 D 处理器环境</p><p>2、（ B ）进程可以充当所有进程的养父。</p><p>A 进程 0 B 进程1 C kswapd D kflushd</p><p>3、Linux创建一个进程采用的是（ B ）技术。</p><p>A 请求调页 B 写时复制 C 分页 D 分段</p><p>4、在支持多线程的系统中，进程P创建的若干个线程不能共享的是（ D ）。</p><p>A 进程P的代码段 B 进程P中打开的文件</p><p>C 进程P的全局变量 D 进程P中某线程的栈指针</p><p>5、创建（ D ）不调用do_fork().</p><p>A 进程 B 用户态线程 C 内核线程 D 协程</p><h4 id="第四章-内存管理"><a href="#第四章-内存管理" class="headerlink" title="第四章 内存管理"></a>第四章 内存管理</h4><p>一、判断题</p><p>1、一个进程的用户地址空间主要由mm_struct结构和vm_block_struct结构来描述。（ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Linux把进程的用户空间划分为一个个区间，这是因为每个虚存区可能来源不同，有的可能来自可执行映像，有的可能来自共享库，而有的则可能是动态分配的内存区，对不同的区间可能具有不同的访问权限，也可能有不同的操作。因此Linux 把进程的用户空间分割管理，并利用了虚存区处理函数（vm_ops）来抽象对不同来源虚存区的处理方法。</span><br><span class="line">一个进程的用户地址空间主要由mm_struct结构和vm_area_structs结构来描述。mm_struct结构对进程整个用户空间进行描述，vm_area_structs结构对用户空间中各个区间(简称虚存区)进行描述。</span><br></pre></td></tr></table></figure><p>2、用户可以通过lscpu命令来查看内存的层次结构。（ ✓ ）</p><p>3、每个进程拥有4GB的虚拟地址空间，0~3GB是各进程私有用户空间，对其他进程不可见。 （ ✓ ）</p><p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211117080708.png" alt="image-20211117080708726"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线性空间在32位平台上为4GB的固定大小，也就是Linux的虚拟地址空间也这么大。Linux内核将这4G字节的空间分为两部分。最高的1G字节（从虚地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”，其中存放的是内核代码和数据，即“内核映象”。而较低的3G字节（从虚地址0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间”。存放的是用户程序的代码和数据。</span><br><span class="line">因为每个进程可以通过系统调用进入内核，因此，Linux内核空间由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟地址空间(也叫虚拟内存) 。每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的。最高的1GB内核空间则为所有进程以及内核所共享。 </span><br></pre></td></tr></table></figure><p>4、每个程序编译链接后形成的二进制映像文件有一个代码段和数据段，进程要映射的文件被映射到内存映射区。 （ ✓ ）</p><p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211117075633.png" alt="image-20211117075624392"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每个进程经编译、链接后形成的二进制映像文件有一个代码段和数据段。进程运行时须有如图所示的独占堆栈空间。由图可以看出，堆栈段安排在用户空间的顶部，运行时由顶向下延伸；代码段和数据段则在低部，运行时并不向上延伸。从数据段的顶部到堆栈段地址的下沿这个区间是一个巨大的空洞，这就是进程在运行时调用malloc()可以动态分配的空间，也叫动态内存或堆。</span><br><span class="line">尽管每个进程拥有3GB的用户空间，但是其中的地址都是虚地址，因此，用户进程在这个虚拟内存中并不能真正地运行起来，必须把用户空间中的虚地址最终映射到物理存储空间才行，而这种映射的建立和管理是由内核完成的。所谓向内核申请一块空间，实际上是指请求内核分配一块虚存区间和相应的若干物理页面，并建立起映射关系。</span><br><span class="line">内核在创建进时并不是为整个用户空间都分配好相应的物理空间,而是根据需要才真正分配一些物理页面并建立映射。在后面我们会看到，系统利用了请页机制来避免对物理内存的过分使用。因为进程访问的用户空间中的页可能当前不在物理内存中，这时，操作系统通过请页机制把数据从磁盘装入到物理内存。为此，系统需要修改进程的页表，以便标志用户空间中的页已经装入到物理页面中。由于上面这些原因，Linux 采用了比较复杂的数据结构跟踪进程的用户地址空间。</span><br><span class="line">调用malloc分配的内存在堆空间中。用户空间的每个划分区域可以叫做虚存区。</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211117081917.png" alt="image-20211117081849021" style="zoom:50%"><p>5、进程运行时，CPU访问的是用户空间的物理地址。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程运行时，CPU访问的是用户空间的虚地址。</span><br><span class="line">请页机制：Linux仅把当前要使用的用户空间中的少量页面装入内存，需要时再通过请页机制将特定的页面调入内存。当要访问的虚页不在内存时，产生一个页故障并报告故障原因。</span><br></pre></td></tr></table></figure><p>6、伙伴算法的核心思想是回收时进行相邻块的合并。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Linux使用伙伴算法有效地分配和回收物理页块。该算法试图分配由一个或多个连续物理页面组成的内存块，其大小为1页，2页，或4页等。只要系统有满足需要的足够的空闲页面，就会在free_area数组中查找满足需要大小的一个页块。</span><br><span class="line">Linux的伙伴算法把所有的空闲页面分为10个块链表，每个链表中的一个块含有2的幂次个页面(叫做“页块”或简称“块”)</span><br><span class="line">大小相同、物理地址连续的两个页块被称为伙伴。</span><br><span class="line">工作原理：首先在大小满足要求的块链表中查找是否有空闲块，若有则直接分配，否则在更大的块中查找。其逆过程就是块的释放，此时会把满足伙伴关系的块合并。</span><br><span class="line">伙伴算法为什么能减少碎片？</span><br><span class="line">（1）在分配时，根据需要，分配与所需内存大小最相近稍大的块，这样碎片最少；</span><br><span class="line">（2）在回收时，检查相邻的伙伴块，实时对释放的伙伴块进行合并；</span><br><span class="line">综合以上原因，伙伴算法的关键是对不同大小的连续空闲页面进行了分区（块）的管理。</span><br></pre></td></tr></table></figure><p>7、把虚地址转换成物理地址的过程是由硬件机制完成的，操作系统只是协助者。 （ ✓ ）</p><p>8、伙伴算法负责大块物理内存的分配和释放，以页框为单位。 （ × ）</p><p>9、缺页异常发生时会调用伙伴算法分配物理页面。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">页故障的产生有三种原因：</span><br><span class="line">（1）程序出现错误，例如，要访问的虚地址在PAGE_OFFSET（3GB）之外，则该地址无效， Linux 将向进程发送一个信号并终止进程的运行；</span><br><span class="line">（2）虚地址有效，但其所对应的页当前不在物理内存中，即缺页异常，这时，操作系统必须从磁盘或交换文件（此页被换出）中将其装入物理内存。这是本节要讨论的主要内容。</span><br><span class="line">（3）要访问的虚地址被写保护，即保护错误，这时，操作系统必须判断：如果是某个用户进程正在写当前进程的地址空间，则发送一个信号并终止进程的运行。但是，如果错误发生在一旧的共享页上时，则处理方法有所不同，也就是要对这一共享页进行复制，这就是曾经描述过的“写时复制”技术。</span><br></pre></td></tr></table></figure><p>10、Linux内核对用户空间的管理是以虚存区为单位的。 （ ✓ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Linux把进程的用户空间划分为一个个区间，便于管理。</span><br><span class="line">一个进程的用户地址空间主要由mm_struct结构和vm_area_structs结构来描述。</span><br><span class="line">mm_struct结构对进程整个用户空间进行描述</span><br><span class="line">vm_area_structs结构对用户空间中各个区间(简称虚存区)进行描述 </span><br></pre></td></tr></table></figure><p>11、在Linux内核中为一个数据结构分配空间调用kmalloc( )函数。 （ ✓ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在内核空间中调用kmalloc()分配连续物理空间，而调用vmalloc()分配非物理连续空间。</span><br><span class="line">我们把kmalloc()所分配内核空间中的地址称为内核逻辑地址 </span><br><span class="line">把vmalloc()分配的内核空间中的地址称为内核虚拟地址</span><br><span class="line">当一个数据结构的使用不频繁、或其大小不足一个页面时，没有必要给其分配专用缓冲区 ，可调用函数kmalloc() 分配通用缓冲区</span><br></pre></td></tr></table></figure><p>二、单选题</p><p>1、Linux内核调用（ C ）为进程创建虚存区。</p><p>A VMA( ) B do_vma( ) C mmap( ) D do_mmap( )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mmap()：在进程的用户空间内创建一个新的虚存区。</span><br><span class="line">do_mmap()：虚存映射都是通过mmap()系统调用对应的内核函数do_mmap() 来实现的。</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211117082813.png" alt="image-20211117082813336" style="zoom:67%"><p>2、内核线程拥有的地址空间为（ B ）</p><p>A 0<del>(3G-1)B B 3GB</del>(4G-1)B C 0~(4G-1)B D 内核栈</p><p>3、 （ B ）系统调用为用户空间创建了一个新的虚存区。</p><p>A fork( ) B mmap( ) C munmap( ) D exe( )</p><p>4、用户进程向系统申请物理内存空间，Linux内核通过调用（ C ）函数实现物理内存的分配。</p><p>A vmalloc( ) B kmalloc( ) C get_free_page( ) D malloc( )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内核在执行过程中使用的页面要经过动态分配，但永驻内存，此类页面根据其内容和性质可以分为两类：</span><br><span class="line">内核调用kmalloc()或vmalloc()为内核中临时使用的数据结构而分配的页用完立即释放。但是，由于一个页面中存放有多个同种类型的数据结构，所以要到整个页面都空闲时才把该页面释放。</span><br><span class="line">内核中通过调用__get_free_pages为某些临时使用和管理目的而分配的页面，例如，每个进程的内核栈所占的两个页面、从内核空间复制参数时所使用的页面等等，这些页面也是一旦使用完毕便无保存价值，所以立即释放。</span><br></pre></td></tr></table></figure><p>5、内核为频繁使用的数据结构分配物理内存采用的是（ C ）</p><p>A 伙伴算法 B slab 机制 C vmalloc机制 D Per-CPU 页框高速缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmalloc（）函数给内核分配一个非连续的内存区</span><br></pre></td></tr></table></figure><h4 id="第五章-中断和异常"><a href="#第五章-中断和异常" class="headerlink" title="第五章 中断和异常"></a>第五章 中断和异常</h4><p>一、判断题</p><p>1、中断分为上下两部分处理的原因是为了避免关中断太长导致中断的丢失，因此内核希望尽可能早些完成中断请求，尽量将更多可以推后的任务推后处理。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">系统不能长时间关中断运行，因此内核应尽可能快的处理完中断请求，尽其所能把更多的处理向后推迟</span><br><span class="line">内核把中断处理分为两部分：上半部（top half）和下半部（bottom half），上半部内核立即执行，而下半部留着稍后处理</span><br><span class="line">中断服务例程在中断请求关闭的条件下执行,即执行上半部，避免嵌套使中断控制复杂化 </span><br><span class="line">下半部运行时是允许中断请求的，而上半部运行时是关中断的，这是二者之间的主要区别。 </span><br></pre></td></tr></table></figure><p>2、IDT是指中断描述符表，是存放中断处理程序入口地址的一种表。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中断描述符表（IDT）：即中断向量表，每个中断占据一个表项。在实地址模式中，CPU把内存中从0开始的1K字节作为一个中断向量表。表中的每个表项占四个字节，由两个字节的段地址和两个字节的偏移量组成，这样构成的地址便是相应中断处理程序的入口地址。</span><br><span class="line">中断向量－每个中断源都被分配一个8位无符号整数作为类型码，即中断向量，Intel x86系列微机共支持256种向量中断.</span><br><span class="line">所有256种中断可分为两大类：中断和异常。</span><br></pre></td></tr></table></figure><p>3、jiffies表示系统自启动以来的时间。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OS时钟是由可编程定时&#x2F;计数器产生的输出脉冲触发中断而产生的</span><br><span class="line">操作系统的“时间基准” 由设计者决定，Linux的时间基准是1970年1月1日凌晨0点</span><br><span class="line">OS时钟记录的时间就是系统时间。系统时间以“时钟节拍”为单位</span><br><span class="line">Linux中用全局变量jiffies表示系统自启动以来的时钟节拍数目 </span><br><span class="line">实际时间存放在内核的xtime中，系统启动时内核通过读取RTC来初始化实际时间 </span><br></pre></td></tr></table></figure><p>4、中断的引入是为了支持设备和设备之间的并行操作。 （ × ）</p><p>5、中断模型是一种C/S结构。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中断是CPU对系统发生某个时间做出的一种反应（what）， 中断的引入是为了支持CPU和设备之间的并行操作（why），CPU在收到中断信号以后，并不立即执行响应，而是在执行每条指令周期的最后一个时钟周期，一旦检测到中断信号有效，并且中断允许位置1的时候，CPU才在当前指令执行完以后转入中断响应周期（when）。中断是一种C&#x2F;S结构，当外设产生中断后并不是立刻传给CPU而是用中断控制器进行收集，然后分发给某个CPU进行处理并且应答(how)。</span><br></pre></td></tr></table></figure><p>6、对中断的上半部分和下半部分执行的函数都为do_irq。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有的中断服务程序最后都要跳转到do_IRQ()函数并由它来依次执行中断服务队列中的ISR。</span><br></pre></td></tr></table></figure><p>7、中断子系统由三个部分组成，分别为硬件无关的代码，CPU体系结构相关的中断处理和中断控制器的驱动代码。 （ √ ）</p><p>8、CPU正在执行内核态的代码时被中断则堆栈不发生切换。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当中断发生在用户态（特权级为3），而中断处理程序运行在内核态（特权级为0），特权级发生了变化，所以会引起堆栈的更换。也就是说，从用户堆栈切换到内核堆栈。而当中断发生在内核态时，即CPU在内核中运行时，则不会更换堆栈。</span><br></pre></td></tr></table></figure><p>9、CPU在每个时钟周期都检查是否有中断。（ × ）</p><p>10、中断描述符表是段描述符表的一种。（ × ）</p><p>11、小任务不能睡眠，不能在小任务中使用信号量。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内核下半部实现机制是软中断（SOFTIRQ）机制,常用的是小任务机制和工作队列机制。小任务是指对要推迟执行的函数进行组织的一种方式。其数据结构为tasklet_struct，每个结构代表一个独立的小任务。小任务既可以静态地创建，也可以动态地创建。</span><br><span class="line">小任务不能睡眠，不能在小任务中使用信号量或者其它产生阻塞的函数。但它运行时可以响应中断。</span><br></pre></td></tr></table></figure><p>12、“时钟中断”是整个操作系统的脉搏。（ √ ）</p><p>13、中断请求队列的建立是为了解决中断线的共享问题。（ √ ）</p><p>二、单选题</p><p>1、注册中断处理程序是为了（ D ）。</p><p>​ A 将中断处理程序挂入中断请求队列 B 初始化IDT</p><p>​ C 从中断返回 D 执行中断处理程序</p><p>2、操作系统启动以后，（ B ）时钟不再被使用。</p><p>​ A CMOS时钟 B RTC C OS时钟 D jiffies</p><p>3、操作系统启动后，使用的时钟是（ C ）。</p><p>​ A CMOS时钟 B RTC C OS时钟 D jiffies</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大部分PC机中有两个时钟源，分别是实时时钟（RTC）和操作系统（OS）时钟。实时时钟也叫硬件时钟，它靠电池供电，即使系统断电，也可以维持日期和时间。RTC和OS时钟之间的关系通常也被称作操作系统的时钟运作机制。一般来说，RTC是OS时钟的时间基准，操作系统通过读取RTC来初始化OS时钟，此后二者保持同步运行，共同维持着系统时间。所谓同步，是指操作系统在运行过程中，每隔一个固定时间会刷新或校正RTC中的信息。</span><br><span class="line">实时时钟：RTC时钟，用于提供年、月、日、时、分、秒和星期等的实时时间信息，由后备电池供电，当你晚上关闭系统和早上开启系统时，RTC仍然会保持正确的时间和日期。</span><br><span class="line">系统时钟：是一个存储于系统内存中的逻辑时钟。用于系统的计算，比如超时产生的中断异常，超时计算就是由系统时钟计算的。这种时钟在系统掉电或重新启动时每次会被清除。</span><br></pre></td></tr></table></figure><p>4、在中断上下文中，用（ B ）加锁。</p><p>​ A 信号量 B 自旋锁 C 原子操作 D 锁操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自旋锁在内核中主要用来防止多处理器中并发访问临界区，防止内核抢占造成的竞争。 另外自旋锁不允许任务睡眠 ( 持有自旋锁的任务睡眠会造成自死锁 —— 因为睡眠有可能造成持有锁的内核任务被重新调度，而再次申请自己已持有的锁 ) ，它能够在中断上下文中使用 。</span><br><span class="line">Lnux 中的信号量是一种睡眠锁。如果有一个任务试图获得一个已被持有的信号量时，信号量会将其推入等待队列，然后让其睡眠。这时处理器获得自由去执行其它代码。当持有信号量的进程将信号量释放后，在等待队列中的一个任务将被唤醒，从而便可以获得这个信号量。</span><br><span class="line">如果代码需要睡眠，这往往是发生在和用户空间同步时，使用信号量是唯一的选择。由于不受睡眠的限制，使用信号量通常来说更加简单一些。如果需要在自旋锁和信号量中作选择，应该取决于锁被持有的时间长短。理想情况是所有的锁都应该尽可能短的被持有，但是如果锁的持有时间较长的话，使用信号量是更好的选择。另外，信号量不同于自旋锁，它不会关闭内核抢占 ，所以持有信号量的代码可以被抢占。这意味者信号量不会对影响调度反应时间带来负面影响。</span><br></pre></td></tr></table></figure><p>5、中断描述符表初始化时，（ C ）的DPL域被置为3。</p><p>​ A 中断门 B 陷阱门 C 系统门 D 以上三种门</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在实地址模式中，CPU把内存中从0开始的1K字节作为一个中断向量表。表中的每个表项占四个字节，由两个字节的段地址和两个字节的偏移量组成，这样构成的地址便是相应中断处理程序的入口地址。但是，在保护模式下，由四字节的表项构成的中断向量表显然满足不了要求。这是因为，除了两个字节的段描述符，偏移量必用四字节来表示；要有反映模式切换的信息。因此，在保护模式下，中断向量表中的表项由8个字节组成，如图5.2所示，中断向量表也改叫做中断描述符表IDT（Interrupt Descriptor Table）。其中的每个表项叫做一个门描述符（gate descriptor），“门”的含义是当中断发生时必须先通过这些门，然后才能进入相应的处理程序。 </span><br><span class="line">其中类型占3位，表示门描述符的类型，主要门描述符为：</span><br><span class="line">(1)中断门（Interrupt gate）</span><br><span class="line">其类型码为110,中断门包含了一个中断或异常处理程序所在段的选择符和段内偏移量。当控制权通过中断门进入中断处理程序时，处理器清IF标志，即关中断，以避免嵌套中断的发生。中断门中的请求特权级（DPL）为0，因此，用户态的进程不能访问Intel的中断门。所有的中断处理程序都由中断门激活，并全部限制在内核态。</span><br><span class="line">(2)陷阱门（Trap gate）</span><br><span class="line">其类型码为111,与中断门类似，其唯一的区别是，控制权通过陷阱门进入处理程序时维持IF标志位不变，也就是说，不关中断。</span><br><span class="line">(3)系统门（System gate）</span><br><span class="line">这是Linux内核特别设置的，用来让用户态的进程访问Intel的陷阱门，因此，门描述符的DPL为3。系统调用就是通过系统门进入内核的。</span><br><span class="line">最后，在保护模式下，中断描述符表在内存的位置不再限于从地址0开始的地方，而是可以放在内存的任何地方。为此，CPU中增设了一个中断描述符表寄存器IDTR，用来存放中断描述符表在内存的起始地址。中断描述符表寄存器IDTR是一个48位的寄存器，其低16位保存中断描述符表的大小，高32位保存中断描述符表的基址</span><br></pre></td></tr></table></figure><p>6、内核初始化时，中断描述符表的地址存放在（ B ）寄存器。</p><p>​ A GDTR B IDTR C LDTR D CR0</p><h4 id="第六章-系统调用"><a href="#第六章-系统调用" class="headerlink" title="第六章 系统调用"></a>第六章 系统调用</h4><p>一、判断题<br>1、从程序的角度看，实际上不直接与系统调用打交道，而是跟API打交道，API是对系统调用的封装。（ √ ）<br>2、库函数以及应用程序怎样使用系统调用，内核并不关心，内核只跟系统调用打交道，而且是实现系统调用的大场景。 （ √ ）<br>3、系统调用抽象出了用于完成某种特殊目的函数，至于这些函数怎么用，内核并不关心。这是机制与策略分离的具体体现。 （ √ ）<br>4、用户空间的程序不能直接执行内核代码，它们不能直接调用内核空间中的函数，因为内核函数驻留在受保护的地址空间上。如果进程可以直接在内核的地址空间上读写的话，系统的安全性和稳定性将不复存在。 （ √ ）<br>5、Linux系统调用接口是指内核中所有已实现和可用系统调用的集合。 （ √ ）<br>6、系统调用的实现与CPU体系结构无关。 （ × ）<br>7、尽管内核版本不同，但其内核API是相同的。 （ √ ）<br>8、对系统调用进行优化，是因为系统调用的实现从用户态切换到内核态，执行完系统调用程序后又从内核态切换回用户态，代价很大。 （ √ ）<br>9、尽管系统调用号唯一的标识每个系统调用，但用户调用系统调用时并不需要知道系统调用号。（ × ）<br>10、ls命令可以跟踪一个应用程序所调用的系统调用。（ × ）</p><p>二、单选题<br>1、（ B ）不属于系统调用处理程序所做的事情。<br>A 在内核栈保存大多数寄存器的内容 B 传递系统调用号<br>C 调用系统调用服务例程来处理系统调用<br>D 通过iret 或者sysexit汇编指令从系统调用返回<br>2、系统调用是通过（ A ）进入其处理程序的。<br>A 中断门 B 陷阱门 C 系统门 D IDT<br>3、中断、异常和系统调用的相同点是（ D ）。<br>A 源头 B 响应方式 C 处理机制 D 都用IDT表描述<br>4、系统调用号是（ A ）传入给eax寄存器的。<br>A 在lib 库中 B 通过int 0x80陷入内核后<br>C 在IDT表中 D 在sys_call_table中<br>5、（ A ）属于内核态。<br>A 系统调用表 B 应用程序 C glibc库 D int 0x80</p><h4 id="第七章-内核中的同步"><a href="#第七章-内核中的同步" class="headerlink" title="第七章 内核中的同步"></a>第七章 内核中的同步</h4><p>一、判断题</p><p>1、竞争条件会导致各种难以调试的错误是因为可执行上下文在CPU上被调度的顺序受诸多因素的影响。（ √ ）</p><p>2、临界资源是访问和操作共享数据的代码段。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">临界资源是一种系统资源，需要不同进程互斥访问，而临界区则是每个进程中访问临界资源的一段代码，是属于对应进程的，临界区前后需要设置进入区和退出区以进行检查和恢复。临界区和临界资源是不同的，临界资源是必须互斥访问的资源，这种资源同时只能被一个进程所使用，但需要这种资源的进程不止一个，因此需要对使用临界资源的进程进行管理，这也就产生了临界区的概念。</span><br></pre></td></tr></table></figure><p>3、为了避免对临界区进行并发访问，编程者必须保证临界区代码被原子地执行。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">临界区（critical regions）就是访问和操作共享数据的代码段，这段代码必须被原子地执行。</span><br></pre></td></tr></table></figure><p>4、中断屏蔽的缺点是有可能造成数据丢失甚至系统崩溃。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">中断屏蔽：在进入临界区之前屏蔽系统的中断，从而保证正在执行的内核任务不被中断处理程序所抢占，防止某些静态条件的发生。在退出临界区后，重新打开中断。 </span><br><span class="line">中断屏蔽的缺点：</span><br><span class="line">（1）local_irq_disable()和local_irq_enable()</span><br><span class="line">这两个函数都只能禁止和开启本地CPU内的中断，并不能解决多处理器引发的竞态(并行)</span><br><span class="line">（2）在屏蔽中断期间所有的中断都无法得到处理</span><br><span class="line">因此长时间屏蔽中断是很危险的，有可能造成数据丢失甚至系统崩溃。</span><br></pre></td></tr></table></figure><p>5、自旋锁是专为防止多处理器并发而引入的一种锁，它在内核中大量应用于中断处理等部分，自旋锁可以被多个内核任务持有。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自旋锁是专为防止多处理器并发而引入的一种锁，它在内核中大量应用于中断处理等部分，而对于单处理器来说，可简单采用关闭中断的方式防止中断处理程序的并发执行。自旋锁最多只能被一个内核任务持有，若一个内核任务试图请求一个已被持有的自旋锁，那么这个任务就会一直进行忙循环，也就是旋转，等待锁重新可用。</span><br><span class="line">自旋锁不允许任务睡眠，持有自旋锁的任务睡眠会造成自死锁，因此自旋锁能够在中断上下文中使用。</span><br></pre></td></tr></table></figure><p>6、在多核系统中遇到原子操作，在系统层面上原子操作还是原子操作的，在核级就不是原子的。 （ × ）</p><p>7、在单CPU上，假设一个系统调用和一个中断服务程序并发执行，则对共享变量V 的加 1操作不会出现错误。 （ × ）</p><p>8、使用嵌套锁时，获取锁的顺序无关紧要。 （ × ）</p><p>9、对于临界区，进程之间可同时进行修改操作。（ × ）</p><p>10、如果数据只会被特定的进程访问，也无需加锁。（ √ ）</p><p>11、持有锁时需要睡眠和调度，优先考虑自旋锁。（ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux中的信号量是一种睡眠锁。若有一个任务试图获得一个已被持有的信号量时，信号量会将其推入等待队列，然后让其睡眠。这时处理器获得自由而去执行其它代码。当持有信号量的进程将信号量释放后，在等待队列中的一个任务将被唤醒，从而便可以获得这个信号量。信号量具有睡眠特性，适用于锁会被长时间持有的情况，只能在进程上下文中使用。</span><br></pre></td></tr></table></figure><p>二、单选题</p><p>1、并发执行的原因不包括（ C ）。</p><p>​ A 中断 B 内核抢占 C 自旋锁 D 睡眠</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">中断——中断几乎可以在任何时刻异步发生，也可能随时打断正在执行的代码。</span><br><span class="line">内核抢占——若内核具有抢占性，内核中的任务就可能会被另一任务抢占。</span><br><span class="line">睡眠及与用户空间的同步——在内核执行的进程可能会睡眠，这将唤醒调度程序，导致调度一个新的用户进程执行。</span><br><span class="line">对称多处理——两个或多个处理器可以同时执行代码。</span><br></pre></td></tr></table></figure><p>2、（ D ）不是内核的同步措施。</p><p>​ A 中断屏蔽 B 原子操作 C 自旋锁 D 临界区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了避免并发，防止竞争。内核提供了一组同步方法来提供对共享数据的保护：中断屏蔽、原子操作、自旋锁、信号量。 </span><br></pre></td></tr></table></figure><p>3、有两个并发执行的内核任务t1和t2，共享初值为1的变量x，t1 对x 加1 ， t2 对x减 1 ，两个操作完成后，x的值为（ C ）。</p><p>​ A 可能为-1或3 B 只能是1 C 可能是0,1,或2 D 可能为-1,0,1或2</p><p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211117165545.png" alt="image-20211117165542608"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">该操作可以转化成下面三条机器指令序列：</span><br><span class="line">(1)得到当前变量i的值并拷贝到一个寄存器中</span><br><span class="line">(2)将寄存器中的值加1</span><br><span class="line">(3)把寄存器中i的新值写回到内存变量i中</span><br><span class="line">将P1中3条语句依次编号为1、2、3；P2中3条语句依次编号为4、5、6。则依次执行1、2、3、4、5、6得结果1，依次执行1、2、4、5、6、3得结果2，执行4、5、1、2、3、6得结果0。结果-1不可能得出。</span><br></pre></td></tr></table></figure><p>4、对共享变量V 的加减赋值等操作，应该通过（ A ）完成。</p><p>​ A 原子操作 B 自旋锁 C 信号量 D RCU锁</p><p>5、以相同的顺序获取嵌套锁，可阻止（ B ）的死锁。</p><p>​ A 拥抱类型 B 同步类型 C 异步类型 D 随机类型</p><p>6、内核避免死锁的算法是（ B ）</p><p>​ A 轮询算法 B 银行家算法 C 预测算法 D 电梯调度算法</p><h4 id="第八章-文件系统"><a href="#第八章-文件系统" class="headerlink" title="第八章 文件系统"></a>第八章 文件系统</h4><p>一、判断题</p><p>1、文件结构是文件存放在磁盘存储设备上的组织形式，主要体现在对文件和目录的组织上。（ √ ）</p><p>2、Linux的目录结构为树型结构，每个分区是一个独立的文件系统，每个分区在这棵树上是一个叶子结点。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件结构是文件存放在磁盘等存贮设备上的组织方法。主要体现在对文件和目录的组织上。 </span><br><span class="line">Linux使用标准的目录结构－树型结构，无论操作系统管理几个磁盘分区，这样的目录树只有一个</span><br><span class="line">制定这样一个固定的目录规划有助于对系统文件和不同的用户文件进行统一管理</span><br></pre></td></tr></table></figure><p>3、Linux文件系统使用索引节点不仅记录文件的结构数据，还存放文件的具体数据。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件系统：文件存在的物理空间，Linux系统中每个分区都是一个文件系统，都有自己的目录层次结构 </span><br><span class="line">Linux文件系统使用索引节点来记录文件信息，系统给每个索引节点分配了一个号码，称为索引节点号。文件系统正是靠这个索引节点号来识别一个文件。</span><br></pre></td></tr></table></figure><p>4、Linux之所以能支持多种文件系统，并对其进行统一和高效的组织以及管理是因为虚拟文件系统，虚拟文件系统抽象出每个实际文件系统的共有属性，描述虚拟文件系统的数据结构是super_block。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为了支持其他各种不同的文件系统，Linux提供了一种统一的框架，就是所谓的虚拟文件系统转换（Virtual Filesystem Switch），简称虚拟文件系统(VFS)。</span><br><span class="line">级块（superblock）对象: 存放系统中已安装文件系统的有关信息。超级块用来描述整个文件系统的信息。每个具体的文件系统都有各自的超级块 VFS超级块是各种具体文件系统在安装时建立的，并在卸载时被自动删除，其数据结构是 super_block </span><br><span class="line">索引节点（inode）对象: 存放关于具体文件的一般信息 </span><br><span class="line">目录项（dentry）对象: 存放目录项与对应文件进行链接的信息 </span><br><span class="line">文件(file)对象: 存放打开文件与进程之间进行交互的有关信息</span><br></pre></td></tr></table></figure><p>5、虚拟文件系统所提供的抽象界面主要由一组标准的抽象操作构成，仅仅给出了函数的定义，并没有具体的实现，真正的实现是由具体的文件系统或者驱动程序完成的。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虚拟文件系统所提供的抽象界面主要由一组标准的、抽象的操作构成，例如read()、write()、lseek等，这些函数以系统调用的形式供用户程序调用。这样，用户程序调用这些系统调用时，根本无需关心所操作的文件属于哪个文件系统，这个文件系统是怎样设计和实现的。 </span><br><span class="line">Linux的目录建立了一棵根目录为“&#x2F; ”的树。根目录包含在根文件系统中，在Linux 中，这个根文件系统通常就是 Ext2类型。其他所有的文件系统都可以被“安装”在根文件系统的子目录中。例如，用户可以通过“mount”命令，将DOS格式的磁盘分区（即FAT文件系统）安装到Linux系统中，然后，用户就可以像访问Ext2文件一样访问DOS的文件。</span><br></pre></td></tr></table></figure><p>6、inode和file数据结构的主要区别是：前者在文件建立时产生，存放于磁盘，后者在文件打开时才建立，存于内存。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inode 或i节点是指对文件的索引。如一个系统，所有文件是放在磁盘或flash上，就要编个目录来说明每个文件在什么地方，有什么属性，及大小等。就像书本的目录一样，便于查找和管理。这目录是操作系统需要的，用来找文件或叫管理文件。</span><br><span class="line">在linux中，内核通过inode来找到每个文件，但一个文件可以被许多用户同时打开或一个用户同时打开多次。这就有一个问题，如何管理文件的当前位移量，因为可能每个用户打开文件后进行的操作都不一样，这样文件位移量也不同，当然还有其他的一些问题。所以linux又搞了一个文件描述符（file descriptor）这个东西，来分别为每一个用户服务。每个用户每次打开一个文件，就产生一个文件描述符，多次打开就产生多个文件描述符，一一对应，不管是同一个用户，还是多个用户。该文件描述符就记录了当前打开的文件的偏移量等数据。所以一个i节点可以有0个或多个文件描述符。多个文件描述符可以对应一个i节点。</span><br></pre></td></tr></table></figure><p>7、虚拟文件系统各种对象的信息是存放在磁盘上的。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件(file)对象: 存放打开文件与进程之间进行交互的有关信息。这类信息仅当进程访问文件期间存在于内存中。 </span><br></pre></td></tr></table></figure><p>8、一个进程要读取一个文件，同一个文件的内容存在了两份拷贝，一份是页缓存，一份是用户进程的堆空间对应的物理内存空间。这种方式有可能导致这两份数据的不一致。 （ √ ）</p><p>9、一个inode 对象对应多个page描述符，同一个文件拥有的所有page描述符都可以在该文件对应的基树中找到。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">总结：address_space，inode，基树以及页描述符之间的关系</span><br><span class="line">1、每个adrres_space对象对应一颗搜索树。他们之间的联系是通过address_space对象中的page_tree字段指向该address_space对象对应的基树。</span><br><span class="line">2、一个inode节点对应一个address_space对象，其中inode节点对象的i_mapping和i_data字段指向相应的 address_space对象，而address_space对象的host字段指向对应的inode节点对象。</span><br><span class="line">3、一般情况下一个inode节点对象对应的文件或者是块设备都会包含多个页面的内容，所以一个inode对象对应多个page描述符。同一个文件拥有的所有page描述符都可以在该文件对应的基树中找到。</span><br><span class="line">因为一个文件可以被多个进程打开，所以多个文件表对象可以指向同一个文件节点，但多个文件表对象其对应的索引节点和目录项对象肯定是惟一的。一个inode（i节点）对应一个page cache对象，一个page cache对象包含多个物理page。</span><br></pre></td></tr></table></figure><p>10、脏页集中到page cache中写回磁盘，虽然提高了性能，但当突然断电时，可能会导致内存与磁盘数据不一致性的问题。 （ √ ）</p><p>二、单选题</p><p>1、当一个进程打开一个文件时， （ B ）数据结构才建立。</p><p>​ A fs_struct B file C dentry D inode</p><p>2、文件打开时形成的文件描述符fd存放在（ C ）数据结构中。</p><p>​ A fs_struct B file C files_struct D inode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件描述符是用来描述打开的文件的。每个进程用一个files_struct结构来记录文件描述符的使用情况，这个files_struct结构称为用户打开文件表，它是进程的私有数据。</span><br></pre></td></tr></table></figure><p>3、在文件的查找look_up操作中， （ A ）数据结构起关键作用。</p><p>​ A dentry B file C files_struct D inode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每个文件除了有一个索引节点inode数据结构外，还有一个目录项dentry数据结构。 </span><br><span class="line">dentry结构代表的是逻辑意义上的文件，描述的是文件逻辑上的属性，目录项对象在磁盘上并没有对应的映像 </span><br><span class="line">inode结构代表的是物理意义上的文件，记录的是物理上的属性，对于一个具体的文件系统，其inode结构在磁盘上就有对应的映像</span><br><span class="line">一个索引节点对象可能对应多个目录项对象</span><br><span class="line">一个有效的dentry结构必定有一个inode结构，这是因为一个目录项要么代表着一个文件，要么代表着一个目录，而目录实际上也是文件。所以，只要dentry结构是有效的，则其指针d_inode必定指向一个inode结构。可是，反过来则不然，一个inode却可能对应着不止一个dentry结构；也就是说，一个文件可以有不止一个文件名或路径名。这是因为一个已经建立的文件可以被链接（link）到其他文件名。所以在inode结构中有一个队列i_dentry,凡是代表着同一个文件的所有目录项都通过其dentry结构中的d_alias域挂入相应inode结构中的i_dentry队列。</span><br></pre></td></tr></table></figure><p>4、假设系统中安装了4个ext4文件系统，则系统中只有一个（ A ）结构。</p><p>​ A file_system_type B super_block C fs_struct D VFS mount</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">必须建立一个文件系统类型(file_system_type)来描述文件系统，它含有文件系统的名称、类型标志以及get_sb()等操作。</span><br></pre></td></tr></table></figure><p>5、文件的树型结构是由（ C ）结构来描述的。</p><p>​ A fs_struct B file C dentry D inode</p><p>6、文件在磁盘上的存放位置是由（ D ）结构来描述的。</p><p>​ A fs_struct B file C dentry D inode</p><p>7、若Linux系统管理了3个磁盘分区，则该系统目录结构有（ A ）目录树。</p><p>​ A 1个 B 2个 C 3个 D 4个</p><h4 id="第九章-设备驱动"><a href="#第九章-设备驱动" class="headerlink" title="第九章 设备驱动"></a>第九章 设备驱动</h4><p>一、判断题</p><p>1、文件操作是对设备操作的组织和抽象，而设备操作则是对文件操作的最终实现。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机中三个最基本的物质基础是CPU、内存和输入输出（I&#x2F;O）设备，文件操作是对设备操作的组织和抽象，而设备操作则是对文件操作的最终实现。 </span><br></pre></td></tr></table></figure><p>2、因为设备驱动程序完全隐藏了设备的工作细节，因此驱动程序的开发人员不需要了解硬件相关的细节。 （ × ）</p><p>3、每个设备都对应一个文件名，在内核也就对应一个索引节点。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux操作系统把设备纳入文件系统的范畴来管理。</span><br><span class="line">每个设备都对应一个文件名，在内核中也就对应一个索引节点。</span><br><span class="line">对文件操作的系统调用大都适用于设备文件。</span><br></pre></td></tr></table></figure><p>4、内核处理系统调用，根据设备文件类型和主设备号调用相应的设备驱动程序。 （ √ ）</p><p>5、设备驱动直接与硬件通信。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设备驱动层直接与物理设备打交道，在实际的实现中则因系统的结构和具体设备的物理特性不同而有不同的驱动方式。</span><br></pre></td></tr></table></figure><p>6、内存文件系统比如proc并不需要驱动程序。 （ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当用户进程发出输入输出时，系统把请求处理的权限放在文件系统，文件系统通过驱动程序提供的接口将任务下放到驱动程序，驱动程序根据需要对设备控制器进行操作，设备控制器再去控制设备本身。</span><br></pre></td></tr></table></figure><p>7、网络设备与块设备和字符设备一样都在/dev目录下对应一个设备文件。（ × ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每一个字符设备或者块设备都在&#x2F;dev目录下对应一个设备文件。读者可以通过查看&#x2F;dev目录下的文件的属性，来区分设备是字符设备还是块设备。使用cd命令进入&#x2F;dev目录，并执行ls -l命令就可以看到设备的属性。</span><br><span class="line">网络设备是特殊设备的驱动，它负责接收和发送帧数据，可能是物理帧，也可能是ip数据包，这些特性都有网络驱动决定。它并不存在于&#x2F;dev下面，所以与一般的设备不同。网络设备是一个net_device结构，并通过register_netdev注册到系统里，最后通过ifconfig -a的命令就能看到。</span><br></pre></td></tr></table></figure><p>8、设备控制器是CPU 与I/O设备之间的接口。 （ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它是CPU与I&#x2F;O设备之间的接口，它接收从CPU发来的命令，并去控制I&#x2F;O设备工作，以使处理机从繁杂的设备控制事务中解脱出来。 设备控制器是一个可编址的设备，当它仅控制一个设备时，它只有一个唯一的设备地址；若控制可连接多个设备时，则应含有多个设备地址，并使每一个设备地址对应一个设备。</span><br></pre></td></tr></table></figure><p>9、访问I/O接口的形式可分为I/O内存和I/O端口，访问I/O<strong>内存</strong>用专用的I/O指令。（ × ）</p><p>10、可以把一个系统划分为应用、文件系统和设备驱动三个层次。（ √ ）</p><p>11、从应用程序的角度看，设备文件逻辑上的空间是一个线性空间（起始地址为0，每读取一个字节加1）。（ √ ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从应用程序的角度看，设备文件逻辑上的空间是一个线性空间（起始地址为0，每读取一个字节加1）。从这个逻辑空间到具体设备物理空间（如磁盘的磁道、扇区）的映射则是由内核提供，并被划分为文件操作和设备驱动两个层次。</span><br></pre></td></tr></table></figure><p>12、对I/O端口的访问和I/O空间的访问方式是一样的。（ × ）</p><p>13、网络驱动程序*<strong>*同步**</strong>接受来自外部世界的数据包。（ × ）</p><p>14、Linux设备模型将硬件设备归纳、分类，然后抽象出一套标准的数据结构和接口，驱动的开发就简化为对内核所规定的数据结构的填充和实现，这也是一种机制与策略分析思想的体现。 （ √ ）</p><p>二、单选题</p><p>1、Linux设备驱动模型使用一系列抽象， （ D ）不包括在其中。</p><p>​ A bus B device C driver D inode</p><p>2、用户程序发出磁盘I/O请求后，在系统处理流程中计算数据所在磁盘的柱面号、磁头号、扇区号的程序是（ C ）。</p><p>​ A 用户程序 B 系统调用程序 C 设备驱动程序 D 中断处理程序</p><p>3、字符设备驱动的编写中，（ A ）完成用户空间与内核空间数据的交换。</p><p>​ A 驱动的初始化 B 设备的操作 C 驱动的注销 D 硬件的初始化</p><p>4、Linux内核中的驱动开发中，基本围绕（ D ）抽象进行。</p><p>​ A 总线(bus) B 设备(device) C 类(class) D 驱动(driver)</p><p>5、内核利用（ B ）层启动I/O操作来传达所请求的数据。</p><p>​ A VFS B 通用块 C I/O调度 D 块设备驱动程序</p><p>6、文件系统的读写单位是（ B ）。</p><p>​ A 字节 B 块 C 扇区 D 磁盘</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">异步操作</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-10 21:36:32" itemprop="dateModified" datetime="2022-02-10T21:36:32+08:00">2022-02-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>15k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>14 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="（一）含义"><a href="#（一）含义" class="headerlink" title="（一）含义"></a>（一）含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 <code>Promise</code> 对象。<code>Promise</code> 可以说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><code>Promise</code> 对象有以下两个特点。</p><ul><li>对象的状态不受外界影响。<code>Promise</code> 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 <code>Promise</code> 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code> 对象的状态改变，只有两种可能：从 <code>pending</code> 变为 <code>fulfilled</code> 和从 <code>pending</code> 变为 <code>rejected</code>。只要这两种情况发生，状态就不会再变，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 <code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ul><p>注意，为了行文方便，本章后面的 <code>resolved</code> 统一只指 <code>fulfilled</code> 状态，不包含 <code>rejected</code> 状态。</p><p>有了 <code>Promise</code> 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code> 也有如下一些缺点。</p><ul><li><code>Promise</code> 一旦创建就会立即执行，无法中途取消。</li><li>如果不设置回调函数，<code>Promise</code> 内部抛出的错误不会反应到外部。</li><li>当处于 <code>pending</code> 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p>如果某些事件不断地反复发生，一般来说，使用 <a target="_blank" rel="noopener" href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署 <code>Promise</code> 更好的选择。</p><h2 id="（二）用法"><a href="#（二）用法" class="headerlink" title="（二）用法"></a>（二）用法</h2><p>ES6 规定，<code>Promise</code> 对象是一个构造函数，用来生成 <code>Promise</code> 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code> 构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和 <code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code> 函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果作为参数传递出去；<code>reject</code> 函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。</p><p><code>Promise</code> 实例生成以后，可以用 <code>then</code> 方法分别指定 <code>resolved</code> 状态和 <code>rejected</code> 状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code> 方法可以接受两个回调函数作为参数。第一个回调函数是 <code>Promise</code> 对象的状态变为 <code>resolved</code> 时调用，第二个回调函数是 <code>Promise</code> 对象的状态变为 <code>rejected</code> 时调用。这两个函数都是可选的，不一定要提供。它们都接受 <code>Promise</code> 对象传出的值作为参数。</p><p>下面是一个 <code>Promise</code> 对象的简单例子：<code>timeout</code> 方法返回一个 <code>Promise</code> 实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code> 实例的状态变为 <code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面是异步加载图片的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">        image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(image);</span><br><span class="line">        &#125;;</span><br><span class="line">        image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url));</span><br><span class="line">        &#125;;</span><br><span class="line">        image.src = url;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，使用 <code>Promise</code> 包装了一个图片加载的异步操作。如果加载成功，就调用 <code>resolve</code> 方法，否则就调用 <code>reject</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Promise对象实现的 Ajax 操作</span></span><br><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="built_in">this</span>.response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        client.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">        client.onreadystatechange = handler;</span><br><span class="line">        client.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">        client.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        client.send();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">&quot;/posts.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON</code> 是对 <code>XMLHttpRequest</code> 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在 <code>getJSON</code> 内部，<code>resolve</code>函数和 <code>reject</code> 函数调用时，都带有参数。</p><p>如果调用 <code>resolve</code> 函数和 <code>reject</code> 函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code> 函数的参数通常是 <code>Error</code> 对象的实例，表示抛出的错误；<code>resolve</code> 函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code> 和 <code>p2</code> 都是 Promise 的实例，但是 <code>p2</code> 的 <code>resolve</code> 方法将 <code>p1</code> 作为参数，即一个异步操作的结果是返回另一个异步操作。注意，这时 <code>p1</code> 的状态就会传递给 <code>p2</code>，也就是说，<code>p1</code> 的状态决定了 <code>p2</code> 的状态。如果 <code>p1</code> 的状态是 <code>pending</code>，那么 <code>p2</code> 的回调函数就会等待 <code>p1</code> 的状态改变；如果 <code>p1</code> 的状态已经是 <code>resolved</code> 或者 <code>rejected</code>，那么 <code>p2</code> 的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为 <code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是 <code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的 <code>then</code> 语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code> 变为 <code>rejected</code>，导致触发 <code>catch</code> 方法指定的回调函数。</p><h2 id="（三）特性"><a href="#（三）特性" class="headerlink" title="（三）特性"></a>（三）特性</h2><h3 id="1-立即执行性"><a href="#1-立即执行性" class="headerlink" title="1. 立即执行性"></a>1. 立即执行性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;create a promise&quot;</span>);</span><br><span class="line">  resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;after new Promise&quot;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;create a promise&quot;</span><br><span class="line">&quot;after new Promise&quot;</span><br><span class="line">&quot;success&quot;</span><br></pre></td></tr></table></figure><p>Promise 对象表示未来某个将要发生的事件，但在开始创建 Promise 时，作为参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有人错以为只有当 Promise 对象调用 <code>then</code> 方法时，Promise 接收的函数才会执行。<code>then</code> 方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。</p><p>注意，调用 <code>resolve</code> 或 <code>reject</code> 并不会终结 Promise 的参数函数的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用 <code>resolve(1)</code> 以后，后面的 <code>console.log(2)</code> 还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说，调用 <code>resolve</code> 或 <code>reject</code> 后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code> 或 <code>reject</code> 的后面。所以，最好在它们前面加上 <code>return</code> 语句，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-三种状态"><a href="#2-三种状态" class="headerlink" title="2. 三种状态"></a>2. 三种状态</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="number">2</span>);  </span><br><span class="line">    &#125;, <span class="number">500</span>);      </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        reject(<span class="number">3</span>);  </span><br><span class="line">    &#125;, <span class="number">500</span>);      </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br><span class="line"><span class="built_in">console</span>.log(p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p3);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1&#125;</span><br><span class="line">Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</span><br><span class="line">Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 2&#125;</span><br><span class="line">Promise &#123;[[PromiseStatus]]: &quot;rejected&quot;, [[PromiseValue]]: 3&#125;</span><br></pre></td></tr></table></figure><p>Promise 的内部实现是一个状态机，它有三种状态：pending，resolved，rejected。当 Promise 刚创建完成时，处于 pending 状态；当 Promise 中的函数参数执行了 <code>resolve()</code> 后，Promise 由 pending 状态变成 resolved 状态；执行 <code>reject()</code> 则会由 pending 状态变成 rejected 状态。</p><p>p2、p3 刚创建完成时，控制台输出的这两台 Promise 都处于 pending 状态，但为什么 p1 是 resolved 状态呢？ 这是因为 p1 的函数参数中执行的是一段同步代码，Promise 刚创建完成，resolve 方法就已经被调用了，因而紧跟着的输出显示 p1 是 resolved 状态。我们通过两个 <code>setTimeout</code> 函数，延迟 1s 后再次输出 p2、p3 的状态，此时 p2、p3 已经执行完成，状态分别变成 resolved 和 rejected。</p><h3 id="3-状态不可逆性"><a href="#3-状态不可逆性" class="headerlink" title="3. 状态不可逆性"></a>3. 状态不可逆性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">    resolve(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    reject(<span class="string">&quot;reject&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;success1&quot;</span><br><span class="line">&quot;success&quot;</span><br></pre></td></tr></table></figure><p>Promise 状态一旦变成 resolved 或 rejected 时，Promise 的状态和值就固定下来了，不论后续再怎么调用 resolve 或 reject 方法，都不能改变它的状态和值。因此，p1 中 <code>resolve(&quot;success2&quot;)</code>并不能将 p1 的值更改为 <code>success2</code>，p2 中 <code>reject(&quot;reject&quot;)</code> 也不能将 p2 的状态由 resolved 改变为 rejected。</p><h3 id="4-链式调用"><a href="#4-链式调用" class="headerlink" title="4. 链式调用"></a>4. 链式调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolve: &#x27;</span>+ value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;reject: &#x27;</span> + err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">undefined</span><br><span class="line">&quot;resolve&quot;</span><br><span class="line">&quot;reject: reject&quot;</span><br></pre></td></tr></table></figure><p>Promise 对象的 then 方法返回一个新的 Promise 对象，因此可以链式调用 then 方法。then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建 then 返回的 Promise 对象。这两个参数的返回值可以是以下三种情况中的一种：</p><ul><li><code>return</code> 一个同步的值 ，或者没有返回一个有效值时（默认返回 undefined），<code>then</code>方法将返回一个 resolved 状态的 Promise 对象，Promise 对象的值就是这个返回值。</li><li><code>return</code> 另一个 Promise，<code>then</code> 方法将根据这个 Promise 的状态和值创建一个新的 Promise 对象返回。</li><li><code>throw</code> 一个同步异常，<code>then</code> 方法将返回一个 rejected 状态的 Promise, 值是该异常。</li></ul><p>根据以上分析，代码中第一个 <code>then</code> 会返回一个值为2（1*2），状态为 resolved 的 Promise 对象，于是第二个 <code>then</code> 输出的值是2。第二个 <code>then</code> 中没有返回值，因此将返回默认的 undefined，于是在第三个 <code>then</code> 中输出 undefined。第三个 <code>then</code> 和第四个 <code>then</code> 中分别返回一个状态是 resolved 的 Promise 和一个状态是 rejected 的 Promise，依次由第四个 <code>then</code> 中成功的回调函数和第五个 <code>then</code> 中失败的回调函数处理。</p><h3 id="5-回调异步性"><a href="#5-回调异步性" class="headerlink" title="5. 回调异步性"></a>5. 回调异步性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;which one is called first ?&quot;</span>);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;which one is called first ?&quot;</span><br><span class="line">&quot;success&quot;</span><br></pre></td></tr></table></figure><p>Promise 接收的函数参数是同步执行的，但 <code>then</code> 方法中的回调函数执行则是异步的，因此，”success” 会在后面输出。</p><h3 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    foo.bar();</span><br><span class="line">    resolve(<span class="number">1</span>);	  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1 then value: &#x27;</span> + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1 then err: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1 then then value: &#x27;</span>+value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1 then then err: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);	</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then value: &#x27;</span> + value);</span><br><span class="line">        foo.bar();</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then err: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then then value: &#x27;</span> + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then then err: &#x27;</span> + err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then then then value: &#x27;</span> + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then then then err: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1 then err: ReferenceError: foo is not defined</span><br><span class="line">p2 then value: 2</span><br><span class="line">p1 then then value: undefined</span><br><span class="line">p2 then then err: ReferenceError: foo is not defined</span><br><span class="line">p2 then then then value: 1</span><br></pre></td></tr></table></figure><p>Promise 中的异常由 <code>then</code> 参数中第二个回调函数处理，异常信息将作为 Promise 的值。异常一旦得到处理，<code>then</code> 返回的后续 Promise 对象将恢复正常，并会被 Promise 执行成功的回调函数处理。另外，需要注意 p1、p2 多级 <code>then</code> 的回调函数是交替执行的 ，这正是由 <code>then</code> 回调的异步性决定的。</p><h3 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7. Promise.resolve()"></a>7. <code>Promise.resolve()</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(p1);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); </span><br><span class="line"><span class="built_in">console</span>.log(p1 === p3);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p4);</span><br><span class="line"><span class="built_in">console</span>.log(p3 === p4);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p4=&#x27;</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p2=&#x27;</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p1=&#x27;</span> + value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">p2&#x3D;1</span><br><span class="line">p1&#x3D;1</span><br><span class="line">p4&#x3D;1</span><br></pre></td></tr></table></figure><p><code>Promise.resolve(...)</code> 可以接收一个值或者是一个 Promise 对象作为参数。当参数是普通值时，它返回一个 resolved 状态的 Promise 对象，对象的值就是这个参数；当参数是一个 Promise 对象时，它直接返回这个 Promise 参数。因此，p1 === p2。但通过 new 的方式创建的 Promise 对象都是一个新的对象，因此后面的三个比较结果都是 false。另外，为什么 p4 的 <code>then</code> 最先调用，但在控制台上是最后输出结果的呢？因为 p4 的 <code>resolve</code> 中接收的参数是一个 Promise 对象 p1，<code>resolve</code> 会对 p1 拆箱，获取 p1 的状态和值，但这个过程是异步的，可参考下一节。</p><h3 id="8-resolve-VS-reject"><a href="#8-resolve-VS-reject" class="headerlink" title="8. resolve VS reject"></a>8. resolve VS reject</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;resolve&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="built_in">Promise</span>.reject(<span class="string">&#x27;reject&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    reject(<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;resolve&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled: &#x27;</span> + value);</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">p2.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled: &#x27;</span> + value);</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">p3.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled: &#x27;</span> + value);</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p3 rejected: [object Promise]</span><br><span class="line">p1 fulfilled: resolve</span><br><span class="line">p2 rejected: reject</span><br></pre></td></tr></table></figure><p>Promise 回调函数中的第一个参数 <code>resolve</code>，会对 Promise 执行拆箱动作。即当 <code>resolve</code> 的参数是一个 Promise 对象时，<code>resolve</code> 会拆箱获取这个 Promise 对象的状态和值，但这个过程是异步的。p1 拆箱后，获取到 Promise 对象的状态是 resolved，因此 <code>fulfilled</code> 回调被执行；p2 拆箱后，获取到 Promise 对象的状态是 rejected，因此 <code>rejected</code> 回调被执行。</p><p>但 Promise 回调函数中的第二个参数 <code>reject</code> 不具备拆箱的能力，reject 的参数会直接传递给 <code>then</code> 方法中的 <code>rejected</code> 回调。因此，即使 p3 <code>reject</code>接收了一个 resolved 状态的 Promise，<code>then</code> 方法中被调用的依然是 <code>rejected</code>，并且参数就是 <code>reject</code> 接收到的 Promise 对象。</p><h2 id="（四）Promise-实现"><a href="#（四）Promise-实现" class="headerlink" title="（四）Promise 实现"></a>（四）Promise 实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise内部已经实现具体的resolve和reject方法，只是还没有传入实参（关键数据）。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>; <span class="comment">// 缓存当前promise实例</span></span><br><span class="line">    self.value = <span class="literal">null</span>; <span class="comment">//成功时的值</span></span><br><span class="line">    self.error = <span class="literal">null</span>; <span class="comment">//失败时的原因</span></span><br><span class="line">    self.status = PENDING; <span class="comment">//初始状态为PENDING</span></span><br><span class="line">    self.onFulfilledCallbacks = []; <span class="comment">//成功的回调函数</span></span><br><span class="line">    self.onRejectedCallbacks = []; <span class="comment">//失败的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//只有当状态是PENDING才能修改状态为fulfilled并执行成功逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(self.status === PENDING) &#123;</span><br><span class="line">            <span class="comment">//利用setTimeout特性将具体执行放到then初始化之后</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                self.status = FULFILLED;</span><br><span class="line">                self.value = value;</span><br><span class="line">                self.onFulfilledCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.value))</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//如果状态是pending才去修改状态为rejected并执行失败逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                self.status = REJECTED;</span><br><span class="line">                self.error = error;</span><br><span class="line">                self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.error));</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve, reject);  <span class="comment">//这里体现Promise的立即执行性。</span></span><br><span class="line">    <span class="comment">//当Promise接收到函数参数fn时，会对其立即执行，只是其中的代码可能是异步代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> bridgePromise;</span><br><span class="line">    <span class="comment">//如果使用者没有传入成功或失败回调函数，那么就使用默认回调函数</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span> ? onRejected : <span class="function"><span class="params">error</span> =&gt;</span> &#123;<span class="keyword">throw</span> error&#125;;</span><br><span class="line">    <span class="keyword">if</span>(self.status === FULFILLED) &#123;</span><br><span class="line">        <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">                    resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(self.status === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(self.error);</span><br><span class="line">                    resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(self.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            self.onFulfilledCallbacks.push(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onFulfilled(value);</span><br><span class="line">                    resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            self.onRejectedCallbacks.push(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onRejeted(error);</span><br><span class="line">                    resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//catch方法是语法糖，就是只传onRejected不传onFulfilled的then方法</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来解析回调函数的返回值x，x可能是普通值也可能是promise对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">bridgePromise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果x是一个promise</span></span><br><span class="line">    <span class="keyword">if</span>(x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        <span class="comment">//如果这个promise是pending状态，就在它的then方法里继续执行resolvePromise解析它的结果，直到返回值不是一个pending状态的promise为止</span></span><br><span class="line">        <span class="keyword">if</span>(x.status === PENDING) &#123;</span><br><span class="line">            x.then(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                resolvePromise(bridgePromise, y, resolve, reject);</span><br><span class="line">            &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x.then(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果x是一个普通值，那么就让bridgePromise的状态fulfilled，并把这个值传递下去</span></span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">动态规划算法</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-26 21:09:53" itemprop="dateModified" datetime="2022-02-26T21:09:53+08:00">2022-02-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4.5k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>冒泡排序在每次冒泡操作时会比较相邻的两个元素，看是否满足大小关系要求，不满足就将它俩互换。一直迭代到不再需要交换，也就是排序完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        flag = <span class="literal">false</span> <span class="comment">// 提前退出冒泡循环的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">const</span> temp = arr[j]</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp</span><br><span class="line">                flag = <span class="literal">true</span> <span class="comment">// 表示有数据交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span> <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><p>插入排序顾名思义，对于未排序的数据，在已排序的序列中从后往前扫描，找到相应的位置进行插入，保持已排序序列中元素一直有序。从 i 等于 1 开始遍历，拿到当前元素 curr，与前面的元素进行比较。如果前面的元素大于当前元素，就把前面的元素和当前元素进行交换，不断循环直到未排序序列中元素为空，排序完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length</span><br><span class="line">    <span class="keyword">let</span> curr, prev</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        curr = arr[i]</span><br><span class="line">        prev = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (prev &gt;= <span class="number">0</span> &amp;&amp; arr[prev] &gt; curr) &#123;</span><br><span class="line">            arr[prev + <span class="number">1</span>] = arr[prev]</span><br><span class="line">            prev--</span><br><span class="line">        &#125;</span><br><span class="line">        arr[prev + <span class="number">1</span>] = curr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h3><p>选择排序和插入排序有些类似，也分已排序序列和未排序序列。</p><p>但是选择排序是将最小的元素存放在数组起始位置，再从剩下的未排序的序列中寻找最小的元素，然后将其放到已排序的序列后面。以此类推，直到排序完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length</span><br><span class="line">    <span class="keyword">let</span> temp, minIndex</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i]</span><br><span class="line">        arr[i] = arr[minIndex]</span><br><span class="line">        arr[minIndex] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h3><p>分治法典型应用，分治算法思想很大程度上是基于递归的，也比较适合用递归来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理过程是由下到上的，先处理子问题，然后再合并。</span><br></pre></td></tr></table></figure><p>分而治之。一般分为以下三个过程：</p><ol><li>分解：将原问题分解成一系列子问题。</li><li>解决：递归求解各个子问题，若子问题足够小，则直接求解。</li><li>合并：将子问题的结果合并成原问题。</li></ol><p>归并排序就是将待排序数组不断二分为规模更小的子问题处理，再将处理好的子问题合并起来，这样整个数组就都有序了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = []</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] &lt; right[j]) &#123;</span><br><span class="line">                result.push(left[i++])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.push(right[j++])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; left.length) &#123;</span><br><span class="line">            result.push(left[i++])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; right.length) &#123;</span><br><span class="line">            result.push(right[j++])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> sort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length === <span class="number">1</span>) &#123; <span class="keyword">return</span> arr &#125; <span class="comment">// 注意这句</span></span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>, mid)</span><br><span class="line">        <span class="keyword">const</span> right = arr.slice(mid, arr.length)</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sort(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h3><p>快速排序也是分治法的应用，处理过程是由上到下的，先分区，然后再处理子问题。快速排序通过遍历数组，将待排序元素分隔成独立的两部分，一部分记录的元素均比另一部分的元素小，则可以分别对这两部分记录的元素继续进行排序，直到排序完成。</p><p>这就需要从数组中挑选出一个元素作为 <code>基准(pivot)</code>，然后重新排序数列，将元素比基准值小的放到基准前面，比基准值大的放到基准后面。然后将小于基准值的子数组(left)和大于基准值的子数组(right)递归地调用 quick 方法，直到排序完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> quick = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">const</span> len = arr.length</span><br><span class="line">        <span class="keyword">const</span> index = <span class="built_in">Math</span>.floor(len &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">const</span> pivot = arr.splice(index, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">const</span> left = []</span><br><span class="line">        <span class="keyword">const</span> right = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">                right.push(arr[i])</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</span><br><span class="line">                left.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quick(left).concat([pivot], quick(right))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quick(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己写的嘻嘻</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> pivot = arr.splice(<span class="built_in">Math</span>.floor(len &gt;&gt; <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> left = [], right = [];</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(item &lt; pivot) &#123;</span><br><span class="line">            left.push(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(pivot).concat(quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h3><p>堆排序相比其他几种排序代码会有些复杂，先来看一些前置知识帮助理解。堆排序顾名思义就是要利用堆这种数据结构进行排序。堆是一种特殊的树，满足以下两点就是堆：</p><ul><li>堆是一个完全二叉树</li><li>堆中每一个节点的值都必须大于等于(或小于等于)其子树中的每个节点的值</li></ul><p>每个节点的值都大于等于子树中每个节点值的堆，叫做大顶堆，每个节点的值都小于等于子树中每个节点值的堆，叫做小顶堆。也就是说，大顶堆中，根节点是堆中最大的元素。小顶堆中，根节点是堆中最小的元素。堆如果用一个数组表示的话，给定一个节点的下标 i (i从1开始)，那么它的父节点一定为 A[i / 2]，左子节点为 A[2i]，右子节点为 A[2i + 1]。</p><p>堆排序包含两个过程，建堆和排序。首先构建一个大顶堆，也就是将最大值存储在根节点(i = 1)。每次取大顶堆的根节点与堆的最后一个节点进行交换，此时最大值放入了有效序列的最后一位，并且有效序列减 1，有效堆依然保持完全二叉树的结构，然后进行堆化成为新的大顶堆。重复此操作，直到有效堆的长度为 0，排序完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heapSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    buildHeap(arr, arr.length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> heapSize = arr.length - <span class="number">1</span> <span class="comment">// 初始化堆的有效序列长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(arr, <span class="number">1</span>, i) <span class="comment">// 交换堆顶元素与最后一个有效子元素</span></span><br><span class="line">        heapSize-- <span class="comment">// 有效序列长度减 1</span></span><br><span class="line">        heapify(arr, heapSize, <span class="number">1</span>) <span class="comment">// 堆化有效序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建大顶堆</span></span><br><span class="line"><span class="keyword">const</span> buildHeap = <span class="function"><span class="keyword">function</span>(<span class="params">items, heapSize</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从后往前并不是从序列的最后一个元素开始，而是从最后一个非叶子节点开始，这是因为，叶子节点没有子节点，不需要自上而下式堆化。</span></span><br><span class="line">    <span class="comment">// 最后一个子节点的父节点为 n/2 ，所以从 n/2 位置节点开始堆化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>); i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        heapify(items, heapSize, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆化</span></span><br><span class="line"><span class="keyword">const</span> heapify = <span class="function"><span class="keyword">function</span>(<span class="params">arr, heapSize, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxIndex = i</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * i &lt;= heapSize &amp;&amp; arr[i] &lt; arr[i * <span class="number">2</span>]) &#123;</span><br><span class="line">            maxIndex = i * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= heapSize &amp;&amp; arr[maxIndex] &lt; arr[i * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">            maxIndex = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxIndex === i) <span class="keyword">break</span></span><br><span class="line">        swap(arr, i, maxIndex)</span><br><span class="line">        i = maxIndex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换工具函数</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function"><span class="keyword">function</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">    arr[i] = arr[j]</span><br><span class="line">    arr[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174333.png" alt="image-20210822173636751" style="zoom:50%"></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">页面加载海量数据</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:21:01" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.2k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><strong>题目</strong>：将包含 10w 条记录的数组一次性渲染到页面上，如何处理可以不冻结 UI ?</p><div class="post-button"><a class="btn" href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E6%95%B0%E7%BB%84/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">JS 数组常见需求</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-28 21:36:19" itemprop="dateModified" datetime="2022-02-28T21:36:19+08:00">2022-02-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h1 id="（一）数组常见需求"><a href="#（一）数组常见需求" class="headerlink" title="（一）数组常见需求"></a>（一）数组常见需求</h1><h2 id="检验数组"><a href="#检验数组" class="headerlink" title="检验数组"></a><strong>检验数组</strong></h2><p>不能使用 <code>typeof</code> 方法检验一个变量是否为数组，因为它的检测结果只有 <code>undefined</code>、<code>object</code>、<code>function</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(arr)); <span class="comment">//&quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>推荐使用 Array 自带的 <code>isArray()</code> 方法进行检验。</p><p>或者使用 <code>Object.prototype.toString.call(arr).slice(8, -1)===&quot;Array&quot;</code> 进行判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)); <span class="comment">// &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure><p>不能直接使用 <code>arr.toString()</code> 来确定类型的原因在于，Object 的 <code>toString</code> 方法被其实例 Array 进行了重写。当数组对象调用自身的 <code>toString</code> 方法时，会用逗号拼接数组中的所有值，并返回其字符串形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.toString()); <span class="comment">// &quot;a,b,c&quot;</span></span><br></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a><strong>数组去重</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test.push(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>(test)); <span class="comment">// &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span></span><br><span class="line"><span class="keyword">var</span> test1 = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(test));</span><br><span class="line"><span class="built_in">console</span>.log(test1); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test2 = test.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> test.indexOf(item) === index);</span><br><span class="line"><span class="built_in">console</span>.log(test2); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> test3 = [...new <span class="built_in">Set</span>(test)]</span><br><span class="line"><span class="built_in">console</span>.log(unique(test)) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 <code>Array.prototype.flat</code> 可以直接将多层数组拍平成一层：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="number">2</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>接下来手动模拟 flat 这种效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> pos = list.indexOf(<span class="number">1</span>)</span><br><span class="line">list.splice(pos, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.info(list) <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><h1 id="（二）面试题"><a href="#（二）面试题" class="headerlink" title="（二）面试题"></a>（二）面试题</h1><h2 id="1-quot-0x1-quot-quot-0x2-quot-quot-0x3-quot-map-parseInt"><a href="#1-quot-0x1-quot-quot-0x2-quot-quot-0x3-quot-map-parseInt" class="headerlink" title="1. [&quot;0x1&quot;, &quot;0x2&quot;, &quot;0x3&quot;].map(parseInt)"></a>1. <code>[&quot;0x1&quot;, &quot;0x2&quot;, &quot;0x3&quot;].map(parseInt)</code></h2><p>正确结果：<code>[1,NaN,0]</code></p><p>首先代码可转换如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="string">&quot;0x1&quot;</span>, <span class="string">&quot;0x2&quot;</span>, <span class="string">&quot;0x3&quot;</span>].map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(item, index)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseInt方法：parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数， radix 是2-36之间的整数，表示被解析字符串的基数。radix 参数可选，如果radix不选或者等于0的时候，该方法首先会对 string 方法进行识别是几进制的数，然后转化为十进制的数。</p><ul><li>因为 parseInt 可以传递2个参数，然后自动的给它按顺序的传递了item和index的参数。</li><li>因此 arr 就等于：<code>arr = [parseInt(&quot;0x1&quot;, 0), parseInt(&quot;0x2&quot;, 1), parseInt(&quot;0x3&quot;, 2)]</code>;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>第一个元素：以为radix等于<span class="number">0</span>，所以<span class="built_in">parseInt</span>就会自动的识别string是不是一个正确的进制数，发现“<span class="number">0x1</span>”是一个<span class="number">16</span>进制的数，所以它会把“<span class="number">0x1</span>”当作一个<span class="number">16</span>进制的数然后再转化为<span class="number">10</span>进制。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>第二个元素：radix = <span class="number">1</span>，因为没有不存在<span class="number">1</span>进制的数，所以就直接返回<span class="literal">NaN</span>。  </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>第三个元素：radix = <span class="number">2</span>，“<span class="number">0x3</span>”当作二进制数然后转化为<span class="number">10</span>进制数，二进制数就只包含<span class="number">0</span>和<span class="number">1</span>，所以在“<span class="number">0x3</span>”中在满足条件的最前面就只有<span class="number">0</span>，所以二机制<span class="number">0</span>转化为<span class="number">10</span>进制为<span class="number">0.</span></span><br><span class="line"></span><br><span class="line">所以输出结果就是[<span class="number">1</span>,<span class="literal">NaN</span>,<span class="number">0</span>].</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x3</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0x3&#x27;</span>, <span class="number">2</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="2-array-sort"><a href="#2-array-sort" class="headerlink" title="2.  array.sort()"></a>2. <code>array.sort()</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a-<span class="number">2</span>)-<span class="built_in">Math</span>.abs(b-<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E6%89%8B%E5%86%99/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E6%89%8B%E5%86%99/" class="post-title-link" itemprop="url">JS 函数手写</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-28 16:05:49" itemprop="dateModified" datetime="2022-02-28T16:05:49+08:00">2022-02-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>26k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>24 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>浅拷贝：只考虑对象类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>极简版深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单版深拷贝：只考虑普通对象属性，不考虑内置对象和函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = deepClone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂版深克隆：基于简单版的基础上，还考虑了解决循环引用的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>obj 要拷贝的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Map&#125;</span> </span>map 用于存储循环引用对象的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj = &#123;&#125;, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (map.get(obj)) <span class="keyword">return</span> map.get(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 初始化返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ||</span><br><span class="line">        <span class="comment">// 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此</span></span><br><span class="line">        <span class="built_in">Object</span>.prototype.toString(obj) === <span class="string">&quot;[object Array]&quot;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止循环引用</span></span><br><span class="line">    map.set(obj, result);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">// 保证 key 不是原型属性</span></span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            result[key] = deepClone(obj[key], map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件总线（发布订阅模式）"><a href="#事件总线（发布订阅模式）" class="headerlink" title="事件总线（发布订阅模式）"></a>事件总线（发布订阅模式）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cache = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">on</span>(<span class="params">name, fn</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cache[name]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.cache[name].push(fn)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cache[name] = [fn]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">off</span>(<span class="params">name, fn</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tasks = <span class="built_in">this</span>.cache[name]</span><br><span class="line">        <span class="keyword">if</span> (tasks) &#123;</span><br><span class="line">            <span class="keyword">const</span> index = tasks.findIndex(<span class="function"><span class="params">f</span> =&gt;</span> f === fn || f.callback === fn)</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                tasks.splice(index, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">emit</span>(<span class="params">name, once = <span class="literal">false</span>, ...args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cache[name]) &#123;</span><br><span class="line">            <span class="comment">// 创建副本，如果回调函数内继续注册相同事件，会造成死循环</span></span><br><span class="line">            <span class="keyword">let</span> tasks = <span class="built_in">this</span>.cache[name].slice()</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> tasks) &#123;</span><br><span class="line">                fn(...args)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (once) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="built_in">this</span>.cache[name]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> eventBus = <span class="keyword">new</span> EventEmitter()</span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`hello, <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">eventBus.on(<span class="string">&#x27;aaa&#x27;</span>, fn1)</span><br><span class="line">eventBus.on(<span class="string">&#x27;aaa&#x27;</span>, fn2)</span><br><span class="line">eventBus.emit(<span class="string">&#x27;aaa&#x27;</span>, <span class="literal">false</span>, <span class="string">&#x27;布兰&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="comment">// &#x27;布兰 12&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;hello, 布兰 12&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解析-URL-参数为对象"><a href="#解析-URL-参数为对象" class="headerlink" title="解析 URL 参数为对象"></a>解析 URL 参数为对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParam</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.exec(url)[<span class="number">1</span>]; <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">    <span class="keyword">const</span> paramsArr = paramsStr.split(<span class="string">&#x27;&amp;&#x27;</span>); <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">    <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">    paramsArr.forEach(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/=/</span>.test(param)) &#123; <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">            <span class="keyword">let</span> [key, val] = param.split(<span class="string">&#x27;=&#x27;</span>); <span class="comment">// 分割 key 和 value</span></span><br><span class="line">            val = <span class="built_in">decodeURIComponent</span>(val); <span class="comment">// 解码</span></span><br><span class="line">            val = <span class="regexp">/^\d+$/</span>.test(val) ? <span class="built_in">parseFloat</span>(val) : val; <span class="comment">// 判断是否转为数字</span></span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123; <span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">                paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">                paramsObj[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">            paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>; <span class="comment">// 模板字符串正则</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(template)) &#123; <span class="comment">// 判断模板里是否有模板字符串</span></span><br><span class="line">        <span class="keyword">const</span> name = reg.exec(template)[<span class="number">1</span>]; <span class="comment">// 查找当前模板里第一个模板字符串的字段</span></span><br><span class="line">        template = template.replace(reg, data[name]); <span class="comment">// 将第一个模板字符串渲染</span></span><br><span class="line">        <span class="keyword">return</span> render(template, data); <span class="comment">// 递归的渲染并返回渲染后的结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> template; <span class="comment">// 如果模板没有模板字符串直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">&#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">render(template, person); <span class="comment">// 我是布兰，年龄12，性别undefined</span></span><br></pre></td></tr></table></figure><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>与普通的图片懒加载不同，如下这个多做了 2 个精心处理：</p><ul><li>图片全部加载完成后移除事件监听；</li><li>加载完的图片，从 imgList 移除；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imgList = [...document.querySelectorAll(<span class="string">&#x27;img&#x27;</span>)]</span><br><span class="line"><span class="keyword">let</span> length = imgList.length</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> imgLazyLoad = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> deleteIndexList = []</span><br><span class="line">        imgList.forEach(<span class="function">(<span class="params">img, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> rect = img.getBoundingClientRect()</span><br><span class="line">            <span class="keyword">if</span> (rect.top &lt; <span class="built_in">window</span>.innerHeight) &#123;</span><br><span class="line">                img.src = img.dataset.src</span><br><span class="line">                deleteIndexList.push(index)</span><br><span class="line">                count++</span><br><span class="line">                <span class="keyword">if</span> (count === length) &#123;</span><br><span class="line">                    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;scroll&#x27;</span>, imgLazyLoad)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        imgList = imgList.filter(<span class="function">(<span class="params">img, index</span>) =&gt;</span> !deleteIndexList.includes(index))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里最好加上防抖处理</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, imgLazyLoad)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903856489365518#heading-19">图片懒加载</a></p><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>触发高频事件 N 秒后只会执行一次，如果 N 秒内事件再次触发，则会重新计时。</p><p>简单版：函数内部支持使用 this 和 event 对象；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;layout&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, e)  <span class="comment">// 分别打印：node 这个节点 和 MouseEvent</span></span><br><span class="line">    node.innerHTML = count++;</span><br><span class="line">&#125;;</span><br><span class="line">node.onmousemove = debounce(getUserAction, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>最终版：除了支持 this 和 event 外，还支持以下功能：</p><ul><li>支持立即执行；</li><li>函数可能有返回值；</li><li>支持取消功能；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, result;</span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setUseAction = debounce(getUserAction, <span class="number">10000</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 使用防抖</span></span><br><span class="line">node.onmousemove = setUseAction</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消防抖</span></span><br><span class="line">setUseAction.cancel()</span><br></pre></td></tr></table></figure><p>参考：<a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/22">JavaScript专题之跟着underscore学防抖</a></p><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>触发高频事件，且 N 秒内只执行一次。</p><p>简单版：使用时间戳来实现，立即执行一次，然后每 N 秒执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        context = <span class="built_in">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终版：支持取消节流；另外通过传入第三个参数，options.leading 来表示是否可以立即执行一次，opitons.trailing 表示结束调用的时候是否还要执行一次，默认都是 true。 注意设置的时候不能同时将 leading 或 trailing 设置为 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="built_in">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        previous = <span class="number">0</span>;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>节流的使用就不拿代码举例了，参考防抖的写就行。</p><p>参考：<a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/26">JavaScript专题之跟着 underscore 学节流</a></p><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>什么叫函数柯里化？其实就是将使用多个参数的函数转换成一系列使用一个参数的函数的技术。还不懂？来举个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> addCurry = curry(add)</span><br><span class="line">addCurry(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在就是要实现 curry 这个函数，使函数从一次调用传入多个参数变成多次调用每次传一个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> judge = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == fn.length) <span class="keyword">return</span> fn(...args)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> judge(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> judge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>什么是偏函数？偏函数就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> partialAdd = partial(add, <span class="number">1</span>)</span><br><span class="line">partialAdd(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>发现没有，其实偏函数和函数柯里化有点像，所以根据函数柯里化的实现，能够能很快写出偏函数的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上这个功能比较简单，现在我们希望偏函数能和柯里化一样能实现占位功能，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clg</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> partialClg = partial(clg, <span class="string">&#x27;_&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">partialClg(<span class="number">1</span>, <span class="number">3</span>)  <span class="comment">// 依次打印：1, 2, 3</span></span><br></pre></td></tr></table></figure><p><code>_</code> 占的位其实就是 1 的位置。相当于：partial(clg, 1, 2)，然后 partialClg(3)。明白了原理，我们就来写实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        args[index] = </span><br><span class="line">        <span class="keyword">return</span> fn(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 核心原理：script 标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于 GET 请求；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonp = <span class="function">(<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> generateUrl = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dataSrc = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">            <span class="keyword">if</span> (params.hasOwnProperty(key)) &#123;</span><br><span class="line">                dataSrc += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dataSrc += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataSrc&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">        scriptEle.src = generateUrl()</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(scriptEle)</span><br><span class="line">        <span class="built_in">window</span>[callbackName] = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            <span class="built_in">document</span>.removeChild(scriptEle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Mscrosoft.XMLHttp&#x27;</span>);</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">false</span>);</span><br><span class="line">        xhr.setRequestHeader(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">                resolve(xhr.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.responseText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现数组原型方法"><a href="#实现数组原型方法" class="headerlink" title="实现数组原型方法"></a>实现数组原型方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach2 = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)  <span class="comment">// this 就是当前的数组</span></span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">// 后面有解释</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            callback.call(thisArg, O[k], k, O);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach%23polyfill">forEach#polyfill</a></p><p>O.length &gt;&gt;&gt; 0 是什么操作？就是无符号右移 0 位，那有什么意义嘛？就是为了保证转换后的值为正整数。其实底层做了 2 层转换，第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型。感兴趣可以阅读 <a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/100790268">something &gt;&gt;&gt; 0是什么意思?</a>。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>基于 forEach 的实现能够很容易写出 map 的实现：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span></span><br><span class="line"><span class="addition">+ Array.prototype.map2 = function(callback, thisArg) &#123;</span></span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&#x27;this is null or not defined&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &#x27; is not a function&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line"><span class="deletion">-   let k = 0</span></span><br><span class="line"><span class="addition">+   let k = 0, res = []</span></span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line"><span class="deletion">-           callback.call(thisArg, O[k], k, O);</span></span><br><span class="line"><span class="addition">+           res[k] = callback.call(thisArg, O[k], k, O);</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+   return res</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>同样，基于 forEach 的实现能够很容易写出 filter 的实现：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span></span><br><span class="line"><span class="addition">+ Array.prototype.filter2 = function(callback, thisArg) &#123;</span></span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&#x27;this is null or not defined&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &#x27; is not a function&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line"><span class="deletion">-   let k = 0</span></span><br><span class="line"><span class="addition">+   let k = 0, res = []</span></span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line"><span class="deletion">-           callback.call(thisArg, O[k], k, O);</span></span><br><span class="line"><span class="addition">+           if (callback.call(thisArg, O[k], k, O)) &#123;</span></span><br><span class="line"><span class="addition">+               res.push(O[k])                </span></span><br><span class="line"><span class="addition">+           &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+   return res</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>同样，基于 forEach 的实现能够很容易写出 some 的实现：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- Array.prototype.forEach2 = function(callback, thisArg) &#123;</span></span><br><span class="line"><span class="addition">+ Array.prototype.some2 = function(callback, thisArg) &#123;</span></span><br><span class="line">    if (this == null) &#123;</span><br><span class="line">        throw new TypeError(&#x27;this is null or not defined&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof callback !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(callback + &#x27; is not a function&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    const O = Object(this)</span><br><span class="line">    const len = O.length &gt;&gt;&gt; 0</span><br><span class="line">    let k = 0</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">        if (k in O) &#123;</span><br><span class="line"><span class="deletion">-           callback.call(thisArg, O[k], k, O);</span></span><br><span class="line"><span class="addition">+           if (callback.call(thisArg, O[k], k, O)) &#123;</span></span><br><span class="line"><span class="addition">+               return true</span></span><br><span class="line"><span class="addition">+           &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+   return false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce2 = <span class="function"><span class="keyword">function</span>(<span class="params">callback, initialValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">const</span> len = O.length &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>, acc</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        acc = initialValue</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没传入初始值的时候，取数组中第一个非 empty 的值为初始值</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; len &amp;&amp; !(k <span class="keyword">in</span> O)) &#123;</span><br><span class="line">            k++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; len) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>( <span class="string">&#x27;Reduce of empty array with no initial value&#x27;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        acc = O[k++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">            acc = callback(acc, O[k], k, O)</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDeep</span>(<span class="params">arr1</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> arr1.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), []);</span><br><span class="line">&#125;</span><br><span class="line">flattenDeep(arr1);<span class="comment">// [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h2 id="实现函数原型方法"><a href="#实现函数原型方法" class="headerlink" title="实现函数原型方法"></a>实现函数原型方法</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>使用一个指定的 this 值和一个或多个参数来调用一个函数。</p><p>实现要点：</p><ul><li>this 可能传入 null；</li><li>传入不固定个数的参数；</li><li>函数可能有返回值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args +<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply 和 call 一样，唯一的区别就是 call 是传入不固定个数的参数，而 apply 是传入一个数组。</p><p>实现要点：</p><ul><li>this 可能传入 null；</li><li>传入一个数组；</li><li>函数可能有返回值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="string">&#x27;arr[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind 方法会创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><p>实现要点：</p><ul><li>bind() 除了 this 外，还可传入多个参数；</li><li>bing 创建的新函数可能传入多个参数；</li><li>新函数可能被当做构造函数调用；</li><li>函数可能有返回值；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现-new-关键字"><a href="#实现-new-关键字" class="headerlink" title="实现 new 关键字"></a>实现 new 关键字</h2><p>new 运算符用来创建用户自定义的对象类型的实例或者具有构造函数的内置对象的实例。</p><p>实现要点：</p><ul><li>new 会产生一个新对象；</li><li>新对象需要能够访问到构造函数的属性，所以需要重新指定它的原型；</li><li>构造函数可能会显示返回；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ret || obj 这里这么写考虑了构造函数显示返回 null 的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> ? ret || obj : obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = objectFactory(person, <span class="string">&#x27;布兰&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现-instanceof-关键字"><a href="#实现-instanceof-关键字" class="headerlink" title="实现 instanceof 关键字"></a>实现 instanceof 关键字</h2><p>instanceof 就是判断构造函数的 prototype 属性是否出现在实例的原型链上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = left.__proto__</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (proto === right.prototype) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        proto = proto.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的 left.<strong>proto</strong> 这种写法可以换成 Object.getPrototypeOf(left)。</p><h2 id="实现-Object-create"><a href="#实现-Object-create" class="headerlink" title="实现 Object.create"></a>实现 Object.create</h2><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create2 = <span class="function"><span class="keyword">function</span>(<span class="params">proto, propertyObject = <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Object prototype may only be an Object or null.&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (propertyObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = proto</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="keyword">new</span> F()</span><br><span class="line">    <span class="keyword">if</span> (propertyObject != <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(obj, propertyObject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个没有原型对象的对象，Object.create(null)</span></span><br><span class="line">        obj.__proto__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现-Object-assign"><a href="#实现-Object-assign" class="headerlink" title="实现 Object.assign"></a>实现 Object.assign</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign2 = <span class="function"><span class="keyword">function</span>(<span class="params">target, ...source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="built_in">Object</span>(target) </span><br><span class="line">    source.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                    ret[key] = obj[key]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现-JSON-stringify"><a href="#实现-JSON-stringify" class="headerlink" title="实现 JSON.stringify"></a>实现 JSON.stringify</h2><p>JSON.stringify([, replacer [, space]) 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 replacer 和第三个参数 space，如果对这两个参数的作用还不了解，建议阅读 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">MDN</a> 文档。</p><ol><li>基本数据类型：<ul><li>undefined 转换之后仍是 undefined(类型也是 undefined)</li><li>boolean 值转换之后是字符串 “false”/“true”</li><li>number 类型(除了 NaN 和 Infinity)转换之后是字符串类型的数值</li><li>symbol 转换之后是 undefined</li><li>null 转换之后是字符串 “null”</li><li>string 转换之后仍是string</li><li>NaN 和 Infinity 转换之后是字符串 “null”</li></ul></li><li>函数类型：转换之后是 undefined</li><li>如果是对象类型(非函数)<ul><li>如果是一个数组：如果属性值中出现了 undefined、任意的函数以及 symbol，转换成字符串 “null” ；</li><li>如果是 RegExp 对象：返回 {} (类型是 string)；</li><li>如果是 Date 对象，返回 Date 的 toJSON 字符串值；</li><li>如果是普通对象；<ul><li>如果有 toJSON() 方法，那么序列化 toJSON() 的返回值。</li><li>如果属性值中出现了 undefined、任意的函数以及 symbol 值，忽略。</li><li>所有以 symbol 为属性键的属性都会被完全忽略掉。</li></ul></li></ul></li><li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataType = <span class="keyword">typeof</span> data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dataType !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = data;</span><br><span class="line">        <span class="comment">//data 可能是 string/number/null/undefined/boolean</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(data) || data === <span class="literal">Infinity</span>) &#123;</span><br><span class="line">            <span class="comment">//NaN 和 Infinity 序列化返回 &quot;null&quot;</span></span><br><span class="line">            result = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&#x27;function&#x27;</span> || dataType === <span class="string">&#x27;undefined&#x27;</span> || dataType === <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//function 、undefined 、symbol 序列化返回 undefined</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            result = <span class="string">&#x27;&quot;&#x27;</span> + data + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//boolean 返回 String()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.toJSON &amp;&amp; <span class="keyword">typeof</span> data.toJSON === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> jsonStringify(data.toJSON());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> result = [];</span><br><span class="line">            <span class="comment">//如果是数组</span></span><br><span class="line">            <span class="comment">//toJSON 方法可以存在于原型链中</span></span><br><span class="line">            data.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&#x27;undefined&#x27;</span> || <span class="keyword">typeof</span> item === <span class="string">&#x27;function&#x27;</span> || <span class="keyword">typeof</span> item === <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">                    result[index] = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result[index] = jsonStringify(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            result = <span class="string">&quot;[&quot;</span> + result + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> result.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//普通对象</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 循环引用抛错(暂未检测，循环引用时，堆栈溢出)</span></span><br><span class="line"><span class="comment">             * symbol key 忽略</span></span><br><span class="line"><span class="comment">             * undefined、函数、symbol 为属性值，被忽略</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">let</span> result = [];</span><br><span class="line">            <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">//key 如果是symbol对象，忽略</span></span><br><span class="line">                    <span class="keyword">if</span> (data[item] !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> data[item] !== <span class="string">&#x27;function&#x27;</span></span><br><span class="line">                        &amp;&amp; <span class="keyword">typeof</span> data[item] !== <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">//键值如果是 undefined、函数、symbol 为属性值，忽略</span></span><br><span class="line">                        result.push(<span class="string">&#x27;&quot;&#x27;</span> + item + <span class="string">&#x27;&quot;&#x27;</span> + <span class="string">&quot;:&quot;</span> + jsonStringify(data[item]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;&#123;&quot;</span> + result + <span class="string">&quot;&#125;&quot;</span>).replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a href="https://link.juejin.cn/?target=https://github.com/YvetteLau/Step-By-Step/issues/39%23issuecomment-508327280">实现 JSON.stringify</a></p><h2 id="实现-JSON-parse"><a href="#实现-JSON-parse" class="headerlink" title="实现 JSON.parse"></a>实现 JSON.parse</h2><p>介绍 2 种方法实现：</p><ul><li>eval 实现；</li><li>new Function 实现；</li></ul><h3 id="eval-实现"><a href="#eval-实现" class="headerlink" title="eval 实现"></a>eval 实现</h3><p>第一种方式最简单，也最直观，就是直接调用 eval，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> + json + <span class="string">&quot;)&quot;</span>);  <span class="comment">// obj 就是 json 反序列化之后得到的对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是直接调用 eval 会存在安全问题，如果数据中可能不是 json 数据，而是可执行的 JavaScript 代码，那很可能会造成 XSS 攻击。因此，在调用 eval 之前，需要对数据进行校验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">    rx_one.test(</span><br><span class="line">        json.replace(rx_two, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">            .replace(rx_three, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">            .replace(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> +json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a href="https://link.juejin.cn/?target=https://github.com/youngwind/blog/issues/115%23issue-300869613">JSON.parse 三种实现方式</a></p><h3 id="new-Function-实现"><a href="#new-Function-实现" class="headerlink" title="new Function 实现"></a>new Function 实现</h3><p>Function 与 eval 有相同的字符串参数特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = (<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;return &#x27;</span> + json))();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现-Promise"><a href="#实现-Promise" class="headerlink" title="实现 Promise"></a>实现 Promise</h2><p>实现 Promise 需要完全读懂 <a href="https://link.juejin.cn/?target=https://promisesaplus.com/">Promise A+ 规范</a>，不过从总体的实现上看，有如下几个点需要考虑到：</p><ul><li>then 需要支持链式调用，所以得返回一个新的 Promise；</li><li>处理异步问题，所以得先用 onResolvedCallbacks 和 onRejectedCallbacks 分别把成功和失败的回调存起来；</li><li>为了让链式调用正常进行下去，需要判断 onFulfilled 和 onRejected 的类型；</li><li>onFulfilled 和 onRejected 需要被异步调用，这里用 setTimeout 模拟异步；</li><li>处理 Promise 的 resolve；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> resolve = (value) = &gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.value = value;</span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.forEach((fn) = &gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> reject = (reason) = &gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.reason = reason;</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach((fn) = &gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 解决 onFufilled，onRejected 没有传值的问题</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : (v) = &gt; v;</span><br><span class="line">        <span class="comment">// 因为错误的值要让后面访问到，所以这里也要抛出错误，不然会在之后 then 的 resolve 中捕获</span></span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span> ? onRejected : (err) = &gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 每次调用 then 都返回一个新的 promise</span></span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) = &gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">                <span class="comment">//Promise/A+ 2.2.4 --- setTimeout</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        <span class="comment">// x可能是一个proimise</span></span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">                <span class="comment">//Promise/A+ 2.2.3</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.push(() = &gt; &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            </span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(() = &gt; &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> resolvePromise = (promise2, x, resolve, reject) = &gt; &#123;</span><br><span class="line">    <span class="comment">// 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Promise/A+ 2.3.3.3.3 只能调用一次</span></span><br><span class="line">    <span class="keyword">let</span> called;</span><br><span class="line">    <span class="comment">// 后续的条件要严格判断 保证代码能和别的库一起使用</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> &amp;&amp; x != <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3</span></span><br><span class="line">                then.call(</span><br><span class="line">                    x, (y) = &gt; &#123;</span><br><span class="line">                        <span class="comment">// 根据 promise 的状态决定是成功还是失败</span></span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1</span></span><br><span class="line">                        resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                    &#125;, (r) = &gt; &#123;</span><br><span class="line">                        <span class="comment">// 只要失败就失败 Promise/A+ 2.3.3.3.2</span></span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        reject(r);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4</span></span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// Promise/A+ 2.3.3.2</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4</span></span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Promise 写完之后可以通过 promises-aplus-tests 这个包对我们写的代码进行测试，看是否符合 A+ 规范。不过测试前还得加一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="comment">// 这里是上面写的 Promise 全部代码</span></span><br><span class="line"><span class="built_in">Promise</span>.defer = <span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure><p>全局安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i promises-aplus-tests -g</span><br></pre></td></tr></table></figure><p>终端下执行验证命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-tests promise.js</span><br></pre></td></tr></table></figure><p>上面写的代码可以顺利通过全部 872 个测试用例。</p><p>参考：</p><ul><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903625769091079">BAT前端经典面试问题：史上最最最详细的手写Promise教程</a></li><li><a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g">100 行代码实现 Promises/A+ 规范</a></li></ul><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>Promsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是 Promsie，则直接输出它</span></span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a href="https://link.juejin.cn/?target=https://bubuzou.com/2020/10/22/promise/">深入理解 Promise</a></p><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all 的规则是这样的：</p><ul><li>传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise；</li><li>只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值；</li><li>只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>, result = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                index++</span><br><span class="line">                result[i] = val</span><br><span class="line">                <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                rejecte(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>Promise.allSettled 的规则是这样：</p><ul><li>所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise，且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象；</li><li>如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    status: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">                    value: val</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">if</span> (result.length === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    status: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">                    reason: err</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">if</span> (result.length === promiseArr.length) &#123;</span><br><span class="line">                    resolve(result) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>Promise.any 的规则是这样：</p><ul><li>空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；</li><li>只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；</li><li>其他情况都会返回一个 pending 的新实例；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (promiseArr.length === <span class="number">0</span>) <span class="keyword">return</span> </span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">                </span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                index++</span><br><span class="line">                <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                  reject(<span class="keyword">new</span> AggregateError(<span class="string">&#x27;All promises were rejected&#x27;</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" class="post-title-link" itemprop="url">事件循环</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-28 22:17:59" itemprop="dateModified" datetime="2022-02-28T22:17:59+08:00">2022-02-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>js 作为主要运行在浏览器的脚本语言，主要用途之一是操作 DOM。如果同时有两个线程对同一个 dom 进行操作，这时浏览器应该听哪个线程的，如何判断优先级？JS 是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，Event Loop 方案应运而生。</p><div class="post-button"><a class="btn" href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/Javascript%20%E7%B2%BE%E7%B2%B9/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/Javascript%20%E7%B2%BE%E7%B2%B9/" class="post-title-link" itemprop="url">JavaScript 精粹</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-28 16:31:21" itemprop="dateModified" datetime="2022-02-28T16:31:21+08:00">2022-02-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>40k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>36 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h2 id="（一）底层原理"><a href="#（一）底层原理" class="headerlink" title="（一）底层原理"></a>（一）底层原理</h2><h3 id="1-原型和原型链"><a href="#1-原型和原型链" class="headerlink" title="1. 原型和原型链"></a>1. 原型和原型链</h3><p><strong>prototype</strong></p><p>如下所示，我们用构造函数 <code>Person()</code> new了一个实例对象 person。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">&#x27;Kevin&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>每个 JS 对象（null 除外）在创建时会与一个叫做原型的对象关联，每个对象都会从原型继承属性。prototype 是函数独有的属性，它指向该构造函数所创建的实例对象的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Person的prototype指向person1和person2的原型</span></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Kevin&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>用<code>Person.prototype</code>表示实例原型，则构造函数和实例原型的关系如下：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233852.png" alt="image-20210515091954495" style="zoom:67%"><p><strong><code>__proto__</code></strong></p><p>每个 JS 对象（null 除外）都有一个叫做 <code>__proto__</code> 的属性，这个属性会指向该对象的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>于是关系图更新如下：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233853.png" alt="image-20210515095146933" style="zoom:67%"><p><strong>constructor</strong></p><p>每个实例原型都有一个 constructor 属性指向关联的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>关系图更新如下：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233854.png" alt="image-20210515095646355" style="zoom:67%"><p>综上我们已经得出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>原型的原型</strong></p><p>当读取实例的属性时，如果实例没有该属性，那么就会去查找实例原型中的属性，如果还查不到，就去找实例原型的原型，一直找到最顶层为止。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Kevin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">&#x27;Daisy&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Daisy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>在上例中，给实例对象 person 添加了 name 属性，当打印 person.name 时，结果自然为 Daisy。但是当删除了 person 的 name 属性时，再次读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 <code>person.__proto__</code> ，即<code>Person.prototype</code>中查找，结果为 Kevin。但如果还没有找到，则会去查找原型的原型。</p><p>因为实例原型本身就是一个对象，既然是对象，就可以用最原始的方式创建它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">&#x27;Kevin&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>原型对象就是通过 Object 构造函数生成的，根据实例的 <code>__proto__</code> 指向构造函数的 prototype ，关系图更新如下：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233855.png" alt="image-20210515103525663" style="zoom:67%"><p><strong>原型链</strong></p><p><code>Object.prototype</code> 的原型则指向null：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>null 表示没有对象，即该处不应有值。 <code>Object.prototype.__proto__</code> 的值为 null，也就说明 <code>Object.prototype</code> 没有原型。最终的关系图更新如下，图中的蓝线即为原型链。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233856.png" alt="image-20210515104256297" style="zoom:67%"><p><strong>补充</strong></p><p>① 当获取 <code>person.constructor</code> 时，其实 person 中并没有 constructor 属性。当不能读取到 constructor 属性时，会从 person 的原型也就是 <code>Person.prototype</code> 中读取到该属性，所以 <code>person.constructor === Person.prototype.constructor</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>② 绝大多数浏览器都支持用 <code>__proto__</code> 访问原型，但这个属性其实来自于 <code>Object.prototype</code>。与其说它是一个属性，不如说是一个 getter/setter，当使用 <code>obj.__proto__</code> 时，可以理解成返回了 <code>Object.getPrototypeOf(obj)</code>。</p><p>③ 前面讲到每个对象都会从原型继承属性，实际上继承是个具有迷惑性的说法。继承意味着复制操作，然而 JS 默认并不会复制对象的属性，相反 JS 只是在两个对象间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。</p><p>④ Objects created using <code>Object.create()</code></p><p>空对象也有原型，但 <code>Object.create(null)</code> 创造的对象没有。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> literalObject = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> nullObject  = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">nullObject.name = <span class="string">&#x27;My object&#x27;</span>;</span><br><span class="line"></span><br><span class="line">literalObject <span class="keyword">instanceof</span> <span class="built_in">Object</span>;   </span><br><span class="line"><span class="comment">// true, every object literal has Object.prototype as prototype</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span>;   </span><br><span class="line"><span class="comment">// true, same case as above</span></span><br><span class="line">nullObject <span class="keyword">instanceof</span> <span class="built_in">Object</span>;   </span><br><span class="line"><span class="comment">// false, prototype is end of prototype chain (null)</span></span><br></pre></td></tr></table></figure><h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h3><p>作用域是指一个变量和函数的作用范围，它分为词法作用域和动态作用域。JS 采用词法作用域（lexical scoping，也称静态作用域）。</p><ul><li>静态作用域：函数的作用域在函数定义时就确定。</li><li>动态作用域：函数的作用域在函数调用时才确定。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><p>JS 采用静态作用域，所以上例 foo 函数在执行时，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据定义的位置查找上一层的代码 <code>var value = 1;</code>，所以结果打印 1。</p><p>假设 JS 采用动态作用域，则执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用该函数的作用域，即 bar 函数内查找 value 变量，所以结果打印 2。</p><p>注：有时候会想通过在外部引入的自定义 js 方法里面来修改当前页面的一些属性值，然而由于 js 采用静态作用域，外部函数方法中的 this 并不能获取到当前页面的属性。所以不能这么做。</p><p><strong>题目</strong>：两个函数的打印结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>两段代码都会打印：<code>local scope</code>，因为 JS 采用词法作用域，函数的作用域基于其创建的位置。</p><h3 id="3-执行上下文"><a href="#3-执行上下文" class="headerlink" title="3. 执行上下文"></a>3. 执行上下文</h3><h4 id="①-执行上下文栈"><a href="#①-执行上下文栈" class="headerlink" title="① 执行上下文栈"></a>① 执行上下文栈</h4><p>JS 的可执行代码（executable code）分为三种：全局代码、函数代码、eval 代码。<strong>每当执行一个函数，就会创建一个执行上下文（execution contexts）。每个执行上下文包含三个重要属性：变量对象（Variable object，VO）、作用域链（Scope chain）、this。</strong>为了方便管理这些执行上下文，JS 引擎创建了执行上下文栈（execution context stack，ECStask）。</p><p>在此假设执行上下文栈是一个数组，以便模拟其行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [];</span><br></pre></td></tr></table></figure><p>JS 解释执行代码时最先遇到全局代码，所以初始化时先向 ECStack 压入全局执行上下文 <code>globalContext</code>。只有当整个程序结束时 <code>ECStack</code> 才会被清空，即 <code>ECStack</code> 栈底只能放 <code>globalContext</code>。当执行一个函数时，就会创建一个EC，并将其压入ECStack。当函数执行完毕时，就将其从栈中弹出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>当 JS 遇到如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fun3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure><p>其执行上下文栈经历的过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行fun1()，将其EC入栈</span></span><br><span class="line">ECStack.push(&lt;fun1&gt; functionContext);</span><br><span class="line"><span class="comment">// fun1中调用了fun2，将fun2的EC入栈</span></span><br><span class="line">ECStack.push(&lt;fun2&gt; functionContext);</span><br><span class="line"><span class="comment">// 同理，将func3的EC入栈</span></span><br><span class="line">ECStack.push(&lt;fun3&gt; functionContext);</span><br><span class="line"><span class="comment">// fun3执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"><span class="comment">// fun2执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"><span class="comment">// fun1执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"><span class="comment">// js接着执行接下来的代码，但ECStack栈底永远有个globalContext</span></span><br></pre></td></tr></table></figure><p><strong>题目</strong>：两个函数在处理执行上下文的区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ECStack.push(&lt;checkscope&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.push(&lt;f&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ECStack.push(&lt;checkscope&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br><span class="line"><span class="comment">// ECStack.push(&lt;f&gt; functionContext);</span></span><br><span class="line"><span class="comment">// ECStack.pop();</span></span><br></pre></td></tr></table></figure><h4 id="②-变量对象"><a href="#②-变量对象" class="headerlink" title="② 变量对象"></a>② 变量对象</h4><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。全局上下文和函数上下文的变量对象稍有不同，这里分开讨论。</p><p><strong>全局上下文</strong></p><p>由 <code>var</code> 声明的全局变量会作为全局对象的成员被脚本创建。<strong>全局对象就是全局上下文中的变量对象</strong>，即作用域链的头。在 web 浏览器中，<code>window</code> 对象就是浏览器的全局对象，任何全局变量或全局函数都能作为 <code>window</code> 的属性来访问。</p><p>Ⅰ. 全局对象可以通过 this 引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); </span><br><span class="line"><span class="comment">// Window &#123;0: Window, window: Window, self: Window, document: document, name: &#x27;&#x27;, location: Location, …&#125;</span></span><br></pre></td></tr></table></figure><p>Ⅱ. 全局对象是 Object 构造函数的一个实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Ⅲ. 全局对象预定义了许多函数和属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.Math.random());</span><br></pre></td></tr></table></figure><p>Ⅳ. 全局对象作为全局变量的宿主。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br></pre></td></tr></table></figure><p>Ⅴ. 浏览器的全局对象有 window 属性指向自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line"><span class="built_in">this</span>.window.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br></pre></td></tr></table></figure><p><strong>函数上下文</strong></p><p>在函数上下文中，用活动对象（activation object, AO）来表示变量对象。两者本质相同，区别在于变量对象是规范上或引擎实现上的，不能在 JS 环境中访问。当进入一个 EC 时，EC 的变量对象会被激活为 AO，这时其上的各种属性（如形参、变量声明）才能被访问。</p><p>函数上下文的变量对象在初始化时只包含 Arguments 对象。在进入 EC 时，会给变量对象添加形参、函数声明、变量声明等初始的属性值。在代码执行阶段，会依照执行顺序再次修改变量对象的属性值。</p><p>**Ⅰ. 进入 EC **</p><p>当刚进入 EC ，还未执行代码时，变量对象的属性包括：</p><p>① 函数形参（如果是函数上下文）：由名称和对应值组成。如果没有实参，对应值设为 undefined</p><p>② 函数声明：由名称和对应值（函数对象，function-object）组成。如果变量对象已存在同名的属性，则将其完全替换</p><p>③ 变量声明：由名称和对应值（undefined）组成。变量声明不会干扰到已声明的同名形参或函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，上例的 AO 是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Ⅱ. 代码执行</strong></p><p>在代码执行阶段会顺序执行代码，根据代码修改变量对象的值。当代码执行完后，上例的 AO 变为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression <span class="string">&#x27;d&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目一</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fin(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">bts(); <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>foo()</code>：报错是因为函数中的 <code>a</code> 没有通过 var 关键字声明，也就没有产生变量提升，因而没有被存放在 AO 中。当执行到 console ， 此时 AO 的值如下。没有 a 的值，然后就到全局去找，全局也没有，所以报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        length: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fin()</code>：函数中的 a 通过变量提升，相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fin</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> a; </span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">    a=<span class="number">1</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><code>bar()</code>：当执行到 console 时，bar 函数的活动对象已经添加了 a 属性，所以打印 1。</p><p><strong>题目二</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 打印：[Function: foo]</span></span><br></pre></td></tr></table></figure><p>在进入 EC 时，首先处理函数声明，其次处理变量声明。如果变量跟函数重名，则变量声明不会干扰函数声明，相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> foo; <span class="comment">//这里只是声明，并不会影响foo的值 </span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//输出foo函数 </span></span><br><span class="line">foo = <span class="number">1</span>; </span><br></pre></td></tr></table></figure><p><strong>题目三</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="comment">// 打印：1</span></span><br></pre></td></tr></table></figure><p>先函数提升，再变量提升，相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> foo; <span class="comment">//这里只是声明，并不会影响foo的值 </span></span><br><span class="line">foo = <span class="number">1</span>; </span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h4 id="③-作用域链"><a href="#③-作用域链" class="headerlink" title="③ 作用域链"></a>③ 作用域链</h4><p>当查找变量时，会先从当前 EC 的变量对象中查找，如果没有找到，就会从父级 EC 的变量对象中查找，一直找到全局上下文的变量对象（即全局对象）。这样由多个 EC 的<strong>变量对象</strong>构成的链表就叫作用域链。</p><p>下面以函数的创建和激活两个阶段来说明作用域链是如何创建和变化的。</p><p><strong>函数创建阶段</strong></p><p>JS 采用静态作用域，函数的作用域在函数定义时便已确定。这是因为当函数被创建时，函数有一个内部属性 <code>[[scope]]</code> 会保存所有父级 EC 的变量对象。注意，它不是完整的作用域链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数创建时，各自的 <code>[[scope]]</code> 为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>函数激活阶段</strong></p><p>当进入函数上下文后，会将新创建的 AO 添加到作用域链的头部。即该 EC 最终完整的作用域链为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><hr><p><strong>题目</strong>：分析 <code>checkscope()</code> 的执行过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope2 = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>Ⅰ. <code>checkscope</code> 函数被创建，在其 <code>[[scope]]</code> 属性中添加父级 EC 的变量对象；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>Ⅱ. 创建 <code>checkscope</code> 函数的 EC，并将其压入 ECStack；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>Ⅲ. 执行函数前，复制函数的 <code>[[scope]]</code> 属性到 EC 中，创建作用域链；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>活动对象由 arguments 初始化，随后加入形参、函数声明、变量声明；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: checkscope.[[scope]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将该 EC 的 AO 压入 <code>checkscope</code> 作用域链头部；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ⅳ. 开始执行函数，修改 AO 的属性值；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: <span class="string">&#x27;local scope&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ⅴ. 返回 scope2 的值后函数执行完毕，将该 EC 从 ECStack 中弹出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h4 id="④-this-指向"><a href="#④-this-指向" class="headerlink" title="④ this 指向"></a>④ this 指向</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar());</span><br></pre></td></tr></table></figure><p>简述：<code>foo.bar()</code>的复杂表达式为 foo.bar，不涉及计算，所以属于 reference。其 basevalue 为 foo，属于对象，则 this 指向该对象。</p><h5 id="Ⅰ-Reference"><a href="#Ⅰ-Reference" class="headerlink" title="Ⅰ. Reference"></a>Ⅰ. Reference</h5><p>ECMAScript 规范定义的类型分为语言类型和规范类型。</p><ul><li>语言类型是开发者能使用 ECMAScript 语言直接操作其值的，分为 Undefined、Null、Boolean、String、Number 和 Object。</li><li>规范类型可以使用算法来描述 ECMAScript 语言结构和语言类型。规范类型包括：Reference、List、Completion、Property Descriptor、Property Identifier、Lexical Environment 和 Environment Record。</li></ul><p>由上可知，ECMAScript 规范中定义了一种不存在实际 js 代码中的类型，它的作用是为了更好地描述语言底层行为逻辑。而其中的 Reference 类型便与 this 的指向密切相关，它用来解释诸如 delete、<code>typeof</code> 和赋值等操作行为。</p><p>Reference 由如下三个部分构成：</p><ul><li>base value：属性所在的对象，该值的类型只能是 Undefined、Object、Boolean、String、Number 或 <code>EnvironmentRecord</code>。</li><li>reference name：属性名。</li><li>strict reference</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的Reference</span></span><br><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    strict: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar(); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bar对应的Reference</span></span><br><span class="line"><span class="keyword">var</span> BarReference = &#123;</span><br><span class="line">    base: foo,</span><br><span class="line">    propertyName: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">    strict: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>GetValue()</code></strong></p><p>该方法返回 Reference 对象真正的值，而非 Reference 自身。当<u>函数调用表达式</u>中包含位运算符（如&amp;）、逻辑运算符（如&amp;&amp;）、条件运算符（a?b:c)、赋值运算符（如=）、等值运算符（如==）、比较运算符（如&lt;）、移位运算符（如&lt;&lt;）、逗号运算符、加减乘除运算符，也就是涉及计算时，都会使用到该方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    strict: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line">GetValue(fooReference) <span class="comment">// 1;</span></span><br></pre></td></tr></table></figure><p>创建 Reference 有两种途径：<strong>标识符解析</strong>和<strong>属性访问</strong>。比如 foo 和 foo.bar 能创建 Reference ，而字面量和函数表达式以及包含上述运算符的表达式却不会。具体可参考下图：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233857.png" alt="image-20210516093949501" style="zoom:67%"><h5 id="Ⅱ-复杂表达式"><a href="#Ⅱ-复杂表达式" class="headerlink" title="Ⅱ. 复杂表达式"></a>Ⅱ. 复杂表达式</h5><p>原始表达式（PrimaryExpression）是表达式的最小单位，它不再包含其他表达式。原始表达式分为字面量、关键字和变量，具体包括 this 关键字、标识符引用、字面量引用、数组初始化、对象初始化和分组表达式。</p><p>而<strong>复杂表达式</strong>（MemberExpression）由原始表达式和操作符组成，包括属性访问表达式、对象创建表达式和函数表达式。</p><ul><li><code>FunctionExpression</code> 函数定义</li><li><code>MemberExpression[Expression]</code> 属性访问</li><li><code>MemberExpression.IdentifierName</code> 属性访问</li><li><code>new MemberExpression(Arguments)</code> 对象创建</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// MemberExpression 是 foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo()(); <span class="comment">// MemberExpression 是 foo()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.bar(); <span class="comment">// MemberExpression 是 foo.bar</span></span><br></pre></td></tr></table></figure><p>可以认为 MemberExpression 是函数调用时<code>()</code>左边的部分。</p><h5 id="Ⅲ-判定方法"><a href="#Ⅲ-判定方法" class="headerlink" title="Ⅲ. 判定方法"></a>Ⅲ. 判定方法</h5><p>ECMAScript 规范说明了当函数被调用时，如何确定 this 的取值。将 ref 作为 MemberExpression 的计算结果，则有：</p><ul><li><p>如果 ref 是 Reference 类型，并且 base value 值是一个对象，那么 this 值为 base value；</p></li><li><p>如果 ref 是 Reference 类型，并且 base value 值是 <code>EnvironmentRecord</code>，那么 this 值为 undefined；</p></li><li><p>如果 ref 不是 Reference 类型，那么 this 值为 undefined。</p><hr><p><strong>题目</strong></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar());</span><br><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar)());</span><br><span class="line"><span class="comment">//例3</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar = foo.bar)());</span><br><span class="line"><span class="comment">//例4</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">false</span> || foo.bar)());</span><br><span class="line"><span class="comment">//例5</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar, foo.bar)());</span><br><span class="line"><span class="comment">//例6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">fin();</span><br></pre></td></tr></table></figure><p><strong>例1：<code>foo.bar()</code></strong></p><p>ME 计算结果为 foo.bar，属于 Reference 类型，值为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BarReference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  name: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  strict: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>base value 为 foo，是一个对象，所以 this 指向 <code>foo &#123; value: 2, bar: [Function: bar] &#125;</code>。打印2。</p><p><strong>例2：<code>(foo.bar)()</code></strong></p><p><code>()</code>并没有对 ME 进行计算，所以结果跟例1一样。</p><p><strong>例3：<code>(foo.bar = foo.bar)()</code></strong></p><p>存在赋值运算符，即运算过程中会使用<code>GetValue()</code>，所以返回值不是 Reference 类型，则 this 指向 undefined，undefined 自然不存在 value 属性，则打印 undefined。非严格模式下，当this 值为 undefined 时，其值会被隐式转换为全局对象，打印1。</p><p><strong>例4：<code>(false || foo.bar)()</code></strong></p><p>存在逻辑运算符，即运算过程中会使用<code>GetValue()</code>，所以返回值不是 Reference 类型，则 this 指向 undefined，打印 undefined。非严格模式下打印1。</p><p><strong>例5：<code>(foo.bar, foo.bar)()</code></strong></p><p>存在逗号运算符，即运算过程中会使用<code>GetValue()</code>，所以返回值不是 Reference 类型，则 this 指向 undefined，打印 undefined。非严格模式下打印1。</p><p><strong>例6：<code>fin()</code></strong></p><p>ME 计算结果为 fin，属于 Reference 类型，值为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    strict: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>base value 为 <code>EnvironmentRecord</code>，所以 this 指向 undefined，打印 undefined。非严格模式打印1。</p><p><strong>例7：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    doSth: doSth</span><br><span class="line">&#125;</span><br><span class="line">ming.doSth()</span><br></pre></td></tr></table></figure><p><strong>例8：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">let</span> fn = create();</span><br><span class="line">fn(); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系。</span></span><br></pre></td></tr></table></figure><blockquote><p>var、let 和 const 的区别：</p><ul><li>var 定义的变量，<code>没有块的概念，可以跨块访问</code>, 不能跨函数访问。let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。</li><li>var可以<code>先使用，后声明</code>，因为存在变量提升；let必须先声明后使用。</li><li>var是允许在相同作用域内<code>重复声明同一个变量</code>的，而let与const不允许这一现象。</li><li>在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系。var声明的变量会和GO有映射关系；</li><li>会产生暂时性死区；</li><li>let /const/function 会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于let的块作用特征即可解决。</li></ul></blockquote><h3 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h3><p>MDN 将闭包定义为能够访问自由变量的函数。而自由变量是指在函数中使用的，但不是函数参数或函数局部变量的变量。即闭包 = 函数 + 函数能够访问的自由变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上例中，foo 函数可以访问变量 a，但 a 既非 foo 函数的局部变量，也不是函数参数，所以 a 是自由变量，foo 函数和其访问的 a 便构成了闭包。理论上所有的 JS 函数都是闭包，因为它们都在创建时保存了父级 EC 的变量对象。而从实际开发角度看，以下函数才算闭包：</p><ul><li>即使创建闭包的上下文已经销毁，它仍然存在（比如内部函数从父函数中返回）</li><li>在代码中引用了自由变量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = checkscope();</span><br><span class="line">foo(); <span class="comment">// &#x27;local scope&#x27;</span></span><br></pre></td></tr></table></figure><p>上例中 EC 的简要变化过程如下：</p><ol><li>进入全局代码，创建全局执行上下文，并将其压入 ECStack；</li><li>全局执行上下文初始化；</li><li>执行 <code>checkscope()</code>，创建该函数的 EC，并将其压入 ECStack；</li><li>checkscope 的 EC 初始化，创建变量对象、作用域链、this 等；</li><li>checkscope 函数执行完毕，将其 EC 从 ECStack 中弹出；</li><li>执行 <code>f()</code>，创建 f 函数的 EC，并将其压入 ECStack；</li><li>f 的 EC 初始化，创建变量对象、作用域链、this 等；</li><li>f 函数执行完毕，将其 EC 从 ECStack 中弹出。</li></ol><p>当执行 f 函数时，checkscope 的 EC 已被销毁（从 ECStack 中弹出），但仍能读取到 checkscope 作用域下的 scope 属性。这是因为 f 函数的 EC 保存了作用域链：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使 checkscopeContext 被销毁，但 JS 仍会把 f 函数引用的 checkscopeContext.AO 保留在内存中，f 函数也就能通过其作用域链找到 checkscopeContext.AO 的值。闭包正因此机制才得以实现。</p><p><strong>题目</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数前，全局上下文的 VO 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext &#x3D; &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数时，data[0] 函数的作用域链为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context &#x3D; &#123;</span><br><span class="line">    Scope: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 没有 i 值，所以从 globalContext.VO 中查找到 i ，打印 3。data[1] 和 data[2] 同理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包版本</span></span><br><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    data[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数前，全局上下文的 VO 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext &#x3D; &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数时，data[0] 函数的作用域链发生改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context &#x3D; &#123;</span><br><span class="line">    Scope: [AO, 匿名函数Context.AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数的 EC 的 AO 添加了函数参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匿名函数Context &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            0: 0,</span><br><span class="line">            length: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        i: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 没有 i 值，于是沿着作用域链从匿名函数 Context.AO 中查找到 i ，打印 0。data[1] 和 data[2] 同理，分别打印 1 和 2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 JavaScript 中下面选项关于 this 描述正确的是（A）</span><br><span class="line">A. 在使用new实例化对象时, this指向这个实例对象</span><br><span class="line">B. 将对象的方法赋值给变量A。执行A()时 该方法中的this指向这个对象。 </span><br><span class="line">C. 在函数定义时,this指向全局变量</span><br><span class="line">D. 在浏览器下的全局范围内，this指向全局对象</span><br></pre></td></tr></table></figure><h3 id="5-参数按值传递"><a href="#5-参数按值传递" class="headerlink" title="5. 参数按值传递"></a>5. 参数按值传递</h3><p>ECMAScript 中所有函数的参数都是<strong>按值传递</strong>：函数的形参是被调用时所传实参的副本，修改形参的值并不会影响实参。下例中，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 _value，则函数中修改的都是 _value 的值，不会影响到 value 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    v = <span class="number">2</span>;zd</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(value);</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但当值是一个复杂的数据结构时，拷贝会产生性能问题。所以还有一种传递方式叫<strong>按引用传递</strong>：传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o.value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(o.value); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>前面说 ECMAScript 中所有函数的参数都是按值传递，而上例看起来却像是按引用传递。其实这是<strong>按共享传递</strong>：当传递的是对象时，传递对象的引用的副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(o); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>所以修改 o.value 时，可以通过引用找到原值。但直接修改 o，不会影响到原值。<strong>参数如果是基本类型则按值传递，如果是引用类型则按共享传递。</strong>但因为拷贝副本本身也是一种值拷贝，所以也可认为是按值传递。</p><h3 id="6-类数组对象与-arguments"><a href="#6-类数组对象与-arguments" class="headerlink" title="6. 类数组对象与 arguments"></a>6. 类数组对象与 arguments</h3><p>类数组对象包含 length 属性和若干索引属性。在客户端 JS 中，一些 DOM 方法（如<code>document.getElementsByTagName()</code>）返回的就是类数组对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组对象</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>];</span><br><span class="line"><span class="comment">// 类数组对象</span></span><br><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;age&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;sex&#x27;</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从读写、获取长度、遍历三方面来看，数组与类数组并无二致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]); <span class="comment">// name</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayLike[<span class="number">0</span>]); <span class="comment">// name</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">&#x27;new name&#x27;</span>;</span><br><span class="line">arrayLike[<span class="number">0</span>] = <span class="string">&#x27;new name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度</span></span><br><span class="line"><span class="built_in">console</span>.log(array.length); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayLike.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arrayLike.length; i &lt; len; i++) &#123; &#125;</span><br></pre></td></tr></table></figure><p>但类数组对象不能使用数组的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayLike.push(<span class="string">&#x27;4&#x27;</span>); <span class="comment">//error: arrayLike.push is not a function</span></span><br></pre></td></tr></table></figure><p>可以使用 <code>Array.prototype.func.call()</code> 让类数组间接调用数组方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;<span class="number">0</span>: <span class="string">&#x27;name&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;age&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;sex&#x27;</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(arrayLike, <span class="string">&#x27;&amp;&#x27;</span>); <span class="comment">// name&amp;age&amp;sex</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.map.call(arrayLike, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item.toUpperCase();</span><br><span class="line">&#125;); <span class="comment">// [&#x27;NAME&#x27;, &#x27;AGE&#x27;, &#x27;SEX&#x27;]</span></span><br></pre></td></tr></table></figure><p>数组的一些方法还能让类数组转成数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;<span class="number">0</span>: <span class="string">&#x27;name&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;age&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;sex&#x27;</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike); </span><br><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike)</span><br><span class="line"><span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;sex&#x27;] </span></span><br></pre></td></tr></table></figure><p>其实 Arguments 对象也是一种类数组对象。它只定义在函数体中，包括了函数的参数和其他属性。在函数体中，<code>arguments</code> 指代该函数的 Arguments 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上例打印结果如下：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210804233858.png" alt="image-20210519225713752" style="zoom:50%"><p><strong>length属性</strong></p><p>Arguments 对象的 length 属性，表示实参的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b, c, d</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;实参的长度为：&#x27;</span> + <span class="built_in">arguments</span>.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;形参的长度为：&#x27;</span> + foo.length)</span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参的长度为：3</span></span><br><span class="line"><span class="comment">// 实参的长度为：1</span></span><br></pre></td></tr></table></figure><p><strong>callee属性</strong></p><p>Arguments 对象的 callee 属性，通过它可以调用函数自身。讲个闭包经典面试题使用 callee 的解决方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.i) </span><br><span class="line">    &#125;).i = i;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>arguments 和对应参数的绑定</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name, age, sex, hobbit</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name, <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// name name</span></span><br><span class="line">    <span class="comment">// 改变形参</span></span><br><span class="line">    name = <span class="string">&#x27;new name&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name, <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// new name new name</span></span><br><span class="line">    <span class="comment">// 改变arguments</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="string">&#x27;new age&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(age, <span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">// new age new age</span></span><br><span class="line">    <span class="comment">// 测试未传入的是否会绑定</span></span><br><span class="line">    <span class="built_in">console</span>.log(sex); <span class="comment">// undefined</span></span><br><span class="line">    sex = <span class="string">&#x27;new sex&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(sex, <span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// new sex undefined</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">3</span>] = <span class="string">&#x27;new hobbit&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(hobbit, <span class="built_in">arguments</span>[<span class="number">3</span>]); <span class="comment">// undefined new hobbit</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在非严格模式下，传入的实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享。在严格模式下，实参和 arguments 不会共享。</p><p><strong>传递参数</strong></p><p>将参数从一个函数传递到另一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 apply 将 foo 的参数传递给 bar</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>使用 ES6 的 … 运算符，可以轻松将其转成数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="7-创建对象的方式"><a href="#7-创建对象的方式" class="headerlink" title="7. 创建对象的方式"></a>7. 创建对象的方式</h3><h4 id="①-工厂模式"><a href="#①-工厂模式" class="headerlink" title="① 工厂模式"></a>① 工厂模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">&#x27;kevin&#x27;</span>);</span><br></pre></td></tr></table></figure><p>工厂模式通过 <code>new Object()</code> 来创建一个对象实例，并为其添加属性和方法。但工厂模式无法确定对象的类型，因为实例直接由 Object() 构造函数创建，原型链上只有 Object.prototype 对象。另外，每创建一个对象实例，都要为每个对象实例创建一遍完全相同的函数方法（理论上每次创建对象的属性均不同，而对象的方法是相同的），这是没有必要的。</p><h4 id="②-构造函数模式"><a href="#②-构造函数模式" class="headerlink" title="② 构造函数模式"></a>② 构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;kevin&#x27;</span>);</span><br></pre></td></tr></table></figure><p>构造函数模式可以识别实例对象的类型，但缺点仍在于每次创建实例时，每个方法都要重新被创建一次。可以通过将函数移到构造函数外来解决，但同时封装性就很糟糕。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.getName = getName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;kevin&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="③-原型模式"><a href="#③-原型模式" class="headerlink" title="③ 原型模式"></a>③ 原型模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123; &#125;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;keivn&#x27;</span>;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>原型模式把属性和方法定义在构造函数的原型，而非构造函数内。这样所有对象实例就能共享对象原型上的属性和方法，从而避免重复创建。但缺点在于修改原型上的引用属性会导致所有实例对应的属性都被改变。另外，还不能初始化参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123; &#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">&#x27;kevin&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>优化后提升了封装性，但重写原型导致丢失了 constructor 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对constructor属性再次优化。但并没有解决原型模式带来的缺点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123; &#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">    <span class="title">name</span>: &#x27;<span class="title">kevin</span>&#x27;,</span><br><span class="line">    <span class="title">getName</span>: <span class="title">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><h4 id="④-组合模式"><a href="#④-组合模式" class="headerlink" title="④ 组合模式"></a>④ 组合模式</h4><p>在构造函数内定义私有属性和方法，在构造函数原型上定义共有的属性和方法。目前最广泛使用的方式之一。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">    <span class="title">getName</span>: <span class="title">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p><strong>动态原型模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span>.getName != <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>使用动态原型模式时，不能用对象字面量重写原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span>.getName != <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        Person.prototype = &#123;</span><br><span class="line">            <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">            <span class="title">getName</span>: <span class="title">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;kevin&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line"><span class="comment">// 报错 并没有该方法</span></span><br><span class="line">person1.getName();</span><br><span class="line"><span class="comment">// 注释掉上面的代码，这句是可以执行的。</span></span><br><span class="line">person2.getName();</span><br></pre></td></tr></table></figure><p>为了解释这个问题，假设开始执行 <code>var person1 = new Person(&#39;kevin&#39;)</code>。回顾下 new 的实现步骤：</p><ol><li>首先新建一个对象</li><li>然后将对象的原型指向 Person.prototype</li><li>然后 <code>Person.apply(obj)</code></li><li>返回这个对象</li></ol><p>在 apply 时会执行 <code>obj.Person()</code>，这时就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 <code>getName()</code> 的，所以报错。</p><p>如果你就是想用字面量方式写代码，可以尝试下这种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span>.getName != <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        Person.prototype = &#123;</span><br><span class="line">            <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">            <span class="title">getName</span>: <span class="title">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;kevin&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line">person1.getName(); <span class="comment">// kevin</span></span><br><span class="line">person2.getName();  <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure><h4 id="⑤-class-定义类"><a href="#⑤-class-定义类" class="headerlink" title="⑤ class 定义类"></a>⑤ class 定义类</h4><p><code>class</code>从 ES6 开始正式被引入到 JS 中，它是组合模式的语法糖，让定义类更加简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>class</code>包含了构造函数<code>constructor</code>和定义在原型对象上的函数<code>hello()</code>，避免了<code>Student.prototype.hello = function () &#123;...&#125;</code>这样分散的代码。</p><h4 id="⑥-寄生构造函数模式"><a href="#⑥-寄生构造函数模式" class="headerlink" title="⑥ 寄生构造函数模式"></a>⑥ 寄生构造函数模式</h4><p>寄生构造函数模式跟工厂模式的唯一区别在于，在创建对象时使用了new。实际上两者结果是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;kevin&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>它只是寄生在构造函数的一种方法，创建的实例使用 instanceof 都无法指向其构造函数。这样方法可以在特殊情况下使用。比如当要创建一个具有额外方法的特殊数组，但又不想直接修改Array构造函数时，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        values.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.join(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> colors2 = SpecialArray(<span class="string">&#x27;red2&#x27;</span>, <span class="string">&#x27;blue2&#x27;</span>, <span class="string">&#x27;green2&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString()); <span class="comment">// red|blue|green</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2);</span><br><span class="line"><span class="built_in">console</span>.log(colors2.toPipedString()); <span class="comment">// red2|blue2|green2</span></span><br></pre></td></tr></table></figure><p>虽然本意是希望像使用普通 Array 类型一样使用 SpecialArray，但把 SpecialArray 当成函数也一样能用，即使这不优雅。在可以使用其他模式的情况下，不要使用这种模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    values.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中的循环可以替换成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.push.apply(values, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><h4 id="⑦-稳妥构造函数模式"><a href="#⑦-稳妥构造函数模式" class="headerlink" title="⑦ 稳妥构造函数模式"></a>⑦ 稳妥构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = person(<span class="string">&#x27;kevin&#x27;</span>);</span><br><span class="line">person1.sayName(); <span class="comment">// kevin</span></span><br><span class="line">person1.name = <span class="string">&#x27;daisy&#x27;</span>;</span><br><span class="line">person1.sayName(); <span class="comment">// kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。与寄生构造函数模式有两点不同：</p><ul><li>新创建的实例方法不引用 this</li><li>不使用 new 操作符调用构造函数</li></ul><p>稳妥对象最适合在一些安全的环境中。稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。</p><h3 id="8-继承"><a href="#8-继承" class="headerlink" title="8. 继承"></a>8. 继承</h3><h4 id="①-原型链继承"><a href="#①-原型链继承" class="headerlink" title="① 原型链继承"></a>① 原型链继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;kevin&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// kevin</span></span><br></pre></td></tr></table></figure><p>原型链继承的缺点在于，引用类型的属性会被所有实例共享。另外在创建 Child 的实例时，不能向Parent传参。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.names = [<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;daisy&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.names.push(<span class="string">&#x27;yayu&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// [&#x27;kevin&#x27;, &#x27;daisy&#x27;, &#x27;yayu&#x27;]</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// [&#x27;kevin&#x27;, &#x27;daisy&#x27;, &#x27;yayu&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="②-借用构造函数"><a href="#②-借用构造函数" class="headerlink" title="② 借用构造函数"></a>② 借用构造函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.names = [<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;daisy&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.names.push(<span class="string">&#x27;yayu&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// [&#x27;kevin&#x27;, &#x27;daisy&#x27;, &#x27;yayu&#x27;]</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// [&#x27;kevin&#x27;, &#x27;daisy&#x27;]</span></span><br></pre></td></tr></table></figure><p>借用构造函数（经典继承）既避免了引用类型的属性被所有实例共享，也可以在 Child 中向 Parent 传参。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;kevin&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure><p>缺点在于方法都在构造函数中定义，每次创建实例都会创建一遍方法。</p><h4 id="③-组合继承"><a href="#③-组合继承" class="headerlink" title="③ 组合继承"></a>③ 组合继承</h4><p>融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line">child1.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors); <span class="comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;]</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">&#x27;daisy&#x27;</span>, <span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors); <span class="comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]。</span></span><br></pre></td></tr></table></figure><h4 id="④-class-继承"><a href="#④-class-继承" class="headerlink" title="④ class 继承"></a>④ class 继承</h4><p>组合继承的缺点在于需要编写大量代码。用 <code>class</code> 定义对象让继承的实现更加方便。不必再考虑原型继承的中间对象和原型对象的构造函数，直接通过 <code>extends</code> 来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, grade</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 记得用super调用父类的构造方法!</span></span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">myGrade</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;I am at grade &#x27;</span> + <span class="built_in">this</span>.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>extends</code>表示原型链对象来自<code>Student</code>。子类的构造函数可能会与父类不同，如<code>PrimaryStudent</code>需要<code>name</code>和<code>grade</code>两个参数，它必须通过<code>super(name)</code>来调用父类的构造函数，否则父类的<code>name</code>属性无法正常初始化。<code>PrimaryStudent</code>已经自动获得了父类<code>Student</code>的<code>hello()</code>，我们又在子类中定义了新的<code>myGrade()</code>。</p><p>ES6引入的<code>class</code>和原有的 JS 原型继承没有任何区别，只是简化了原型链代码。</p><h4 id="⑤-原型式继承"><a href="#⑤-原型式继承" class="headerlink" title="⑤ 原型式继承"></a>⑤ 原型式继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。缺点在于包含引用类型的属性值始终都会共享相应的值，跟原型链继承一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;kevin&#x27;</span>,</span><br><span class="line">    friends: [<span class="string">&#x27;daisy&#x27;</span>, <span class="string">&#x27;kelly&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">&#x27;person1&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">&#x27;taylor&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// [&#x27;daisy&#x27;, &#x27;kelly&#x27;, &#x27;taylor&#x27;]</span></span><br></pre></td></tr></table></figure><p>注意：修改 <code>person1.name</code> 的值，<code>person2.name</code> 的值并未发生改变，并不是因为 <code>person1</code> 和 <code>person2</code> 有独立的 name 值，而是因为 <code>person1.name = &#39;person1&#39;</code>，给 <code>person1</code> 添加了 name 值，并非修改了原型上的 name 值。</p><h4 id="⑥-寄生式继承"><a href="#⑥-寄生式继承" class="headerlink" title="⑥ 寄生式继承"></a>⑥ 寄生式继承</h4><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object.create(o);</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><h4 id="⑦-寄生组合式继承"><a href="#⑦-寄生组合式继承" class="headerlink" title="⑦ 寄生组合式继承"></a>⑦ 寄生组合式继承</h4><p>在这里重复一下组合继承的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure><p>组合继承最大的缺点是会调用两次父构造函数。</p><p>一次是设置子类型实例的原型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>一次是创建子类型实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在创建子类型实例时，会执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.call(<span class="built_in">this</span>, name);</span><br></pre></td></tr></table></figure><p>即又调用了一次 Parent 构造函数。如果打印 child1 对象，会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p><p>如果不使用 <code>Child.prototype = new Parent()</code> ，而是间接地让 Child.prototype 访问到 Parent.prototype，那就可以避免这一次重复调用。实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure><p>最后我们封装一下这个继承方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(parent.prototype);</span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure><p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的属性。与此同时，原型链还能保持不变；因此能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p><h2 id="（二）模拟实现"><a href="#（二）模拟实现" class="headerlink" title="（二）模拟实现"></a>（二）模拟实现</h2><h3 id="1-call-amp-apply-amp-bind"><a href="#1-call-amp-apply-amp-bind" class="headerlink" title="1. call &amp; apply &amp; bind"></a>1. call &amp; apply &amp; bind</h3><h4 id="①-call"><a href="#①-call" class="headerlink" title="① call()"></a>① <code>call()</code></h4><p>Ⅰ. <strong><code>call()</code> 在指定 this 值的前提下调用某个函数或方法。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value); <span class="comment">// this本应指向undefined或全局对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>实现思路</strong></p><p>上例中，当调用 <code>call()</code> 时，如果将 foo 对象改造如下，这样 bar 函数内的 this 就指向了 foo 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但这给 foo 对象本身添加了一个属性，所以在函数执行完后须将其删除。第一版的 <code>call2()</code> 如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this指向调用call的函数bar，作为foo的属性fn</span></span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    context.fn();</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.call2(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>Ⅱ. <code>call()</code> 还能传递额外参数到调用函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(foo, <span class="string">&#x27;kevin&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// kevin</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>实现思路</strong></p><p>由于参数不定长，所以函数除了 context 外不能加入其它形参，但可以从 Arguments 对象中取出第二个到最后一个参数，然后放到一个数组里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上例的arguments为：</span></span><br><span class="line"><span class="built_in">arguments</span> = &#123;</span><br><span class="line">    <span class="number">0</span>: foo,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;kevin&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">18</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着要把参数传入到函数形参中，但 args 是一个数组，需要将其转换成连续的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments是类数组对象，可以采用for循环</span></span><br><span class="line"><span class="keyword">var</span> args = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">context.fn(...args);</span><br></pre></td></tr></table></figure><p>但数组的扩展运算符属于 ES6 的方法，而 call 属于 ES5，所以下面改用 eval 写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行后args为 [&#x27;arguments[1]&#x27;, &#x27;arguments[2]&#x27;]</span></span><br><span class="line"><span class="comment">// 这里采用eval方法进行拼接。args会自动调用Array.toString()</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">&#x27;arguments[1]&#x27;</span>, <span class="string">&#x27;arguments[2]&#x27;</span>].toString()); <span class="comment">// &#x27;arguments[1],arguments[2]&#x27;</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args +<span class="string">&#x27;)&#x27;</span>); <span class="comment">// context.fn(arguments[1],arguments[2])</span></span><br></pre></td></tr></table></figure><p>之所以使用 <code>args.push(&#39;arguments[&#39; + i + &#39;]&#39;)</code>，而非 <code>args.push(arguments[i])</code>，原因在于后者在这里所产生的 args 为 [‘kevin’, 18]，转成字符串为 ‘kevin, 18’。eval 解析执行时会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[foo, <span class="string">&#x27;kevin&#x27;</span>, <span class="number">18</span>].toString(); <span class="comment">// &#x27;[object Object],kevin,18&#x27;</span></span><br><span class="line">context.fn(kevin, <span class="number">18</span>); <span class="comment">// Uncaught ReferenceError: kevin is not defined</span></span><br></pre></td></tr></table></figure><p>第二版解决了传参问题，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args +<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.call2(foo, <span class="string">&#x27;kevin&#x27;</span>, <span class="number">18</span>); </span><br><span class="line"><span class="comment">// kevin</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>Ⅲ. <strong>如果 this 参数为 null，则默认指向 window。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.call(<span class="literal">null</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>另外， 函数可能还有返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        value: <span class="built_in">this</span>.value,</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(bar.call(obj, <span class="string">&#x27;kevin&#x27;</span>, <span class="number">18</span>));</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//    value: 1,</span></span><br><span class="line"><span class="comment">//    name: &#x27;kevin&#x27;,</span></span><br><span class="line"><span class="comment">//    age: 18</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>最终版代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">Object</span>(context) || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args +<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        value: <span class="built_in">this</span>.value,</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bar.call(<span class="literal">null</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.call2(obj, <span class="string">&#x27;kevin&#x27;</span>, <span class="number">18</span>));</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//    value: 1,</span></span><br><span class="line"><span class="comment">//    name: &#x27;kevin&#x27;,</span></span><br><span class="line"><span class="comment">//    age: 18</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h4 id="②-apply"><a href="#②-apply" class="headerlink" title="② apply()"></a>② <code>apply()</code></h4><p>apply 的实现跟 call 类似。注意 apply 的第二个参数必须是数组或类数组，它们会被转换成类数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">Object</span>(context) || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="string">&#x27;arr[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③-bind"><a href="#③-bind" class="headerlink" title="③ bind()"></a>③ <code>bind()</code></h4><p><code>bind()</code> 会返回一个新函数。当这个新函数被调用时，<code>bind()</code> 的第一个参数将作为它运行时的 this，其后的若干参数将会优先传递的实参传入。</p><p>Ⅰ. <code>bind()</code> 会返回一个新函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回了一个函数</span></span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo); </span><br><span class="line">bindFoo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>可以使用 call 或 apply 指定 this 指向，第一版的实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ⅱ. <code>bind()</code> 可以传入新函数的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line">bindFoo(<span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// daisy</span></span><br><span class="line"><span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>bar 函数有 name 和 age 两个参数，上例 <code>bind()</code> 传入了 name，在执行新函数时再传 age。可以用 arguments 进行处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind2函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        self.apply(context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ⅲ. <code>bind()</code> 返回的函数可以作为构造函数，原来指定的 this 值会失效，但其它传入的参数依然生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.habit = <span class="string">&#x27;shopping&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">bar.prototype.friend = <span class="string">&#x27;kevin&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> bindFoo(<span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// daisy</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.habit);</span><br><span class="line"><span class="built_in">console</span>.log(obj.friend);</span><br><span class="line"><span class="comment">// shopping</span></span><br><span class="line"><span class="comment">// kevin</span></span><br></pre></td></tr></table></figure><p>尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefined，根据 new 的实现原理，这时的 this 其实指向了 obj。可以通过修改返回函数的原型来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承函数的原型中的值</span></span><br><span class="line">    fbound.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    <span class="keyword">return</span> fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    // 当作为构造函数时，this 指向实例，self 指向绑定函数，因为下面一句 `fbound.prototype = this.prototype;`，已经修改了 fbound.prototype 为 绑定函数的 prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。
    // 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context。
</code></pre><p>但 <code>fbound.prototype = this.prototype</code> 会使我们在修改 fbound.prototype 时，也会影响到绑定函数的 prototype。因此我们可以通过一个空函数来进行中转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第四版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">    fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    fbound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ⅳ. MDN 中文版模拟实现 bind 时，在 apply 这里加了一个关于 context 是否存在的判断，然而这是错误的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context || <span class="built_in">this</span>, args.concat(bindArgs))</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    bar: bar.bind(<span class="literal">null</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1。</p><p>如果调用 bind 的不是函数，则需要抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Function.prototype.bind - what is trying to be bound is not callable&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Function.prototype.bind - what is trying to be bound is not callable&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    fbound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-new"><a href="#2-new" class="headerlink" title="2. new"></a>2. new</h3><p>new 用于创建一个自定义对象类型的实例。如下所示，实例 person 能访问到 <u>Otaku 构造函数和 Otaku.prototype</u> 中的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Otaku 御宅族，简称宅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.habit = <span class="string">&#x27;Games&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为缺乏锻炼的缘故，身体强度让人担忧</span></span><br><span class="line">Otaku.prototype.strength = <span class="number">60</span>;</span><br><span class="line">Otaku.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Otaku(<span class="string">&#x27;Kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength) <span class="comment">// 60</span></span><br><span class="line">person.sayYourName(); <span class="comment">// I am Kevin</span></span><br></pre></td></tr></table></figure><p>由于 new 是关键字，无法像 <code>bind()</code> 直接覆盖，所以用如下名为 objectFactory 的函数来模拟 new 的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 new</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Otaku(……);</span><br><span class="line"><span class="comment">// 使用 objectFactory</span></span><br><span class="line"><span class="keyword">var</span> person = objectFactory(Otaku, ……)</span><br></pre></td></tr></table></figure><p>因为 new 会<strong>返回一个新对象</strong>，所以在模拟实现时也要创建一个新对象 obj。可以使用 <code>Otaku.apply(obj, arguments)</code> 让 obj 继承并设置 Otaku 构造函数中的属性。另外，让实例的 <code>__proto__</code> 属性指向构造函数的 prototype，从而实现访问原型的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 取出第一个参数，即传入的构造函数。因为shift会修改原数组，所以arguments会被去除第一个参数</span></span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="comment">// 使构造函数的this指向obj，这样obj就能访问到构造函数中的属性</span></span><br><span class="line">    Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.habit = <span class="string">&#x27;Games&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Otaku.prototype.strength = <span class="number">60</span>;</span><br><span class="line">Otaku.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = objectFactory(Otaku, <span class="string">&#x27;Kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength) <span class="comment">// 60</span></span><br><span class="line">person.sayYourName(); <span class="comment">// I am Kevin</span></span><br></pre></td></tr></table></figure><p>构造函数可能存在返回值。下例中构造函数返回了一个对象，在实例 person 中只能访问返回对象中的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.strength = <span class="number">60</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        habit: <span class="string">&#x27;Games&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Otaku(<span class="string">&#x27;Kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>而下例构造函数返回的是一个基本类型的值，结果虽然有返回值，但却是按没有返回值进行处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.strength = <span class="number">60</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;handsome boy&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Otaku(<span class="string">&#x27;Kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength) <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>所以还需要判断返回值是否为一个对象。如果是，则返回的是该对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){const e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">mohui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">484k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">7:20</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>