<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"baimohui.github.io",root:"/",images:"/images",scheme:"Muse",version:"8.2.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12},copycode:!1,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"}}</script><meta property="og:type" content="website"><meta property="og:title" content="白抹灰"><meta property="og:url" content="https://baimohui.github.io/page/2/index.html"><meta property="og:site_name" content="白抹灰"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="mohui"><meta property="article:tag" content="前端,JavaScript,html5,css3,Vue"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://baimohui.github.io/page/2/"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>白抹灰</title><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">白抹灰</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">mohui</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">35</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">42</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9/" class="post-title-link" itemprop="url">移动端兼容</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:47:40" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/" itemprop="url" rel="index"><span itemprop="name">兼容适配</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>19k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>17 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h2 id="（一）响应式界面"><a href="#（一）响应式界面" class="headerlink" title="（一）响应式界面"></a>（一）响应式界面</h2><h3 id="1-什么是响应式设计"><a href="#1-什么是响应式设计" class="headerlink" title="1. 什么是响应式设计"></a>1. 什么是响应式设计</h3><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20976405">响应式布局</a></p><p>响应式界面能够适应不同的设备。描述响应式界面最著名的一句话就是“Content is like water”，翻译成中文便是“如果将屏幕看作容器，那么内容就像水一样”。</p><h3 id="2-响应式界面的四个层次"><a href="#2-响应式界面的四个层次" class="headerlink" title="2. 响应式界面的四个层次"></a>2. 响应式界面的四个层次</h3><ul><li>同一页面在不同大小和比例上看起来都应该是舒适的；</li><li>同一页面在不同分辨率上看起来都应该是合理;</li><li>同一页面在不同操作方式（如鼠标和触屏）下，体验应该是统一的；</li><li>同一页面在不同类型的设备（手机、平板、电脑）上，交互方式应该是符合习惯的。</li></ul><h3 id="3-响应式界面的基本规则"><a href="#3-响应式界面的基本规则" class="headerlink" title="3. 响应式界面的基本规则"></a>3. 响应式界面的基本规则</h3><p>① <strong>可伸缩的内容区块</strong>：内容区块在一定程度上能够自动调整，以确保填满整个页面</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174657.png" alt="image-20210327123558579" style="zoom:50%"><p>② <strong>适应页面尺寸的边距</strong>：到页面尺寸发生更大变化时，区块的边距也应该变化</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174658.png" alt="image-20210327123935190" style="zoom:50%"><p>③ <strong>能够适应比例变化的图片</strong>：对于常见的宽度调整，图片在隐去两侧部分时，依旧保持美观可用</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174659.png" alt="image-20210327124052768" style="zoom:50%"><p>④ <strong>能够自动隐藏/部分显示的内容</strong>：如在电脑上显示的的大段描述文本，在手机上就只能少量显示或全部隐藏</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174700.png" alt="image-20210327124148764" style="zoom:50%"><p>⑤ <strong>能自动折叠的导航和菜单</strong>：展开还是收起，应该根据页面尺寸来判断</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174701.png" alt="image-20210327124310687" style="zoom:50%"><p>⑥ 放弃使用像素作为尺寸单位：用dp(对于前端来说，这里可能是rem)尺寸等方法来确保页面在分辨率相差很大的设备上，看起来也能保持一致。同时也要求提供的图片应该比预想的更大，才能适应高分辨率的屏幕</p><p>简单总结起来，可以概括为：</p><ul><li>媒体查询，边界断点的规则设定（Media queries &amp;&amp; break point）</li><li>内容的可伸缩性效果（Flexible visuals）</li><li>流式网格布局(Fluid grids)</li><li>主要内容呈现及图片的高质量(Main content and high quality)</li></ul><h3 id="4-响应式与自适应"><a href="#4-响应式与自适应" class="headerlink" title="4. 响应式与自适应"></a>4. 响应式与自适应</h3><p>响应式设计是 Responsive Web Design（RWD），自适应设计是 Adaptive Web Design（AWD）。RWD 和 AWD 两者都是为了适配各种不同的移动设备，致力于提升用户体验所产生的的技术。核心思想是用技术来使网页适应从小到大（现在到超大）的不同分辨率的屏幕。<strong>通常认为，RWD 是 AWD 的子集</strong>。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174702.png" alt="image-20210327124723911" style="zoom:50%"><p>从定义上而言，RWD 是一套代码，适用于所有屏幕。而 AWD 则是多端多套代码。两者的本质都是致力于适配不同设备，更好地提升用户体验。</p><h2 id="（二）分辨率"><a href="#（二）分辨率" class="headerlink" title="（二）分辨率"></a>（二）分辨率</h2><h3 id="1-物理像素"><a href="#1-物理像素" class="headerlink" title="1. 物理像素"></a>1. 物理像素</h3><p>在电商网站购买手机时我们都会查看手机的参数，以 京东上的 iPhone7 为例：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174703.png" alt="image-20210327135258715" style="zoom:67%"><p>可以看到，iPhone7 的分辨率是 <code>1334 x 750</code>，这里描述的就是屏幕实际的物理像素。</p><p>物理像素，又称为设备像素。显示屏是由一个个物理像素点组成的，<code>1334 x 750</code> 表示手机分别在垂直和水平上所具有的像素点数。通过控制每个像素点的颜色，就可以使屏幕显示出不同的图像，屏幕从出厂起，其物理像素点就固定不变了，单位为pt。屏幕分辨率就是指一个屏幕具体由多少个物理像素点组成。</p><h3 id="2-设备独立像素"><a href="#2-设备独立像素" class="headerlink" title="2. 设备独立像素"></a>2. 设备独立像素</h3><p>以 iPhone6/7/8为例，这里我们打开 Chrome 开发者工具：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174704.png" alt="image-20210327135542887" style="zoom:80%"><p>这里的375*667表示的就是设备独立像素DIP（Device Independent Pixels）。</p><p>当我们设定一个宽度为 375px 的 div，刚好可以充满这个设备的一行，配合高度 667px ，则 div 的大小<strong>刚好</strong>可以充满整个屏幕。</p><h3 id="3-CSS像素"><a href="#3-CSS像素" class="headerlink" title="3. CSS像素"></a>3. CSS像素</h3><p>在写CSS时用到最多的单位是<code>px</code>，即CSS像素，当页面缩放比例为100%时，一个CSS像素等于一个设备独立像素。但是<code>CSS像素</code>是很容易被改变的，当用户对浏览器进行了放大，CSS像素会被放大，这时一个CSS像素会跨越更多的物理像素。</p><p><code>页面的缩放系数 = CSS像素 / 设备独立像素</code>。</p><h3 id="4-DPR"><a href="#4-DPR" class="headerlink" title="4. DPR"></a>4. DPR</h3><p>DPR（Device Pixel Ratio） 设备像素比，这个与我们通常说的视网膜屏（多倍屏，Retina屏）有关。设备像素比描述的是<strong>未缩放状态下</strong>，物理像素和设备独立像素的初始比例关系。</p><p><strong>DPR = 物理像素宽度 / 设备独立像素宽度</strong></p><p>套用上面 iPhone7 的数据：iPhone7’s DPR = iPhone7’s 物理像素宽度 / iPhone7’s 设备独立像素宽度 = 2</p><p>我们通常说的H5手机适配也就是指的这两个维度：</p><ul><li>适配不同屏幕大小，也就是适配不同屏幕下的 CSS 像素</li><li>适配不同像素密度，也就是适配不同屏幕下 dpr 不一致导致的一些问题</li></ul><h3 id="5-PPI"><a href="#5-PPI" class="headerlink" title="5. PPI"></a>5. PPI</h3><p><code>PPI(Pixel Per Inch)</code>：每英寸包括的物理像素数。<code>PPI</code>可以用于描述屏幕的清晰度以及一张图片的质量。使用<code>PPI</code>描述图片时，<code>PPI</code>越高，图片质量越高，使用<code>PPI</code>描述屏幕时，<code>PPI</code>越高，屏幕越清晰。</p><h3 id="6-DPI"><a href="#6-DPI" class="headerlink" title="6. DPI"></a>6. DPI</h3><p><code>DPI(Dot Per Inch)</code>：即每英寸包括的点数。这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点或者打印机的墨点。平时可能会看到使用<code>DPI</code>来描述图片和屏幕，这时的<code>DPI</code>应该和<code>PPI</code>是等价的，<code>DPI</code>最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。</p><p>一张图片在屏幕上显示时，它的像素点数是规则排列的，每个像素点都有特定的位置和颜色。当使用打印机进行打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是<code>DPI</code>所描述的：打印点的密度。打印机的<code>DPI</code>越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174705.png" alt="image-20210327143056556" style="zoom:50%"><h2 id="（三）适配屏幕方案"><a href="#（三）适配屏幕方案" class="headerlink" title="（三）适配屏幕方案"></a>（三）适配屏幕方案</h2><p>适配不同屏幕大小其实只需要遵循一条原则，确保页面元素大小的与屏幕大小保持一定比例。也就是：<strong>按比例还原设计稿</strong></p><h3 id="1-rem适配方案（old-fashioned）"><a href="#1-rem适配方案（old-fashioned）" class="headerlink" title="1. rem适配方案（old-fashioned）"></a>1. rem适配方案（old-fashioned）</h3><p>rem（font size of the root element），在 <a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-values-3/#lengths">CSS Values and Units Module Level 3</a>中的定义就是， 根据网页的根元素来设置字体大小，和 em（font size of the element）的区别是，em 是根据其父元素的字体大小来设置，而 rem 是根据网页的根元素（html）来设置字体大小。</p><h4 id="flexible"><a href="#flexible" class="headerlink" title="flexible"></a>flexible</h4><p>基于此，淘宝早年推行的一套以 rem 为基准的适配方案：<a target="_blank" rel="noopener" href="https://github.com/amfe/lib-flexible">lib-flexible</a>。其核心做法在于：</p><ul><li><del>根据设备的 dpr 动态改写 `` 标签，设置 viewport 的缩放</del></li><li><del>给 `` 元素添加 data-dpr 属性，并且动态改写 data-dpr 的值</del></li><li>根据 <code>document.documentElement.clientWidth</code> 动态修改 <code>&lt;html&gt;</code> 的 font-size ，页面其他元素使用 rem 作为长度单位进行布局，从而实现页面的等比缩放</li></ul><p>关于头两点，其实现在的 <code>lib-flexible</code> 库已经不这样做了，不再去缩放 Viewport，字体大小的设定也直接使用了 rem</p><h4 id="hotcss"><a href="#hotcss" class="headerlink" title="hotcss"></a>hotcss</h4><p><a target="_blank" rel="noopener" href="https://github.com/imochen/hotcss">hotcss</a> 不是一个库，也不是一个框架。它是一个移动端布局开发解决方案。使用 hotcss 可以让移动端布局开发更容易。本质的思想与 flexible 完全一致。</p><h4 id="对于-rem-方案的一些总结"><a href="#对于-rem-方案的一些总结" class="headerlink" title="对于 rem 方案的一些总结"></a>对于 rem 方案的一些总结</h4><p>使用 flexible/hotcss 作为屏幕宽度适配解决方案，是存在一些问题的：</p><ul><li>动态修改 Viewport 存在一定的风险的，譬如通过 Viewport 改变了页面的缩放之后，获取到的 <code>innerWidth/innerHeight</code> 也会随之发生变化，如果业务逻辑有获取此类高宽进行其他计算的，可能会导致意想不到的错误；到今天，其实存在很多在 flexible 基础上演化而来的各种 rem 解决方案，有的不会对 Viewport 进行缩放处理，自行处理 1px 边框问题。</li><li>flexible/hotcss 都并非纯 CSS 方案，需要引入一定的 Javascript 代码</li><li>rem 的设计初衷并非是用于解决此类问题，用 rem 进行页面的宽度适配多少有一种 hack 的感觉</li><li>存在一定的兼容性问题，对于安卓 4.4 以下版本系统不支持 viewport 缩放（当然，flexible 处理 Android 系列时，始终认为其 dpr 为 1，没有进行 viewport 缩放）</li></ul><h3 id="2-vw适配方案"><a href="#2-vw适配方案" class="headerlink" title="2. vw适配方案"></a>2. vw适配方案</h3><p>严格来说，使用 rem 进行页面适配其实是一种 hack 手段，rem 单位的初衷本身并不是用来进行移动端页面宽度适配的。到了今天，有了一种更好的替代方案，使用 vw 进行适配 。百分比适配方案的核心需要一个全局通用的基准单位，rem 是不错，但是需要借助 Javascript 进行动态修改根元素的 <code>font-size</code>，而 vw/vh的出现则很好弥补 rem 需要 JS 辅助的缺点。</p><p>根据 CSS Values and Units Module Level 4：<code>vw</code>等于初始包含块（html元素）宽度的1%，也就是</p><ul><li><code>1vw</code> 等于 <code>window.innerWidth</code> 的数值的 1%</li><li><code>1vh</code> 等于 <code>window.innerHeight</code> 的数值的 1%</li><li><code>vmin</code> : <code>vw</code> 和 <code>vh</code> 中的较小值</li><li><code>vmax</code> : <code>vw</code> 和 <code>vh</code> 中的较大值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174706.png" alt="image-20210327144751871"></p><blockquote><ul><li><p><code>window.innerHeight</code>：获取浏览器视觉视口高度（包括垂直滚动条）。</p></li><li><p><code>window.outerHeight</code>：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。</p></li><li><p><code>window.screen.Height</code>：获取获屏幕取理想视口高度，这个数值是固定的，设备的分辨率/设备像素比</p></li><li><p><code>window.screen.availHeight</code>：浏览器窗口可用的高度。</p></li><li><p><code>document.documentElement.clientHeight</code>：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。</p></li><li><p><code>document.documentElement.offsetHeight</code>：包括内边距、滚动条、边框和外边距。</p></li><li><p><code>document.documentElement.scrollHeight</code>：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与<code>clientHeight</code>相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。</p></li></ul></blockquote><p>根据相关的测试，可以使用 vw 进行长度单位的有：</p><ul><li>容器大小适配，可以使用 vw</li><li>文本大小的适配，可以使用 vw</li><li>大于 1px 的边框、圆角、阴影都可以使用 vw</li><li>内距和外距，可以使用 vw</li></ul><p><a target="_blank" rel="noopener" href="https://codepen.io/Chokcoco/pen/oNvWVYq?editors=1100">vw页面适配代码演示</a></p><img src="https://user-images.githubusercontent.com/8554143/64007393-a7ad3e80-cb03-11e9-988a-90a7a38990f6.gif" alt="vw" style="zoom:67%"><p>vw 看上去不错，但存在一些问题：</p><ol><li>没能很好解决 1px 边框在高清屏下的显示问题，需要自行处理；</li><li>由于 vw 方案是完全的等比缩放，在完全等比还原设计稿的同时无法很好限定一个最大最小宽度值，由于 rem 方案是借助 Javascript 的，所以这一点 rem 比 vw 会更加的灵活；</li><li><code>px</code>转换成<code>vw</code>不一定能完全整除，因此有一定的像素差；</li><li>比如当容器使用<code>vw</code>，<code>margin</code>采用<code>px</code>时，很容易造成整体宽度超过<code>100vw</code>，从而影响布局效果。当然我们也是可以避免的，例如使用<code>padding</code>代替<code>margin</code>，结合<code>calc()</code>函数使用等等。</li></ol><p>当然，两个方案现阶段其实都可以使用甚至一起搭配使用，更多详情可以读读：</p><ul><li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5a9d07ee6fb9a028c149f55b">再聊移动端页面的适配</a></li><li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NgGd9zSm6NEaF5Jxp5WBKg">H5必知必会之像素级还原设计稿</a></li><li><a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2016/05/fluid-typography/">Responsive And Fluid Typography With vh And vw Units</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wengxuesong/archive/2016/05/16/5497653.html">使用VH和VW实现真正的流体排版</a></li></ul><h2 id="（四）图片适配及优化"><a href="#（四）图片适配及优化" class="headerlink" title="（四）图片适配及优化"></a>（四）图片适配及优化</h2><p>图像通常占据了网页下载资源的绝大部分。优化图像通常可以最大限度地减少从网站下载的字节数以及提高网站性能。一些通用的优化手段如下：</p><ul><li>消除多余的图像资源</li><li><strong>尽可能利用 CSS3\SVG 矢量图像替代某些光栅图像</strong></li><li>谨慎使用字体图标，使用网页字体取代在图像中进行文本编码</li><li>选择正确的图片格式</li><li><strong>为不同 DPR 屏幕提供最适合的图片尺寸</strong></li></ul><p>首先就是上述的第二点，我们平时使用的图片大多数都属于位图（<code>png、jpg...</code>），位图由一个个像素点构成的，每个像素都具有特定的位置和颜色值。理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果。而在<code>dpr &gt; 1</code>的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确分配上对应位图像素的颜色，只能取近似值，所以相同的图片在<code>dpr &gt; 1</code>的屏幕上就会模糊。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174707.png" alt="image-20210328120230196" style="zoom:67%"><p>尽可能利用 CSS3\SVG 矢量图像替代某些光栅图像。某些简单的几何图标，可以用 CSS3 快速实现的图形，都应该尽量避免使用光栅图像。这样能够保证它们在任何尺寸下都不会失真。其次，实在到了必须使用光栅图像的地步，也是有许多方式能保证图像在各种场景下都不失真。</p><h3 id="1-在不同dpr屏幕下使图片不失真"><a href="#1-在不同dpr屏幕下使图片不失真" class="headerlink" title="1. 在不同dpr屏幕下使图片不失真"></a>1. 在不同dpr屏幕下使图片不失真</h3><h4 id="①-无脑多倍图（不可取）"><a href="#①-无脑多倍图（不可取）" class="headerlink" title="① 无脑多倍图（不可取）"></a>① 无脑多倍图（不可取）</h4><p>在移动端假设我们需要一张 CSS 像素为 300 x 200的图像，考虑到现在已经有了 dpr = 3 的设备，那么要保证图片在 dpr = 3 的设备下也正常高清展示，我们最大可能需要一张 900 x 600的原图。这样，不管设备的 dpr 是否为 3，我们统一都使用 3 倍图。这样即使在 dpr = 1，dpr = 2 的设备上，也能非常好的展示图片。当然这样并不可取，会造成大量带宽的浪费。现代浏览器，提供了更好的方式，让我们能够根据设备 dpr 的不同，提供不同尺寸的图片。</p><h4 id="②-srcset-配合像素密度描述符"><a href="#②-srcset-配合像素密度描述符" class="headerlink" title="② srcset 配合像素密度描述符"></a>② srcset 配合像素密度描述符</h4><p>srcset 可以根据不同的 dpr 拉取对应尺寸的图片：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;illustration&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;illustration-small.png&#x27;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">srcset</span>=<span class="string">&#x27;images/illustration-small.png 1x,</span></span></span><br><span class="line"><span class="tag"><span class="string">               images/illustration-big.png 2x&#x27;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">style</span>=<span class="string">&#x27;max-width: 500px&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面 <code>srcset</code> 里的 1x，2x 表示 <strong>像素密度描述符</strong>，表示</p><ul><li>当屏幕的 dpr = 1 时，使用 <code>images/illustration-small.png</code> 这张图</li><li>当屏幕的 dpr = 2 时，使用 <code>images/illustration-big.png</code> 这张图</li></ul><h4 id="③-srcset-配合w宽度描述符"><a href="#③-srcset-配合w宽度描述符" class="headerlink" title="③ srcset 配合w宽度描述符"></a>③ srcset 配合w宽度描述符</h4><p>上面 1x，2x 的写法比较容易接受易于理解。除此之外，srcset属性还有一个 w 宽度描述符，配合 sizes 属性一起使用，可以覆盖更多的面。</p><p>以如下代码为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">sizes</span> = <span class="string">“(min-width:</span> <span class="attr">600px</span>) <span class="attr">600px</span>, <span class="attr">300px</span>&quot; </span></span><br><span class="line"><span class="tag">    <span class="attr">src</span> = <span class="string">&quot;photo.png&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">srcset</span> = <span class="string">“photo@1x.png</span> <span class="attr">300w</span>,</span></span><br><span class="line"><span class="tag">               <span class="attr">photo</span>@<span class="attr">2x.png</span> <span class="attr">600w</span>,</span></span><br><span class="line"><span class="tag">               <span class="attr">photo</span>@<span class="attr">3x.png</span> <span class="attr">1200w</span>,&quot;</span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p><code>sizes = “(min-width: 600px) 600px, 300px&quot;</code></p><p>如果屏幕当前的 CSS 像素宽度大于或等于 600px，则图片的 CSS 宽度为 600px，否则图片的 CSS 宽度为 300px。sizes 属性声明了在不同宽度下图片的 CSS 宽度表现。大屏幕下图片宽度为 600px，小屏幕下图片宽度为 300px。注意，这里的 sizes 属性只是声明了在不同屏幕宽度下图片的 CSS 宽度表现，而具体使图片在大于600px的屏幕上展示为600px宽度的代码需要另外由 CSS 或者 JS 实现。</p><p><code>srcset = “photo@1x.png 300w, photo@2x.png 600w, photo@3x.png 1200w</code></p><p>里面的 300w，600w，900w 叫宽度描述符。假设当前屏幕 dpr = 2 ，屏幕CSS 宽度为 375px，图片 CSS 宽度为 300px，则分别用上述 3 个宽度描述符的数值除以 300，得：</p><ul><li>300 / 300 = 1</li><li>600 / 300 = 2</li><li>1200 / 300 = 4</li></ul><p>上式计算得到的结果即算出的有效像素密度，换算成和 x 描述符等价的值 。这里 600w 算出的 2 满足 dpr = 2 的情况，选择此张图。此方案考虑到了响应性布局的复杂性与屏幕的多样性，利用上述规则，可以<strong>一次适配 PC 端大屏幕和移动端高清屏</strong>。</p><h4 id="④-media查询"><a href="#④-media查询" class="headerlink" title="④ media查询"></a>④ media查询</h4><p>使用<code>media</code>查询判断不同的设备像素比来显示不同精度的图片（只适用于背景图）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span>&#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">conardLi_1x.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="selector-class">.avatar</span>&#123;</span><br><span class="line">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">conardLi_2x.png</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="selector-class">.avatar</span>&#123;</span><br><span class="line">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">conardLi_3x.png</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑤-image-set"><a href="#⑤-image-set" class="headerlink" title="⑤ image-set"></a>⑤ image-set</h4><p>使用<code>image-set</code>（只适用于背景图）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">-webkit-image-set</span>( <span class="string">&quot;conardLi_1x.png&quot;</span> <span class="number">1</span>x, <span class="string">&quot;conardLi_2x.png&quot;</span> <span class="number">2</span>x );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑥-使用svg"><a href="#⑥-使用svg" class="headerlink" title="⑥ 使用svg"></a>⑥ 使用svg</h4><p><code>SVG</code>的全称是可缩放矢量图（<code>Scalable Vector Graphics</code>）。不同于位图的基于像素，<code>SVG</code> 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。</p><h2 id="（五）字体适配方案"><a href="#（五）字体适配方案" class="headerlink" title="（五）字体适配方案"></a>（五）字体适配方案</h2><p>浏览器有最小字体限制：</p><ul><li>PC上最小 font-size=12px</li><li>手机上最小 font-size=8px</li></ul><p>如果小于最小字体，那么字体默认就是最小字体。其次，很多早期的文章规范都建议不要使用奇数级单位来定义字体大小（如 13px，15px…），容易在一些低端设备上造成字体模糊，出现锯齿。</p><h3 id="字体的选择展示"><a href="#字体的选择展示" class="headerlink" title="字体的选择展示"></a>字体的选择展示</h3><p>在字体适配上面，我们需要从<strong>性能</strong>和<strong>展示效果</strong>两个维度去考虑。</p><p>完整的一个字体资源实在太大了，所以应尽可能使用用户设备上已有的字体，而不是额外下载字体资源，从而使加载时间明显加快。而从展示效果层面来说，使用系统字体能更好与当前操作系统使用的相匹配，得到最佳的展示效果。所以我们在字体使用方面，有一个应该尽量去遵循的原则，也是现在大部分网站在字体适配上使用的策略：<strong>使用各个支持平台上的默认系统字体</strong>。</p><h3 id="兼顾各个操作系统"><a href="#兼顾各个操作系统" class="headerlink" title="兼顾各个操作系统"></a>兼顾各个操作系统</h3><p>常见的操作系统有 Windows、Windows Phone、Mac OS X、iPhone、Android Phone、Linux。当然对于普通用户而言，无须关注 Linux 系统。</p><p>下面就以 <a target="_blank" rel="noopener" href="https://css-tricks.com/">CSS-Trick</a> 网站最新的 font-family 为例，看看他们是如何在字体选择上做到适配各个操作系统的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: </span><br><span class="line">    system-ui,-apple-system,BlinkMacSystemFont,segoe ui,Roboto,</span><br><span class="line">    Helvetica,Arial,</span><br><span class="line">    sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-family-关键字"><a href="#font-family-关键字" class="headerlink" title="font-family 关键字"></a>font-family 关键字</h3><p>对于 CSS 中的 <code>font-family</code> 而言，它有两类取值。</p><ol><li>一类是类似这样的具体的<strong>字体族名</strong>定义：<code>font-family: Arial</code> 这里定义了一个具体的字体样式，字体族名为 <code>Arial</code>;</li><li>一类是<strong>通用字体族名</strong>，它是一种备选机制，用于在指定的字体不可用时给出较好的字体，类似这样：<code>font-family: sans-serif</code> 。</li></ol><p>其中，<code>sans-serif</code> 表无衬线字体族，例如， “Open Sans”, “Arial” “微软雅黑” 等等。</p><p>关于<strong>通用字体族名</strong>，在 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/#generic-font-families">CSS Fonts Module Level 3 – Basic Font Properties</a> 中，定义了 5 个，也就是我们熟知的几个通用字体族名：</p><ol><li>serif 衬线字体族</li><li>sans-serif 非衬线字体族</li><li>monospace 等宽字体，即字体中每个字宽度相同</li><li>cursive 草书字体</li><li>fantasy 主要是那些具有特殊艺术效果的字体</li></ol><h3 id="新增通用字体族关键字"><a href="#新增通用字体族关键字" class="headerlink" title="新增通用字体族关键字"></a>新增通用字体族关键字</h3><p>而在 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/css-fonts-4/#generic-font-families">CSS Fonts Module Level 4 – Generic font families</a> 中，新增了几个关键字：</p><ul><li>system-ui 系统默认字体</li><li>emoji 用于兼容 emoji 表情符号字符</li><li>math 适用于数学表达式</li><li>fangsong 此字体系列用于中文的（仿宋）字体。</li></ul><p>我们看看用的最多的 <code>system-ui</code>。</p><h3 id="system-ui"><a href="#system-ui" class="headerlink" title="system-ui"></a>system-ui</h3><p>简单而言，<code>font-family: system-ui</code> 的目的就是在不同的操作系统的 Web 页面下，自动选择本操作系统下的默认系统字体。</p><p>默认使用特定操作系统的系统字体可以提高性能，因为浏览器或者 webview 不必去下载任何字体文件，而是使用已有的字体文件。 <code>font-family: system-ui</code> 字体设置的优势之处在于它与当前操作系统使用的字体相匹配，对于文本内容而言，它可以得到最恰当的展示。</p><h2 id="（六）前端布局的兼容适配"><a href="#（六）前端布局的兼容适配" class="headerlink" title="（六）前端布局的兼容适配"></a>（六）前端布局的兼容适配</h2><p>前端工程师的一大工作内容就是页面布局。无论在PC端还是移动端，页面布局的兼容适配都是重中之重。在整个前端发展的历程中，布局的方法也在不断的推陈出新。</p><h3 id="布局发展历程"><a href="#布局发展历程" class="headerlink" title="布局发展历程"></a>布局发展历程</h3><p>简单来说，前端的布局发展历程经历了下面几个过程：</p><p><strong>表格布局 –&gt; 定位布局 –&gt; 浮动布局 –&gt; flexbox布局 –&gt; grid box布局</strong></p><p>每一种布局在特定时期都发挥了重要的作用，而每一种新的布局方式的出现，往往都是因为现有的布局方式已经在该时期已经无法很好的满足开发者的需求，无法满足越来越潮流的页面布局的方式。</p><p>以 Flexbox 的出现为例子，在 Flexbox 被大家广为接受使用之前。我们一直在使用定位+浮动的布局方式。像下面这个布局：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174708.png" alt="image-20210327163627097" style="zoom:67%"><p>容器宽度不定，内部三个元素，均分排列且占满整个空间，并且垂直居中。如果使用定位+浮动的布局方式，你无法很快想到最佳的解决方式。三个元素并排那么必然需要浮动或者绝对定位，容器宽度不定且中间元素始终居中，需要顾虑的方面就很多了。也许使用 <code>text-align: justify</code> 可以 hack 实现，等等等等。</p><p>然而，使用 flexbox 布局的话，只需要：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flexbox 的出现，一次性解决了流动布局，弹性布局，排列方式等多个问题。并且它是简洁的，可控的。</p><p>再来看一个例子，水平垂直居中一个元素。使用 flexbox 也许是最便捷的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://codepen.io/Chokcoco/pen/GarPev">最便捷的垂直居中方式</a></p><h3 id="CSS-Grid-Layout"><a href="#CSS-Grid-Layout" class="headerlink" title="CSS Grid Layout"></a>CSS Grid Layout</h3><p>OK，flexbox 已经足够优秀了，为什么 gird 网格布局的出现又是为什么？它解决了什么 flex 布局无法很好解决的问题？</p><p>看看下面这张图：</p><p><a target="_blank" rel="noopener" href="https://user-images.githubusercontent.com/8554143/62539277-6bc9e500-b887-11e9-9f7b-78c51cde312c.png"><img src="https://user-images.githubusercontent.com/8554143/62539277-6bc9e500-b887-11e9-9f7b-78c51cde312c.png" alt="css grid layout" style="zoom:25%"></a></p><p>flexbox 是一维布局，他只能在一条直线上放置你的内容区块；而grid是一个二维布局。它除了可以灵活的控制水平方向之外，还能轻易的控制垂直方向的布局模式。对于上图那样的九宫格布局，它就可以轻而易举的完成。</p><p>一图以蔽之，flexbox：</p><p><a target="_blank" rel="noopener" href="https://user-images.githubusercontent.com/8554143/62591778-51cde800-b903-11e9-9037-9c5b25c9b894.png"><img src="https://user-images.githubusercontent.com/8554143/62591778-51cde800-b903-11e9-9037-9c5b25c9b894.png" alt="flexbox" style="zoom:25%"></a></p><p>grid box：</p><p><a target="_blank" rel="noopener" href="https://user-images.githubusercontent.com/8554143/62591784-5397ab80-b903-11e9-9c70-e7d4316a3da0.png"><img src="https://user-images.githubusercontent.com/8554143/62591784-5397ab80-b903-11e9-9c70-e7d4316a3da0.png" alt="gridbox" style="zoom:25%"></a></p><p>在现阶段，移动端布局应当更多使用 flexbox 去完成（相对那些还在使用 float 布局的），而考虑到未来页面布局的推陈出新。对于 Grid 布局我们应当像前几年对待 flexbox 一样，重视起来，随着兼容性的普及，Grid 布局也会慢慢成为主流。</p><h2 id="（七）视口"><a href="#（七）视口" class="headerlink" title="（七）视口"></a>（七）视口</h2><p>视口(<code>viewport</code>)代表当前可见的计算机图形区域。在<code>Web</code>浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的<code>UI</code>， 菜单栏等，即你正在浏览的文档的那一部分。一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。</p><h3 id="1-布局视口"><a href="#1-布局视口" class="headerlink" title="1. 布局视口"></a>1. 布局视口</h3><p>首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为viewport的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如768×1024，或者1080×1920这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？前面我们已经说了，css中的1px并不是代表屏幕上的1px，你分辨率越大，css中1px代表的物理像素就会越多，device Pixel Ratio的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视device Pixel Ratio的值而定），就是满屏的宽度了。回到正题上来，如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。这个浏览器默认的viewport叫做layout viewport(布局视口)。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174709.png" alt="image-20210327213112704" style="zoom:67%"><p>当我们以百分比来指定元素的大小时，它的值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。所以，布局视口是网页布局的基准窗口，在<code>PC</code>浏览器上，布局视口就等于当前浏览器的窗口大小（不包括<code>borders</code> 、<code>margins</code>、滚动条）。在移动端，布局视口被赋予一个默认值，大部分为<code>980px</code>，这保证<code>PC</code>的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。</p><p>我们可以通过调用<code>document.documentElement.clientWidth / clientHeight</code>来获取布局视口大小。</p><h3 id="2-视觉视口"><a href="#2-视觉视口" class="headerlink" title="2. 视觉视口"></a>2. 视觉视口</h3><p>然而，layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，这个viewport叫做 **visual viewport(视觉视口)**，即用户通过屏幕真实看到的区域，默认等于当前浏览器的窗口大小（包括滚动条宽度）。visual viewport的宽度指的是浏览器可视区域的宽度。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174710.png" alt="image-20210327213406398" style="zoom:67%"><p>用户正在看到的网页的区域。用户可以通过缩放来查看网站的内容。如果用户缩小网站，我们看到的网站区域将变大，此时视觉视口也变大了，同理，用户放大网站，我们能看到的网站区域将缩小，此时视觉视口也变小了。不管用户如何缩放，都不会影响到布局视口的宽度。</p><p>我们可以通过调用<code>window.innerWidth / innerHeight</code>来获取视觉视口大小。</p><h3 id="3-理想视口"><a href="#3-理想视口" class="headerlink" title="3. 理想视口"></a>3. 理想视口</h3><p>现在我们已经有两个viewport了：layout viewport 和 visual viewport。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的viewport。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。viewport叫做 <strong>ideal viewport(理想视口)**，移动设备的理想viewport，ideal viewport 可通过</strong>window. screen. width**获取。</p><p>ideal viewport 并没有一个固定的尺寸，不同的设备拥有有不同的 ideal viewport。所有的 iphone 的 ideal viewport 宽度都是 320px，无论它的屏幕宽度是 320 还是 640，也就是说，在 iphone 中，css 中的 320px 就代表 iphone 屏幕的宽度。</p><p>但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://viewportsizes.com/">http://viewportsizes.com</a> 去查看一下，里面收集了众多设备的理想宽度。</p><p>移动设备上的viewport分为layout viewport 、 visual viewport 和 ideal viewport 三类，其中的 ideal viewport 是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美地呈现给用户。</p><blockquote><p><strong>1、</strong>在桌面浏览器上，浏览器窗口与视口的宽度一致，而视口（CSS标准文档中称为“初始包含块”）是CSS百分比宽度推算的根源，因此，浏览器窗口是约束CSS布局的视口；<br><strong>2、</strong>在手机上，有两个视口，布局视口会限制CSS布局；视觉视口决定用户看到的网站内容；<br><strong>3、</strong>移动端浏览器还有个理想视口，它是对特定设备上的特定浏览器的布局视口的一个理想尺寸；<br><strong>4、</strong>可以把布局视口尺寸定义为理想视口。这也是响应式设计的基础。</p></blockquote><h3 id="4-Meta-Viewport"><a href="#4-Meta-Viewport" class="headerlink" title="4. Meta Viewport"></a>4. Meta Viewport</h3><p>meta用来表示不能由其它HTML元相关元素之一表示的任何元数据信息，它可以高速浏览器如何解析页面。我们可以借助</p><meta>元素的viewport来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。<p></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面是<code>viewport</code>的一个配置，我们来看看它们的具体含义：</p><table><thead><tr><th><code>Value</code></th><th>可能值</th><th>描述</th></tr></thead><tbody><tr><td><code>width</code></td><td>正整数或<code>device-width</code></td><td>以<code>pixels</code>（像素）为单位， 定义布局视口的宽度。</td></tr><tr><td><code>height</code></td><td>正整数或<code>device-height</code></td><td>以<code>pixels</code>（像素）为单位， 定义布局视口的高度。</td></tr><tr><td><code>initial-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义页面初始缩放比率。</td></tr><tr><td><code>minimum-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义缩放的最小值；必须小于或等于<code>maximum-scale</code>的值。</td></tr><tr><td><code>maximum-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义缩放的最大值；必须大于或等于<code>minimum-scale</code>的值。</td></tr><tr><td><code>user-scalable</code></td><td>一个布尔值（<code>yes</code>或者<code>no</code>）</td><td>如果设置为 <code>no</code>，用户将不能放大或缩小网页。默认值为 yes。</td></tr></tbody></table><p>首先，如果不设置meta viewport标签，那么移动设备上浏览器默认的宽度值为800px，980px，1024px等这些，总之是大于屏幕宽度的。这里的宽度所用的单位px都是指CSS像素，而不是物理像素。</p><p>第二、每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度。我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用。所以，我们可以使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来得到一个理想的viewport（也就是前面说的ideal viewport）。</p><p>为什么需要有理想的viewport呢？比如一个分辨率为320x480的手机理想viewport的宽度是320px，而另一个屏幕尺寸相同但分辨率为640x960的手机的理想viewport宽度也是为320px，那为什么分辨率大的这个手机的理想宽度要跟分辨率小的那个手机的理想宽度一样呢？这是因为，只有这样才能保证同样的网站在不同分辨率的设备上看起来都是一样或差不多的。实际上，现在市面上虽然有那么多不同种类不同品牌不同分辨率的手机，但它们的理想viewport宽度归纳起来无非也就 320、360、384、400等几种，都是非常接近的，理想宽度的相近也就意味着我们针对某个设备的理想viewport而做出的网站，在其他设备上的表现也不会相差非常多甚至是表现一样的。</p><h3 id="5-移动端适配"><a href="#5-移动端适配" class="headerlink" title="5. 移动端适配"></a>5. 移动端适配</h3><p>为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。<code>device-width</code>就等于理想视口的宽度，所以设置<code>width=device-width</code>就相当于让布局视口等于理想视口。</p><p>缩放是相对于ideal viewport来缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。例如在iphone中，ideal viewport的宽度是320px，如果我们设置 initial-scale=2 ，此时viewport的宽度会变为只有160px了，这也好理解，放大了一倍嘛，就是原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了。因此<code>initial-scale = 理想视口宽度 / 视觉视口宽度</code>，所以我们设置<code>initial-scale=1;</code>就相当于让视觉视口等于理想视口。这时，1个<code>CSS</code>像素就等于1个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。</p><p>值得注意的是，安卓自带的webkit浏览器只有在 initial-scale = 1 以及没有设置width属性时才是表现正常的，也就相当于这理论在它身上基本没用；而IE则根本不甩initial-scale这个属性，无论你给他设置什么，initial-scale表现出来的效果永远是1。</p><p>再来说下initial-scale的默认值问题，就是不写这个属性的时候，它的默认值会是多少呢？很显然不会是1，因为当 initial-scale = 1 时，当前的layout viewport宽度会被设为 ideal viewport的宽度，但前面说了，各浏览器默认的 layout viewport宽度一般都是980啊，1024啊，800啊等等这些个值，没有一开始就是 ideal viewport的宽度的，所以 initial-scale的默认值肯定不是1。安卓设备上的initial-scale默认值好像没有方法能够得到，或者就是干脆它就没有默认值，一定要你显示的写出来这个东西才会起作用，我们不管它了，这里我们重点说一下iphone和ipad上的initial-scale默认值。</p><p>根据测试，我们可以在iphone和ipad上得到一个结论，就是无论你给layout viewport设置的宽度是多少，而又没有指定初始的缩放值的话，那么iphone和ipad会自动计算initial-scale这个值，以保证当前layout viewport的宽度在缩放后就是浏览器可视区域的宽度，也就是说不会出现横向滚动条。比如说，在iphone上，我们不设置任何的viewport meta标签，此时layout viewport的宽度为980px，但我们可以看到浏览器并没有出现横向滚动条，浏览器默认的把页面缩小了。根据上面的公式，当前缩放值 = ideal viewport宽度 / visual viewport宽度，我们可以得出：<strong>当前缩放值 = 320 / 980</strong><br>也就是当前的initial-scale默认值应该是 0.33这样子。当你指定了initial-scale的值后，这个默认值就不起作用了。</p><p>总之记住这个结论就行了：在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。</p><h3 id="6-缩放"><a href="#6-缩放" class="headerlink" title="6. 缩放"></a>6. 缩放</h3><p>上面提到<code>width</code>可以决定布局视口的宽度，实际上它并不是布局视口的唯一决定性因素，设置<code>initial-scale</code>也有可能影响到布局视口，因为布局视口宽度取的是<code>width</code>和视觉视口宽度的最大值。</p><p>例如：若手机的理想视口宽度为<code>400px</code>，设置<code>width=device-width</code>，<code>initial-scale=2</code>，此时<code>视觉视口宽度 = 理想视口宽度 / initial-scale</code>即<code>200px</code>，布局视口取两者最大值即<code>device-width</code> <code>400px</code>。</p><p>若设置<code>width=device-width</code>，<code>initial-scale=0.5</code>，此时<code>视觉视口宽度 = 理想视口宽度 / initial-scale</code>即<code>800px</code>，布局视口取两者最大值即<code>800px</code>。</p><h2 id="（八）1px问题"><a href="#（八）1px问题" class="headerlink" title="（八）1px问题"></a>（八）1px问题</h2><p>为了适配各种屏幕，我们写代码时一般使用设备独立像素来对页面进行布局。而在设备像素比大于<code>1</code>的屏幕上，我们写的<code>1px</code>实际上是被多个物理像素渲染，这就会出现<code>1px</code>在有些屏幕上看起来很粗的现象。</p><h3 id="1-border-image"><a href="#1-border-image" class="headerlink" title="1. border-image"></a>1. border-image</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">        <span class="attribute">border-bottom</span>: none;</span><br><span class="line">        <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">../img/1pxline.png</span>) <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> stretch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-background-image"><a href="#2-background-image" class="headerlink" title="2. background-image"></a>2. background-image</h3><p>和<code>border-image</code>类似，准备一张符合条件的边框背景图，模拟在背景上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">../img/1pxline.png</span>) repeat-x left bottom;</span><br><span class="line">        <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">1px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种都需要单独准备图片，而且圆角不是很好处理，但是可以应对大部分场景。</p><h3 id="3-伪元素-transform"><a href="#3-伪元素-transform" class="headerlink" title="3. 伪元素+transform"></a>3. 伪元素+transform</h3><p>基于<code>media</code>查询判断不同的设备像素比对线条进行缩放：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="selector-class">.border_1px</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="selector-class">.border_1px</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式可以满足各种场景，如果需要满足圆角，只需要给伪类也加上<code>border-radius</code>即可。</p><h3 id="4-svg"><a href="#4-svg" class="headerlink" title="4. svg"></a>4. svg</h3><p>上面我们<code>border-image</code>和<code>background-image</code>都可以模拟<code>1px</code>边框，但是使用的都是位图，还需要外部引入。</p><p>借助<code>PostCSS</code>的<code>postcss-write-svg</code>我们能直接使用<code>border-image</code>和<code>background-image</code>创建<code>svg</code>的<code>1px</code>边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@svg</span> border_1px &#123; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2px</span>; </span><br><span class="line">  <span class="keyword">@rect</span> &#123; </span><br><span class="line">    fill: <span class="built_in">var</span>(--color, black); </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50%</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"><span class="selector-class">.example</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid transparent; <span class="attribute">border-image</span>: <span class="built_in">svg</span>(border_1px <span class="built_in">param</span>(--color <span class="number">#00b1ff</span>)) <span class="number">2</span> <span class="number">2</span> stretch; &#125;</span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid transparent; <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; height=&#x27;2px&#x27;%3E%3Crect fill=&#x27;%2300b1ff&#x27; width=&#x27;100%25&#x27; height=&#x27;50%25&#x27;/%3E%3C/svg%3E&quot;</span>) <span class="number">2</span> <span class="number">2</span> stretch; &#125;</span><br></pre></td></tr></table></figure><p>该方法基本可以满足所有场景，而且不需要外部引入，这是比较推荐的一种方案。</p><h3 id="5-设置viewport"><a href="#5-设置viewport" class="headerlink" title="5. 设置viewport"></a>5. 设置viewport</h3><p>通过设置缩放，让<code>CSS</code>像素等于真正的物理像素。</p><p>例如：当设备像素比为<code>3</code>时，我们将页面缩放<code>1/3</code>倍，这时<code>1px</code>等于一个真正的屏幕像素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="keyword">const</span> viewport = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!viewport) &#123;</span><br><span class="line">    viewport = <span class="built_in">document</span>.createElement(<span class="string">&#x27;meta&#x27;</span>);</span><br><span class="line">    viewport.setAttribute(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;viewport&#x27;</span>);</span><br><span class="line">    <span class="built_in">window</span>.document.head.appendChild(viewport);</span><br><span class="line">&#125;</span><br><span class="line">viewport.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;width=device-width,user-scalable=no,initial-scale=&#x27;</span> + scale + <span class="string">&#x27;,maximum-scale=&#x27;</span> + scale + <span class="string">&#x27;,minimum-scale=&#x27;</span> + scale);</span><br></pre></td></tr></table></figure><p>实际上，上面这种方案是早先<code>flexible</code>采用的方案。</p><p>当然，这样做是要付出代价的，这意味着你页面上所有的布局都要按照物理像素来写。这显然是不现实的，这时，我们可以借助<code>flexible</code>或<code>vw、vh</code>来帮助我们进行适配。</p><h2 id="（九）适配-iphone-X"><a href="#（九）适配-iphone-X" class="headerlink" title="（九）适配 iphone X"></a>（九）适配 iphone X</h2><p><code>iPhoneX</code>的出现将手机的颜值带上了一个新的高度，它取消了物理按键，改成了底部的小黑条，但是这样的改动给开发者适配移动端又增加了难度。</p><h3 id="1-安全区域"><a href="#1-安全区域" class="headerlink" title="1. 安全区域"></a>1. 安全区域</h3><p>在<code>iPhoneX</code>发布后，许多厂商相继推出了具有边缘屏幕的手机。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/331ae1667fbd495892819ea0a3750ad6~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:25%"><p>这些手机和普通手机在外观上无外乎做了三个改动：圆角（<code>corners</code>）、刘海（<code>sensor housing</code>）和小黑条（<code>Home Indicator</code>）。为了适配这些手机，安全区域这个概念变诞生了：安全区域就是一个不受上面三个效果的可视窗口范围。</p><p>为了保证页面的显示效果，我们必须把页面限制在安全范围内，但是不影响整体效果。</p><h3 id="2-viewport-fit"><a href="#2-viewport-fit" class="headerlink" title="2. viewport-fit"></a>2. viewport-fit</h3><p><code>viewport-fit</code>是专门为了适配<code>iPhoneX</code>而诞生的一个属性，它用于限制网页如何在安全区域内进行展示。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc930e75508a4e2d93f92fabe835931c~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:67%"><ul><li><code>contain</code>: 可视窗口完全包含网页内容</li><li><code>cover</code>：网页内容完全覆盖可视窗口</li></ul><p>默认情况下或者设置为<code>auto</code>和<code>contain</code>效果相同。</p><h3 id="3-env、constant"><a href="#3-env、constant" class="headerlink" title="3. env、constant"></a>3. env、constant</h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37944c89b2244681a6fa1e7a63c64d4c~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:50%"><p>我们需要将顶部和底部合理的摆放在安全区域内，<code>iOS11</code>新增了两个<code>CSS</code>函数<code>env、constant</code>，用于设定安全区域与边界的距离。</p><p>函数内部可以是四个常量：</p><ul><li><code>safe-area-inset-left</code>：安全区域距离左边边界距离</li><li><code>safe-area-inset-right</code>：安全区域距离右边边界距离</li><li><code>safe-area-inset-top</code>：安全区域距离顶部边界距离</li><li><code>safe-area-inset-bottom</code>：安全区域距离底部边界距离</li></ul><p>注意：我们必须指定<code>viweport-fit</code>后才能使用这两个函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;viewport-fit=cover&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>constant</code>在<code>iOS &lt; 11.2</code>的版本中生效，<code>env</code>在<code>iOS &gt;= 11.2</code>的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用底部固定导航栏时，我们要为他们设置<code>padding</code>值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（十）横屏适配"><a href="#（十）横屏适配" class="headerlink" title="（十）横屏适配"></a>（十）横屏适配</h2><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174711.png" alt="image-20210328113924163" style="zoom:50%"><p>很多视口我们要对横屏和竖屏显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式：</p><h3 id="1-JavaScript检测横屏"><a href="#1-JavaScript检测横屏" class="headerlink" title="1. JavaScript检测横屏"></a>1. JavaScript检测横屏</h3><p><code>window.orientation</code>:获取屏幕旋转方向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.orientation === <span class="number">180</span> || <span class="built_in">window</span>.orientation === <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// 正常方向或屏幕旋转180度</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;竖屏&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.orientation === <span class="number">90</span> || <span class="built_in">window</span>.orientation === -<span class="number">90</span> )&#123; </span><br><span class="line">       <span class="comment">// 屏幕顺时钟旋转90度或屏幕逆时针旋转90度</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;横屏&#x27;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><h3 id="2-CSS检测横屏"><a href="#2-CSS检测横屏" class="headerlink" title="2. CSS检测横屏"></a>2. CSS检测横屏</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (orientation: portrait) &#123;</span><br><span class="line">  <span class="comment">/*竖屏...*/</span></span><br><span class="line">&#125; </span><br><span class="line">@media screen and (orientation: landscape) &#123;</span><br><span class="line">  <span class="comment">/*横屏...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">前端性能优化方案</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：16:54:07" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>55k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>50 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210701211849.png" alt="image-20210415153410699"></p><p>关于 Web 应用性能优化，有一点是毫无疑问的：「<strong>页面加载越久，用户体验就越差</strong>」。Web 应用性能优化的关键之处就在于：<strong>减少页面初载时所需加载资源的「数量」和「体积」</strong>。</p><div class="post-button"><a class="btn" href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/" class="post-title-link" itemprop="url">前后端的分离</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:47:58" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.2k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h2 id="（一）前后端分离"><a href="#（一）前后端分离" class="headerlink" title="（一）前后端分离"></a>（一）前后端分离</h2><p>前后端分离是指前后端根据 AJAX 接口进行数据的交互，目前常见的是后端直接将数据以<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/JSON">JSON</a>的格式返回给前端，前端根据后端服务器返回的数据操作DOM。</p><p><strong>主要优点</strong></p><ul><li>分工明确，前后端各司其职，后端专注业务逻辑和功能的实现，前端专注页面设计。</li><li>接口明确，并行开发，在后端接口没有实现好之前，前端完全可以自己通过<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://nodejs.org/en/">Node.js</a>的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://expressjs.com/zh-cn/">Express</a>和<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://koa.bootcss.com/">koa</a>等的Web框架模拟接口，提供测试数据。</li><li>提高开发效率，一定程度上减少了前后端的<del>沟通成本</del>撕逼</li></ul><p>在前后端分离中，后端一般提供<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.zhihu.com/question/28557115">RESTful</a> API，常将数据以JSON格式返回；而前端一般使用什么呢，这里便是引出了我们讨论的主题之一：SPA。</p><h2 id="（二）SPA"><a href="#（二）SPA" class="headerlink" title="（二）SPA"></a>（二）SPA</h2><p>SPA（Single Page App）是一种<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://en.wikipedia.org/wiki/Web_application">网络应用程序</a>（Web App）模型。在传统网站中，切换到不同页面需要从服务器加载一整个新的页面，而在 SPA 中只要动态重写页面需要发生变化的部分（如下图知乎页面的导航栏），从而避免了过多的数据交换，提高了响应速度。</p><p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174748.png" alt="image-20210513125706473" style="zoom:70%"><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174749.png" alt="image-20210513125723203" style="zoom:67%"></p><p>目前常见的几个SPA框架有Angular、React、Vue。</p><p><strong>SPA的优点</strong></p><p>除了上文所说的前后端分离，SPA还有如下一些优点：</p><ul><li>页面之间的切换非常快</li><li>一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染）</li><li>后端程序只需要提供API，完全不用管客户端到底是Web界面还是手机等</li></ul><p><strong>SPA的缺点</strong></p><ul><li>首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面。</li><li>不利于SEO</li></ul><p>根据这几个缺点，接下来讨论的两个主题就是SEO和SSR。</p><h2 id="（三）SEO"><a href="#（三）SEO" class="headerlink" title="（三）SEO"></a>（三）SEO</h2><p><strong>SEO</strong>（<strong>Search Engine Optimization</strong>）也称搜索引擎优化。它是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。</p><p><strong>常用技术</strong></p><p>搜索引擎优化中的技术大致可以分两类：白帽技术与黑帽技术，<br>SEO涉及细节也很多，以下是<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://en.wikipedia.org/wiki/Search_engine_optimization">维基百科</a>对于一些白帽技术的介绍：</p><blockquote><ul><li>在每页使用一个短、独特和相关的标题。</li><li>编辑网页，用与该页的主题。有关的具体术语替换隐晦的字眼。这有助于该站诉求的观众群，在搜索引擎上搜索而被正确导引至该站。</li><li>在该站点增加相当数量的原创内容。</li><li>使用合理大小、准确描述的汇标，而不过度使用关键字、惊叹号、或不相关标题术语。</li><li>注意网址字眼，有助于搜索引擎优化。</li><li>确认所有页可透过正常的链接来访问，而非只能透过Java 、JavaScript或Adobe Flash应用程序访问。这可透过使用一个专属列出该站所有内容的网页达成（网站地图）</li><li>透过自然方式开发链接：Google不花功夫在这有点混淆不清的指南上。写封电子邮件给网站员，告诉他：您刚刚贴了一篇挺好的文章，并且请求链接，这种做法很可能为搜索引擎所认可。</li><li>参与其他网站的网络集团（译按：web ring 指的是有相同主题的结盟站群）──只要其它网站是独立的、分享同样题目和可比较的品质。</li></ul></blockquote><p>除去非开发细节，我们大该可以提炼出以下的信息：</p><ul><li>标题： 即HTML的 <code>&lt;title&gt;&lt;/title&gt;</code> 标签，例如： <code>&lt;title&gt;浅谈SPA、SEO、SSR | XXX 的博客&lt;/title&gt;</code> ，在Google的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://support.google.com/webmasters/answer/79812?hl=en">相关文档</a>中已经说明了不再使用<code>&lt;title&gt;</code> 标签作为Meta，但是经常会配合 <code>description</code>出现在搜索的结果上</li></ul><blockquote><p>While technically not a meta tag, this tag is often used together with the “description”. The contents of this tag are generally shown as the title in search results (and of course in the user’s browser)</p></blockquote><ul><li>描述： 即HTML<code>&lt;meta&gt;</code>标签的<code>description</code>，例如百度百科的一个词条的 <code>description</code>：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;通常所说的META标签，是在HTML网页源代码中一个重要的html标签。META标签用来描述一个HTML网页文档的属性，例如作者、日期和时间、网页描述、关键词、页面刷新等。...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>关键字： 即HTML<code>&lt;meta&gt;</code>标签的<code>keywords</code>， 例如</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;META标签 META标签作用 META标签组成 META标签属性 META标签描述设计 META标签错误 META标签标签&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Google的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://support.google.com/webmasters/answer/79812?hl=en">相关文档</a>中也没有提到过使用<code>meta keywords</code>， Quora也讨论过Google是否还在使用<code>meta keywords</code>这个<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.quora.com/Does-Google-use-meta-keywords-in-2018">问题</a>，大部分的回答都是谷歌已经不再使用它了，但是其它的一些搜索引擎比如百度等还在使用<code>meta keywords</code>。</p><p><strong>SPA与SEO的冲突</strong></p><p>前面我们谈到的SPA不利于SEO，因为就目前而言，部分搜索引擎如Google、bing等，它们的爬虫虽然已经支持执行JS甚至是通过AJAX获取数据了，但是对于异步数据的支持也还不足(也可能是搜索引擎提供商觉得没必要)，<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://ssr.vuejs.org/zh/">Vue SSR</a>中是这样说的</p><blockquote><p>如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。</p></blockquote><p>前面也谈到过SPA应用中，通常通过AJAX获取数据，而这里就难以保证我们的页面能被搜索引擎正常收录到。并且有一些搜索引擎不支持执行JS和通过AJAX获取数据，那就更不用提SEO了。<br>对于有些网站而言，SEO显得至关重要，例如主要以内容输出为主的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.quora.com/">Quora</a>、<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://stackoverflow.com/">stackoverflow</a>、<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.zhihu.com/">知乎</a>和<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.douban.com/">豆瓣</a>等等，那如何才能正常使用SPA而又不影响SEO呢？</p><p>此时，SSR便闪亮登场了</p><h2 id="（四）SSR"><a href="#（四）SSR" class="headerlink" title="（四）SSR"></a>（四）SSR</h2><p><strong>SSR</strong>是 <strong>Server-Side Rendering</strong>（服务器端渲染）的缩写，在普通的 SPA 中，一般是将框架及网站页面代码发送到浏览器，然后在浏览器中生成和操作DOM（在同等带宽及网络延迟下，初次访问 SPA 网站比传统的在后端生成 HTML 发送到浏览器要更慢的主要原因）。但我们可以将 SPA 应用打包到服务器上，在服务器上渲染出 HTML 再发送到浏览器，这样的 HTML 页面还不具备交互能力，所以还需要与 SPA 框架配合，在浏览器上混合成可交互的应用程序。所以只要能合理地运用SSR技术，不仅能一定程度上解决首屏慢的问题，还能获得更好的SEO。</p><p><strong>SSR的优点</strong></p><ul><li>更快的响应时间，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面。</li><li>更好的SSR，我们可以将SEO的关键信息直接在后台就渲染成HTML，而保证搜索引擎的爬虫都能爬取到关键数据。</li></ul><p><strong>SSR的缺点</strong></p><ul><li>相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序自然会占用更多的CPU和内存资源</li><li>一些常用的浏览器API可能无法正常使用，比如<code>window</code>、<code>document</code>和<code>alert</code>等，如果使用的话需要对运行的环境加以判断</li><li>开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂</li><li>可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致。</li></ul><p><strong>SSR常用框架</strong></p><ul><li>React 的 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://nextjs.org/">Next</a></li><li>Vue.js 的 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://nuxtjs.org/">Nuxt</a></li></ul><p>不熟悉React及Next，不作评价，我的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://chengfy.com">博客</a>便是使用了Nuxt做服务器端渲染，在此不得不说Nuxt的用法实在是太漂亮了，既有一定的约束（无规矩不成方圆），又不失扩展性，官网的文档也非常不错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>前后端分离降低了前端和后端的耦合度，提高了开发效率；<br>SPA是前后端分离中前端的一种解决方案；<br>SEO对与很多网站很重要而普通的SPA又不利于SEO；<br>SSR的出现一定程度上解决了SPA中首屏慢的问题，又极大减少了普通SPA对于SEO的不利影响。</strong></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/web%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E6%8F%90%E5%8D%87%E6%8C%87%E5%8D%97/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/web%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E6%8F%90%E5%8D%87%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Web 用户体验设计提升指南</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：16:57:54" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>用户体验设计秉承着<strong>以用户为中心的思想</strong>，以用户需求为目标。设计过程注重以用户为中心，用户体验的概念从开发的最早期就开始进入整个流程，并贯穿始终。良好的用户体验设计，是产品每一个环节共同努力的结果。</p><p>除去一些很难一蹴而就的，本文将就<strong>页面展示</strong>、<strong>交互细节</strong>、<strong>可访问性</strong>三个方面入手，罗列一些在实际的开发过程中，积攒的一些有益的经验。通过本文，你将能收获到：</p><ul><li><p>了解到一些小细节是如何影响用户体验的</p></li><li><p>了解到如何在尽量小的开发改动下，提升页面的用户体验</p></li><li><p>了解到一些优秀的交互设计细节</p></li><li><p>了解基本的无障碍功能及页面可访问性的含义</p></li><li><p>了解基本的提升页面可访问性的方法</p><div class="post-button"><a class="btn" href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/web%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E6%8F%90%E5%8D%87%E6%8C%87%E5%8D%97/#more" rel="contents">阅读全文 &raquo;</a></div></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%90%8E%E7%AB%AF/Linux/%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%90%8E%E7%AB%AF/Linux/%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">Linux 课后练习题</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：16:49:07" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>606</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><p>第一章</p><p>一、判断题<br>1、Linux内核是单内核结构，执行效率高，可维护性好。（ × ）</p><p>为什么要使用模块？<br>linux内核之所以提供模块机制，是因为它本身是一个单内核。而单内核的最大优点就是效率高，因为所有的内容都集成在一起，但其缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p><p>2、Linux内核模块不属于Linux的子系统。（ √ ）</p><p>Linux内核主要由5个子系统组成：进程调度（SCHED），内存管理（MM），虚拟文件系统（VFS），网络接口（NET），进程间通信（IPC）</p><p>3、当一个操作系统满足POSIX标准时，在该系统上写的应用程序都能在任何UNIX系统中运行。（ √ ）<br>4、硬件性价比比较低的时候，操作系统设计追求低成本高性能。（ ）<br>5、 硬件性价比比较高以后，操作系统设计不再考虑硬件成本需求，着力在充分利用硬件的性能上。（ × ）</p><p>在硬件的性价比较低的时候，操作系统设计完成了追求硬件使用率的理论探索，从批处理到分时系统<br>在硬件性价比越来越高后，操作系统的设计开始追求系统的可靠和稳定，出现了多处理器系统和分布式系统</p><p>6、Linux系统的设备管理功能通过虚拟文件系统实现。（ ）</p><p>二、单选题<br>1、（ d ）不属于Linux的子系统。<br>A 进程管理 B 内存管理 C 文件系统 D 模块<br>2、Linux操作系统遵循（ c ）标准。<br>A GNU B GPL C POSIX D MMU<br>3、struct list_head 无法表达（ ）种数据结构。<br>A 队列和堆栈 B 图 C 树 D 集合</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%BC%82%E6%AD%A5/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%BC%82%E6%AD%A5/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">异步操作</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:24:51" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>15k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>14 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="（一）Promise-含义"><a href="#（一）Promise-含义" class="headerlink" title="（一）Promise 含义"></a>（一）Promise 含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 <code>Promise</code> 对象。<code>Promise</code> 可以说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><code>Promise</code> 对象有以下两个特点。</p><ul><li>对象的状态不受外界影响。<code>Promise</code> 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 <code>Promise</code> 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code> 对象的状态改变，只有两种可能：从 <code>pending</code> 变为 <code>fulfilled</code> 和从 <code>pending</code> 变为 <code>rejected</code>。只要这两种情况发生，状态就不再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 <code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ul><p>注意，为了行文方便，本章后面的 <code>resolved</code> 统一只指 <code>fulfilled</code> 状态，不包含 <code>rejected</code> 状态。</p><p>有了 <code>Promise</code> 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有一些缺点。首先，<code>Promise</code> 一旦创建就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误不会反应到外部。第三，当处于 <code>pending</code> 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><p>如果某些事件不断地反复发生，一般来说，使用 <a target="_blank" rel="noopener" href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署 <code>Promise</code> 更好的选择。</p><h2 id="（二）Promise-用法"><a href="#（二）Promise-用法" class="headerlink" title="（二）Promise 用法"></a>（二）Promise 用法</h2><p>ES6 规定，<code>Promise</code> 对象是一个构造函数，用来生成 <code>Promise</code> 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code> 构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和 <code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code> 函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果作为参数传递出去；<code>reject</code> 函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。</p><p><code>Promise</code> 实例生成以后，可以用 <code>then</code> 方法分别指定 <code>resolved</code> 状态和 <code>rejected</code> 状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code> 方法可以接受两个回调函数作为参数。第一个回调函数是 <code>Promise</code> 对象的状态变为 <code>resolved</code> 时调用，第二个回调函数是 <code>Promise</code> 对象的状态变为 <code>rejected</code> 时调用。这两个函数都是可选的，不一定要提供。它们都接受 <code>Promise</code> 对象传出的值作为参数。</p><p>下面是一个 <code>Promise</code> 对象的简单例子：<code>timeout</code> 方法返回一个 <code>Promise</code> 实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code> 实例的状态变为 <code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面是异步加载图片的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">        image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(image);</span><br><span class="line">        &#125;;</span><br><span class="line">        image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url));</span><br><span class="line">        &#125;;</span><br><span class="line">        image.src = url;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，使用 <code>Promise</code> 包装了一个图片加载的异步操作。如果加载成功，就调用 <code>resolve</code> 方法，否则就调用 <code>reject</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Promise对象实现的 Ajax 操作</span></span><br><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="built_in">this</span>.response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        client.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">        client.onreadystatechange = handler;</span><br><span class="line">        client.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">        client.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        client.send();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">&quot;/posts.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON</code> 是对 <code>XMLHttpRequest</code> 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在 <code>getJSON</code> 内部，<code>resolve</code>函数和 <code>reject</code> 函数调用时，都带有参数。</p><p>如果调用 <code>resolve</code> 函数和 <code>reject</code> 函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是 <code>Error</code> 对象的实例，表示抛出的错误；<code>resolve</code> 函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code> 和 <code>p2</code> 都是 Promise 的实例，但是 <code>p2</code> 的 <code>resolve</code> 方法将 <code>p1</code> 作为参数，即一个异步操作的结果是返回另一个异步操作。注意，这时 <code>p1</code> 的状态就会传递给 <code>p2</code>，也就是说，<code>p1</code> 的状态决定了 <code>p2</code> 的状态。如果 <code>p1</code> 的状态是 <code>pending</code>，那么 <code>p2</code> 的回调函数就会等待 <code>p1</code> 的状态改变；如果 <code>p1</code> 的状态已经是 <code>resolved</code> 或者 <code>rejected</code>，那么 <code>p2</code> 的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为 <code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是 <code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的 <code>then</code> 语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code> 变为 <code>rejected</code>，导致触发 <code>catch</code> 方法指定的回调函数。</p><h2 id="（三）Promise-特性"><a href="#（三）Promise-特性" class="headerlink" title="（三）Promise 特性"></a>（三）Promise 特性</h2><h3 id="1-立即执行性"><a href="#1-立即执行性" class="headerlink" title="1. 立即执行性"></a>1. 立即执行性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;create a promise&quot;</span>);</span><br><span class="line">  resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;after new Promise&quot;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;create a promise&quot;</span><br><span class="line">&quot;after new Promise&quot;</span><br><span class="line">&quot;success&quot;</span><br></pre></td></tr></table></figure><p>Promise 对象表示未来某个将要发生的事件，但在开始创建 Promise 时，作为参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有人错以为只有当 Promise 对象调用 <code>then</code> 方法时，Promise 接收的函数才会执行。<code>then</code> 方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。</p><p>注意，调用 <code>resolve</code> 或 <code>reject</code> 并不会终结 Promise 的参数函数的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用 <code>resolve(1)</code> 以后，后面的 <code>console.log(2)</code> 还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说，调用 <code>resolve</code> 或 <code>reject</code> 后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code> 或 <code>reject</code> 的后面。所以，最好在它们前面加上 <code>return</code> 语句，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-三种状态"><a href="#2-三种状态" class="headerlink" title="2. 三种状态"></a>2. 三种状态</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="number">2</span>);  </span><br><span class="line">    &#125;, <span class="number">500</span>);      </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        reject(<span class="number">3</span>);  </span><br><span class="line">    &#125;, <span class="number">500</span>);      </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br><span class="line"><span class="built_in">console</span>.log(p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p3);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1&#125;</span><br><span class="line">Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</span><br><span class="line">Promise &#123;[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined&#125;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 2&#125;</span><br><span class="line">Promise &#123;[[PromiseStatus]]: &quot;rejected&quot;, [[PromiseValue]]: 3&#125;</span><br></pre></td></tr></table></figure><p>Promise 的内部实现是一个状态机，它有三种状态：pending，resolved，rejected。当 Promise 刚创建完成时，处于 pending 状态；当 Promise 中的函数参数执行了 <code>resolve()</code> 后，Promise 由 pending 状态变成 resolved 状态；执行 <code>reject()</code> 则会由 pending 状态变成 rejected 状态。</p><p>p2、p3 刚创建完成时，控制台输出的这两台 Promise 都处于 pending 状态，但为什么 p1 是 resolved 状态呢？ 这是因为 p1 的函数参数中执行的是一段同步代码，Promise 刚创建完成，resolve 方法就已经被调用了，因而紧跟着的输出显示 p1 是 resolved 状态。我们通过两个 <code>setTimeout</code> 函数，延迟 1s 后再次输出 p2、p3 的状态，此时 p2、p3 已经执行完成，状态分别变成 resolved 和 rejected。</p><h3 id="3-状态不可逆性"><a href="#3-状态不可逆性" class="headerlink" title="3. 状态不可逆性"></a>3. 状态不可逆性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">    resolve(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    reject(<span class="string">&quot;reject&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;success1&quot;</span><br><span class="line">&quot;success&quot;</span><br></pre></td></tr></table></figure><p>Promise 状态一旦变成 resolved 或 rejected 时，Promise 的状态和值就固定下来了，不论后续再怎么调用 resolve 或 reject 方法，都不能改变它的状态和值。因此，p1 中 <code>resolve(&quot;success2&quot;)</code>并不能将 p1 的值更改为 <code>success2</code>，p2 中 <code>reject(&quot;reject&quot;)</code> 也不能将 p2 的状态由 resolved 改变为 rejected。</p><h3 id="4-链式调用"><a href="#4-链式调用" class="headerlink" title="4. 链式调用"></a>4. 链式调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolve: &#x27;</span>+ value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;reject: &#x27;</span> + err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">undefined</span><br><span class="line">&quot;resolve&quot;</span><br><span class="line">&quot;reject: reject&quot;</span><br></pre></td></tr></table></figure><p>Promise 对象的 then 方法返回一个新的 Promise 对象，因此可以链式调用 then 方法。then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建 then 返回的 Promise 对象。这两个参数的返回值可以是以下三种情况中的一种：</p><ul><li><code>return</code> 一个同步的值 ，或者没有返回一个有效值时（默认返回 undefined），<code>then</code>方法将返回一个 resolved 状态的 Promise 对象，Promise 对象的值就是这个返回值。</li><li><code>return</code> 另一个 Promise，<code>then</code> 方法将根据这个 Promise 的状态和值创建一个新的 Promise 对象返回。</li><li><code>throw</code> 一个同步异常，<code>then</code> 方法将返回一个 rejected 状态的 Promise, 值是该异常。</li></ul><p>根据以上分析，代码中第一个 <code>then</code> 会返回一个值为2（1*2），状态为 resolved 的 Promise 对象，于是第二个 <code>then</code> 输出的值是2。第二个 <code>then</code> 中没有返回值，因此将返回默认的 undefined，于是在第三个 <code>then</code> 中输出 undefined。第三个 <code>then</code> 和第四个 <code>then</code> 中分别返回一个状态是 resolved 的 Promise 和一个状态是 rejected 的 Promise，依次由第四个 <code>then</code> 中成功的回调函数和第五个 <code>then</code> 中失败的回调函数处理。</p><h3 id="5-回调异步性"><a href="#5-回调异步性" class="headerlink" title="5. 回调异步性"></a>5. 回调异步性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;which one is called first ?&quot;</span>);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;which one is called first ?&quot;</span><br><span class="line">&quot;success&quot;</span><br></pre></td></tr></table></figure><p>Promise 接收的函数参数是同步执行的，但 <code>then</code> 方法中的回调函数执行则是异步的，因此，”success” 会在后面输出。</p><h3 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    foo.bar();</span><br><span class="line">    resolve(<span class="number">1</span>);	  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1 then value: &#x27;</span> + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1 then err: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1 then then value: &#x27;</span>+value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p1 then then err: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);	</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then value: &#x27;</span> + value);</span><br><span class="line">        foo.bar();</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then err: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then then value: &#x27;</span> + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then then err: &#x27;</span> + err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then then then value: &#x27;</span> + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;p2 then then then err: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1 then err: ReferenceError: foo is not defined</span><br><span class="line">p2 then value: 2</span><br><span class="line">p1 then then value: undefined</span><br><span class="line">p2 then then err: ReferenceError: foo is not defined</span><br><span class="line">p2 then then then value: 1</span><br></pre></td></tr></table></figure><p>Promise 中的异常由 <code>then</code> 参数中第二个回调函数处理，异常信息将作为 Promise 的值。异常一旦得到处理，<code>then</code> 返回的后续 Promise 对象将恢复正常，并会被 Promise 执行成功的回调函数处理。另外，需要注意 p1、p2 多级 <code>then</code> 的回调函数是交替执行的 ，这正是由 <code>then</code> 回调的异步性决定的。</p><h3 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7. Promise.resolve()"></a>7. <code>Promise.resolve()</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(p1);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); </span><br><span class="line"><span class="built_in">console</span>.log(p1 === p3);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p4);</span><br><span class="line"><span class="built_in">console</span>.log(p3 === p4);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p4=&#x27;</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p2=&#x27;</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p1=&#x27;</span> + value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">p2&#x3D;1</span><br><span class="line">p1&#x3D;1</span><br><span class="line">p4&#x3D;1</span><br></pre></td></tr></table></figure><p><code>Promise.resolve(...)</code> 可以接收一个值或者是一个 Promise 对象作为参数。当参数是普通值时，它返回一个 resolved 状态的 Promise 对象，对象的值就是这个参数；当参数是一个 Promise 对象时，它直接返回这个 Promise 参数。因此，p1 === p2。但通过 new 的方式创建的 Promise 对象都是一个新的对象，因此后面的三个比较结果都是 false。另外，为什么 p4 的 <code>then</code> 最先调用，但在控制台上是最后输出结果的呢？因为 p4 的 <code>resolve</code> 中接收的参数是一个 Promise 对象 p1，<code>resolve</code> 会对 p1 拆箱，获取 p1 的状态和值，但这个过程是异步的，可参考下一节。</p><h3 id="8-resolve-VS-reject"><a href="#8-resolve-VS-reject" class="headerlink" title="8. resolve VS reject"></a>8. resolve VS reject</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;resolve&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="built_in">Promise</span>.reject(<span class="string">&#x27;reject&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    reject(<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;resolve&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled: &#x27;</span> + value);</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">p2.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled: &#x27;</span> + value);</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">p3.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled: &#x27;</span> + value);</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p3 rejected: [object Promise]</span><br><span class="line">p1 fulfilled: resolve</span><br><span class="line">p2 rejected: reject</span><br></pre></td></tr></table></figure><p>Promise 回调函数中的第一个参数 <code>resolve</code>，会对 Promise 执行拆箱动作。即当 <code>resolve</code> 的参数是一个 Promise 对象时，<code>resolve</code> 会拆箱获取这个 Promise 对象的状态和值，但这个过程是异步的。p1 拆箱后，获取到 Promise 对象的状态是 resolved，因此 <code>fulfilled</code> 回调被执行；p2 拆箱后，获取到 Promise 对象的状态是 rejected，因此 <code>rejected</code> 回调被执行。</p><p>但 Promise 回调函数中的第二个参数 <code>reject</code> 不具备拆箱的能力，reject 的参数会直接传递给 <code>then</code> 方法中的 <code>rejected</code> 回调。因此，即使 p3 <code>reject</code>接收了一个 resolved 状态的 Promise，<code>then</code> 方法中被调用的依然是 <code>rejected</code>，并且参数就是 <code>reject</code> 接收到的 Promise 对象。</p><h2 id="（四）Promise-实现"><a href="#（四）Promise-实现" class="headerlink" title="（四）Promise 实现"></a>（四）Promise 实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise内部已经实现具体的resolve和reject方法，只是还没有传入实参（关键数据）。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>; <span class="comment">// 缓存当前promise实例</span></span><br><span class="line">    self.value = <span class="literal">null</span>; <span class="comment">//成功时的值</span></span><br><span class="line">    self.error = <span class="literal">null</span>; <span class="comment">//失败时的原因</span></span><br><span class="line">    self.status = PENDING; <span class="comment">//初始状态为PENDING</span></span><br><span class="line">    self.onFulfilledCallbacks = []; <span class="comment">//成功的回调函数</span></span><br><span class="line">    self.onRejectedCallbacks = []; <span class="comment">//失败的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//只有当状态是PENDING才能修改状态为fulfilled并执行成功逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(self.status === PENDING) &#123;</span><br><span class="line">            <span class="comment">//利用setTimeout特性将具体执行放到then初始化之后</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                self.status = FULFILLED;</span><br><span class="line">                self.value = value;</span><br><span class="line">                self.onFulfilledCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.value))</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//如果状态是pending才去修改状态为rejected并执行失败逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                self.status = REJECTED;</span><br><span class="line">                self.error = error;</span><br><span class="line">                self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.error));</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve, reject);  <span class="comment">//这里体现Promise的立即执行性。</span></span><br><span class="line">    <span class="comment">//当Promise接收到函数参数fn时，会对其立即执行，只是其中的代码可能是异步代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> bridgePromise;</span><br><span class="line">    <span class="comment">//如果使用者没有传入成功或失败回调函数，那么就使用默认回调函数</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span> ? onRejected : <span class="function"><span class="params">error</span> =&gt;</span> &#123;<span class="keyword">throw</span> error&#125;;</span><br><span class="line">    <span class="keyword">if</span>(self.status === FULFILLED) &#123;</span><br><span class="line">        <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">                    resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(self.status === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(self.error);</span><br><span class="line">                    resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(self.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            self.onFulfilledCallbacks.push(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onFulfilled(value);</span><br><span class="line">                    resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            self.onRejectedCallbacks.push(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onRejeted(error);</span><br><span class="line">                    resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//catch方法是语法糖，就是只传onRejected不传onFulfilled的then方法</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来解析回调函数的返回值x，x可能是普通值也可能是promise对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">bridgePromise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果x是一个promise</span></span><br><span class="line">    <span class="keyword">if</span>(x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        <span class="comment">//如果这个promise是pending状态，就在它的then方法里继续执行resolvePromise解析它的结果，直到返回值不是一个pending状态的promise为止</span></span><br><span class="line">        <span class="keyword">if</span>(x.status === PENDING) &#123;</span><br><span class="line">            x.then(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                resolvePromise(bridgePromise, y, resolve, reject);</span><br><span class="line">            &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x.then(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果x是一个普通值，那么就让bridgePromise的状态fulfilled，并把这个值传递下去</span></span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise</span><br></pre></td></tr></table></figure><h1 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h1></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">动态规划算法</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:43:43" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4.2k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>冒泡排序在每次冒泡操作时会比较相邻的两个元素，看是否满足大小关系要求，不满足就将它俩互换。一直迭代到不再需要交换，也就是排序完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        flag = <span class="literal">false</span> <span class="comment">// 提前退出冒泡循环的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">const</span> temp = arr[j]</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp</span><br><span class="line">                flag = <span class="literal">true</span> <span class="comment">// 表示有数据交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span> <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><p>插入排序顾名思义，对于未排序的数据，在已排序的序列中从后往前扫描，找到相应的位置进行插入，保持已排序序列中元素一直有序。从 i 等于 1 开始遍历，拿到当前元素 curr，与前面的元素进行比较。如果前面的元素大于当前元素，就把前面的元素和当前元素进行交换，不断循环直到未排序序列中元素为空，排序完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length</span><br><span class="line">    <span class="keyword">let</span> curr, prev</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        curr = arr[i]</span><br><span class="line">        prev = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (prev &gt;= <span class="number">0</span> &amp;&amp; arr[prev] &gt; curr) &#123;</span><br><span class="line">            arr[prev + <span class="number">1</span>] = arr[prev]</span><br><span class="line">            prev--</span><br><span class="line">        &#125;</span><br><span class="line">        arr[prev + <span class="number">1</span>] = curr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h3><p>选择排序和插入排序有些类似，也分已排序序列和未排序序列。</p><p>但是选择排序是将最小的元素存放在数组起始位置，再从剩下的未排序的序列中寻找最小的元素，然后将其放到已排序的序列后面。以此类推，直到排序完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length</span><br><span class="line">    <span class="keyword">let</span> temp, minIndex</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i]</span><br><span class="line">        arr[i] = arr[minIndex]</span><br><span class="line">        arr[minIndex] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h3><p>分治法典型应用，分治算法思想很大程度上是基于递归的，也比较适合用递归来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理过程是由下到上的，先处理子问题，然后再合并。</span><br></pre></td></tr></table></figure><p>分而治之。一般分为以下三个过程：</p><ol><li>分解：将原问题分解成一系列子问题。</li><li>解决：递归求解各个子问题，若子问题足够小，则直接求解。</li><li>合并：将子问题的结果合并成原问题。</li></ol><p>归并排序就是将待排序数组不断二分为规模更小的子问题处理，再将处理好的子问题合并起来，这样整个数组就都有序了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = []</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] &lt; right[j]) &#123;</span><br><span class="line">                result.push(left[i++])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.push(right[j++])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; left.length) &#123;</span><br><span class="line">            result.push(left[i++])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; right.length) &#123;</span><br><span class="line">            result.push(right[j++])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> sort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length === <span class="number">1</span>) &#123; <span class="keyword">return</span> arr &#125;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>, mid)</span><br><span class="line">        <span class="keyword">const</span> right = arr.slice(mid, arr.length)</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sort(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h3><p>快速排序也是分治法的应用，处理过程是由上到下的，先分区，然后再处理子问题。快速排序通过遍历数组，将待排序元素分隔成独立的两部分，一部分记录的元素均比另一部分的元素小，则可以分别对这两部分记录的元素继续进行排序，直到排序完成。</p><p>这就需要从数组中挑选出一个元素作为 <code>基准(pivot)</code>，然后重新排序数列，将元素比基准值小的放到基准前面，比基准值大的放到基准后面。然后将小于基准值的子数组(left)和大于基准值的子数组(right)递归地调用 quick 方法，直到排序完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> quick = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">const</span> len = arr.length</span><br><span class="line">        <span class="keyword">const</span> index = <span class="built_in">Math</span>.floor(len &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">const</span> pivot = arr.splice(index, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">const</span> left = []</span><br><span class="line">        <span class="keyword">const</span> right = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">                right.push(arr[i])</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</span><br><span class="line">                left.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quick(left).concat([pivot], quick(right))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = quick(arr)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h3><p>堆排序相比其他几种排序代码会有些复杂，先来看一些前置知识帮助理解。堆排序顾名思义就是要利用堆这种数据结构进行排序。堆是一种特殊的树，满足以下两点就是堆：</p><ul><li>堆是一个完全二叉树</li><li>堆中每一个节点的值都必须大于等于(或小于等于)其子树中的每个节点的值</li></ul><p>每个节点的值都大于等于子树中每个节点值的堆，叫做大顶堆，每个节点的值都小于等于子树中每个节点值的堆，叫做小顶堆。也就是说，大顶堆中，根节点是堆中最大的元素。小顶堆中，根节点是堆中最小的元素。堆如果用一个数组表示的话，给定一个节点的下标 i (i从1开始)，那么它的父节点一定为 A[i / 2]，左子节点为 A[2i]，右子节点为 A[2i + 1]。</p><p>堆排序包含两个过程，建堆和排序。首先构建一个大顶堆，也就是将最大值存储在根节点(i = 1)。每次取大顶堆的根节点与堆的最后一个节点进行交换，此时最大值放入了有效序列的最后一位，并且有效序列减 1，有效堆依然保持完全二叉树的结构，然后进行堆化成为新的大顶堆。重复此操作，直到有效堆的长度为 0，排序完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heapSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    buildHeap(arr, arr.length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> heapSize = arr.length - <span class="number">1</span> <span class="comment">// 初始化堆的有效序列长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(arr, <span class="number">1</span>, i) <span class="comment">// 交换堆顶元素与最后一个有效子元素</span></span><br><span class="line">        heapSize-- <span class="comment">// 有效序列长度减 1</span></span><br><span class="line">        heapify(arr, heapSize, <span class="number">1</span>) <span class="comment">// 堆化有效序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建大顶堆</span></span><br><span class="line"><span class="keyword">const</span> buildHeap = <span class="function"><span class="keyword">function</span>(<span class="params">items, heapSize</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从后往前并不是从序列的最后一个元素开始，而是从最后一个非叶子节点开始，这是因为，叶子节点没有子节点，不需要自上而下式堆化。</span></span><br><span class="line">    <span class="comment">// 最后一个子节点的父节点为 n/2 ，所以从 n/2 位置节点开始堆化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>); i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        heapify(items, heapSize, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆化</span></span><br><span class="line"><span class="keyword">const</span> heapify = <span class="function"><span class="keyword">function</span>(<span class="params">arr, heapSize, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxIndex = i</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * i &lt;= heapSize &amp;&amp; arr[i] &lt; arr[i * <span class="number">2</span>]) &#123;</span><br><span class="line">            maxIndex = i * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= heapSize &amp;&amp; arr[maxIndex] &lt; arr[i * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">            maxIndex = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxIndex === i) <span class="keyword">break</span></span><br><span class="line">        swap(arr, i, maxIndex)</span><br><span class="line">        i = maxIndex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换工具函数</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function"><span class="keyword">function</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">    arr[i] = arr[j]</span><br><span class="line">    arr[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174333.png" alt="image-20210822173636751" style="zoom:50%"></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划算法</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:23:16" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>768</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>动态规划，无非就是利用<strong>历史记录</strong>，来避免我们的重复计算。而这些<strong>历史记录</strong>，我们得需要一些<strong>变量</strong>来保存，一般是用<strong>一维数组</strong>或者<strong>二维数组</strong>来保存。下面我们先来讲下做动态规划题很重要的三个步骤，</p><p><strong>第一步骤</strong>：定义<strong>数组元素的含义</strong>，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？</p><p><strong>第二步骤</strong>：找出<strong>数组元素之间的关系式</strong>，我觉得动态规划，还是有一点类似于我们高中学习时的<strong>归纳法</strong>的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用<strong>历史数据</strong>来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。</p><div class="post-button"><a class="btn" href="/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">页面加载海量数据</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:21:01" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.2k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><strong>题目</strong>：将包含 10w 条记录的数组一次性渲染到页面上，如何处理可以不冻结 UI ?</p><div class="post-button"><a class="btn" href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E6%95%B0%E7%BB%84/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/JavaScript/%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">JS 数组常见需求</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:20:16" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h1 id="（一）数组常见需求"><a href="#（一）数组常见需求" class="headerlink" title="（一）数组常见需求"></a>（一）数组常见需求</h1><h2 id="检验数组"><a href="#检验数组" class="headerlink" title="检验数组"></a><strong>检验数组</strong></h2><p>不能使用 <code>typeof</code> 方法检验一个变量是否为数组，因为它的检测结果只有 <code>undefined</code>、<code>object</code>、<code>function</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>bigint</code>、<code>symbol</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(arr)); <span class="comment">//&quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>推荐使用 Array 自带的 <code>isArray()</code> 方法进行检验。</p><p>或者使用 <code>Object.prototype.toString.call(arr).slice(8, -1)===&quot;Array&quot;</code> 进行判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)); <span class="comment">// &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure><p>不能直接使用 <code>arr.toString()</code> 来确定类型的原因在于，Object 的 <code>toString</code> 方法被其实例 Array 进行了重写。当数组对象调用自身的 <code>toString</code> 方法时，会用逗号拼接数组中的所有值，并返回其字符串形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.toString()); <span class="comment">// &quot;a,b,c&quot;</span></span><br></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a><strong>数组去重</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test.push(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>(test)); <span class="comment">// &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span></span><br><span class="line"><span class="keyword">var</span> test1 = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(test));</span><br><span class="line"><span class="built_in">console</span>.log(test1); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test2 = test.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> test.indexOf(item) === index);</span><br><span class="line"><span class="built_in">console</span>.log(test2); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> test3 = [...new <span class="built_in">Set</span>(test)]</span><br><span class="line"><span class="built_in">console</span>.log(unique(test)) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 <code>Array.prototype.flat</code> 可以直接将多层数组拍平成一层：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="number">2</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>接下来手动模拟 flat 这种效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> pos = list.indexOf(<span class="number">1</span>)</span><br><span class="line">list.splice(pos, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.info(list) <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h1 id="（二）实际应用"><a href="#（二）实际应用" class="headerlink" title="（二）实际应用"></a>（二）实际应用</h1><h2 id="1-判断访谈题目必填项是否为空"><a href="#1-判断访谈题目必填项是否为空" class="headerlink" title="1. 判断访谈题目必填项是否为空"></a>1. 判断访谈题目必填项是否为空</h2><p><code>originalQuestions</code> 数组存放着访谈题目列表（目前共有 18 道），数据格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalQuestions = [	<span class="comment">// 简答题</span></span><br><span class="line">    &#123;</span><br><span class="line">        content: <span class="string">&quot;请简单介绍一下您的经历（包括部门、岗位、司龄、曾任职的公司和岗位等）？&quot;</span>, <span class="comment">// 题目</span></span><br><span class="line">        id: <span class="string">&quot;f9912584095a694c9f9882518c4e9da350b6&quot;</span>, <span class="comment">// 题目ID</span></span><br><span class="line">        choices: [], <span class="comment">// 选项</span></span><br><span class="line">        isShow: <span class="number">1</span>, <span class="comment">// 是否显示（主要用于跳题）</span></span><br><span class="line">        maxChoices: <span class="number">0</span>, <span class="comment">// 最大可选多少个选项</span></span><br><span class="line">        minChoices: <span class="number">0</span>, <span class="comment">// 最少可选多少个选项</span></span><br><span class="line">        number: <span class="number">1</span>, <span class="comment">// 题目序号</span></span><br><span class="line">        required: <span class="literal">true</span>, <span class="comment">// 是否必填</span></span><br><span class="line">        type: <span class="number">2</span>, <span class="comment">// 题型：</span></span><br><span class="line">    &#125;,	<span class="comment">// 判断题	</span></span><br><span class="line">    &#123;</span><br><span class="line">        content: <span class="string">&quot;您是否是部门负责人？&quot;</span>,</span><br><span class="line">        id: <span class="string">&quot;9d5a5f98799b0743d608b7f2eb1d0e338b84&quot;</span>,</span><br><span class="line">        choices: [</span><br><span class="line">            &#123;</span><br><span class="line">                content: <span class="string">&quot;是&quot;</span>,</span><br><span class="line">                id: <span class="string">&quot;1b5366a873ddaf43a08b4fdfef9e133d72d2&quot;</span>,</span><br><span class="line">                isExclude: <span class="number">0</span>,</span><br><span class="line">                jumpNumber: <span class="number">7</span>,</span><br><span class="line">                number: <span class="number">1</span>,</span><br><span class="line">                required: <span class="literal">false</span>,</span><br><span class="line">                type: <span class="number">0</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                content: <span class="string">&quot;否&quot;</span>,</span><br><span class="line">                id: <span class="string">&quot;6c8c368b15998e4798d89f47d35127559631&quot;</span>,</span><br><span class="line">                isExclude: <span class="number">0</span>,</span><br><span class="line">                jumpNumber: <span class="number">8</span>,</span><br><span class="line">                number: <span class="number">2</span>,</span><br><span class="line">                required: <span class="literal">false</span>,</span><br><span class="line">                type: <span class="number">0</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        isShow: <span class="number">1</span>,</span><br><span class="line">        maxChoices: <span class="number">0</span>,</span><br><span class="line">        minChoices: <span class="number">0</span>,</span><br><span class="line">        number: <span class="number">6</span>,</span><br><span class="line">        required: <span class="literal">true</span>,		</span><br><span class="line">        type: <span class="number">0</span>,</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>访谈题目分为两种：一种是简答题，另一种是判断题。在这里需要根据题目的 required 属性来确定题目是否必填。</p><p>通过请求处理得到的响应数据为一个数组，数组当中的每个对象对应着一个用户的访谈填写详情。对象中的前四个属性是用户基本信息，并非用户访谈题目的填写答案，最后五个属性也是如此，只有中间那部分才是用户作答的完整信息，即 <code>list[userIndex][4]</code> 才是用户填写的第一道题的答案。</p><p>另外，用户也并非每道题都有作答。例如，当用户没有作答第二道题，那么对象就不会存在 “5” 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [	&#123;</span><br><span class="line">	    <span class="string">&quot;0&quot;</span>: <span class="string">&quot;肖AA&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;1&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;2&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;3&quot;</span>: <span class="string">&quot;高&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;4&quot;</span>: <span class="number">222</span>,</span><br><span class="line">	    <span class="string">&quot;7&quot;</span>: <span class="number">2222</span>,</span><br><span class="line">	    <span class="string">&quot;9&quot;</span>: <span class="string">&quot;是&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;10&quot;</span>: <span class="number">333</span>,</span><br><span class="line">	    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖AA&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;department&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;job&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;level&quot;</span>: <span class="string">&quot;高&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;_XID&quot;</span>: <span class="string">&quot;row_86&quot;</span></span><br><span class="line">	&#125;,	&#123;</span><br><span class="line">	    <span class="string">&quot;0&quot;</span>: <span class="string">&quot;肖BB&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;1&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;2&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;3&quot;</span>: <span class="string">&quot;高&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;4&quot;</span>: <span class="number">222</span>,</span><br><span class="line">	    <span class="string">&quot;5&quot;</span>: <span class="number">2222</span>,</span><br><span class="line">	    <span class="string">&quot;6&quot;</span>: <span class="number">2222</span>,</span><br><span class="line">	    <span class="string">&quot;7&quot;</span>: <span class="number">2222</span>,</span><br><span class="line">	    <span class="string">&quot;8&quot;</span>: <span class="number">2222</span>,</span><br><span class="line">	    <span class="string">&quot;9&quot;</span>: <span class="string">&quot;是&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;10&quot;</span>: <span class="number">333</span>,</span><br><span class="line">	    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖BB&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;department&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;job&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;level&quot;</span>: <span class="string">&quot;高&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;_XID&quot;</span>: <span class="string">&quot;row_26&quot;</span></span><br><span class="line">	&#125;];</span><br></pre></td></tr></table></figure><p>在这里，我们需要对用户作答情况进行处理，检测是否存在用户没有作答必填项。一旦发现存在，直接返回该用户的 index 以及未作答题目的序号。</p><h3 id="①-检测单个用户"><a href="#①-检测单个用户" class="headerlink" title="① 检测单个用户"></a>① 检测单个用户</h3><p>在这里先只对一个用户对象进行检测，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">&quot;0&quot;</span>: <span class="string">&quot;肖AA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">    <span class="string">&quot;2&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">    <span class="string">&quot;3&quot;</span>: <span class="string">&quot;高&quot;</span>,</span><br><span class="line">    <span class="string">&quot;4&quot;</span>: <span class="number">222</span>,</span><br><span class="line">    <span class="string">&quot;7&quot;</span>: <span class="number">2222</span>,</span><br><span class="line">    <span class="string">&quot;9&quot;</span>: <span class="string">&quot;是&quot;</span>,</span><br><span class="line">    <span class="string">&quot;10&quot;</span>: <span class="number">333</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖AA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;department&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">    <span class="string">&quot;job&quot;</span>: <span class="string">&quot;前端&quot;</span>,</span><br><span class="line">    <span class="string">&quot;level&quot;</span>: <span class="string">&quot;高&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_XID&quot;</span>: <span class="string">&quot;row_86&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于要从用户答案还是题目列表开始遍历，很显然，因为要判断用户有无漏答题目，所以应从 originalQuestions 开始。</p><h4 id="第一版（-forEach-实现）"><a href="#第一版（-forEach-实现）" class="headerlink" title="第一版（ forEach 实现）"></a>第一版（ <code>forEach</code> 实现）</h4><p><strong>实现思路</strong></p><p>通过 <code>forEach</code> 来遍历题目列表，当题目的 required 为 true 且用户对应题目的作答情况为空时，则标记好信息后直接 return 跳出循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isFalse = <span class="literal">false</span>; <span class="comment">// 用户是否没有作答必填题</span></span><br><span class="line"><span class="keyword">var</span> pos = -<span class="number">1</span>; <span class="comment">// 用户未作答题目的序号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一版检测函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determine0</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    originalQuestions.forEach(<span class="function">(<span class="params">item, index</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(item.required &amp;&amp; !obj[<span class="built_in">String</span>(index + <span class="number">4</span>)]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.isFalse = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.pos = index;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`pos:<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">determine0(obj);</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pos:1</span><br><span class="line">pos:2</span><br><span class="line">pos:4</span><br><span class="line">pos:7</span><br><span class="line">pos:8</span><br></pre></td></tr></table></figure><p><strong>存在缺陷</strong></p><ul><li>打印输出多次，这说明 return 并没有跳出循环。查阅资料后发现，<code>forEach</code> 循环不能被 return 终止，其作用和 for 循环中的 continue 相似，只是跳出当前循环，并继续执行之后的循环。同样，在 <code>forEach</code> 中也不能使用 break、continue 来跳出循环。</li></ul><h4 id="第二版（-findIndex-实现）"><a href="#第二版（-findIndex-实现）" class="headerlink" title="第二版（ findIndex 实现）"></a>第二版（ <code>findIndex</code> 实现）</h4><p><strong>实现思路</strong></p><p>数组的 <code>findIndex</code> 方法会根据 return 返回的条件进行遍历查找，一旦发现数组中有匹配的元素，就直接返回该元素的 index。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版检测函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determine1</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.pos = originalQuestions.findIndex(<span class="function">(<span class="params">item, index</span>)=&gt;</span> &#123;		</span><br><span class="line">        <span class="keyword">if</span>(item.required &amp;&amp; !obj[<span class="built_in">String</span>(index + <span class="number">4</span>)]) &#123;			</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`pos:<span class="subst">$&#123;index&#125;</span>`</span>);		</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item.required &amp;&amp; !obj[<span class="built_in">String</span>(index + <span class="number">4</span>)];</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.pos !== -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.isFalse = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">determine1(obj);</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pos:1</span><br></pre></td></tr></table></figure><h3 id="②-检测所有用户"><a href="#②-检测所有用户" class="headerlink" title="② 检测所有用户"></a>② 检测所有用户</h3><p>当检测所有用户时，所需要采用的策略与检测单个用户时大有不同。仍旧是先遍历谁的问题，这次该从用户列表还是从题目列表开始遍历？这里采用的是，先从题目列表中遍历。当抽出一道题时，再从用户列表中依次抽取用户来比对是否作答该题目。</p><h4 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础<strong>版</strong></h4><p><strong>实现思路</strong></p><p>因为要对所有用户依次进行题目列表的遍历，但真正需要遍历的题目只有必选题，所以为了提高效率，需要先通过数组的 filter 方法把题目列表筛选成只含有必答题的题目列表。</p><p>得到精简后的题目列表后，通过使用数组的 some 方法来判断是否存在用户未作答题目。当存在时，some 方法的返回结果为 true，否则返回 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> row = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> column = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determineAll0</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newQuestions = questions.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.required);</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> newQuestions.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(a=<span class="number">0</span>; a&lt;list.length; a++) &#123;</span><br><span class="line">            result = list[a][<span class="built_in">String</span>(item.number + <span class="number">4</span>)];</span><br><span class="line">            <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">                <span class="built_in">this</span>.row = a;</span><br><span class="line">                <span class="built_in">this</span>.column = item.number;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`row: <span class="subst">$&#123;<span class="built_in">this</span>.row&#125;</span>, col:<span class="subst">$&#123;<span class="built_in">this</span>.column&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> !result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)   </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.isFalse = determineAll0(originalList); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row: 0, col:1</span><br></pre></td></tr></table></figure><p><strong>存在缺陷</strong></p><ul><li>不够精简</li></ul><h4 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h4><p>基础的 for 循环操作有些繁琐，数组的 filter 和 some 方法可以合并。对代码进行简化如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determineAll1</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> questions.filter(<span class="function"><span class="params">f</span> =&gt;</span> f.required).some(<span class="function"><span class="params">question</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.column = question.number</span><br><span class="line">		<span class="built_in">this</span>.row = list.findIndex(<span class="function"><span class="params">user</span> =&gt;</span> !user[<span class="built_in">String</span>(question.number + <span class="number">4</span>)]) </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.row !== -<span class="number">1</span>;	</span><br><span class="line">    &#125;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="娱乐版"><a href="#娱乐版" class="headerlink" title="娱乐版"></a>娱乐版</h4><p>经过试验，最后将代码化简至 3 行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 娱乐版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determineAll2</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> questions.filter(<span class="function"><span class="params">f</span> =&gt;</span> f.required).some(<span class="function"><span class="params">s</span> =&gt;</span>(<span class="built_in">this</span>.row = list.findIndex(<span class="function"><span class="params">i</span> =&gt;</span> !i[(<span class="built_in">this</span>.column = s.number) + <span class="number">4</span>])) + <span class="number">1</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){const e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">mohui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">389k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">5:54</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>