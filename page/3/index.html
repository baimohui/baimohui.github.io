<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"baimohui.github.io",root:"/",images:"/images",scheme:"Muse",version:"8.2.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12},copycode:!1,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"}}</script><meta property="og:type" content="website"><meta property="og:title" content="白抹灰"><meta property="og:url" content="https://baimohui.github.io/page/3/index.html"><meta property="og:site_name" content="白抹灰"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="mohui"><meta property="article:tag" content="前端,JavaScript,html5,css3,Vue"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://baimohui.github.io/page/3/"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>白抹灰</title><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">白抹灰</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">mohui</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">50</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%89%8D%E7%AB%AF%E9%89%B4%E6%9D%83/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%89%8D%E7%AB%AF%E9%89%B4%E6%9D%83/" class="post-title-link" itemprop="url">前端鉴权</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:34:50" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">前端安全</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>23k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>21 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>这里先阐述一些前置概念。</p><ul><li>Authentication：身份鉴别，以下简称认证</li><li>Authorisation：授权</li><li>Authorization Server / Identity Provider(IdP)：认证服务器</li><li>Service Provider(SP) / Resource Server：业务服务器，负责提供资源（API 调用）</li></ul><p><strong>认证</strong>的作用在于认可你有权限访问系统，用于鉴别访问者是否是合法用户；而<strong>授权</strong>用于决定你有访问哪些资源的权限。大多数人站在用户的立场上不会区分这两者的区别。而作为系统的设计者来说，这两者是有差别的，分属于不同的工作职责，我们可以只需要认证功能，而不需要授权功能，甚至不需要自己实现认证功能，而借助 Google 的认证系统，即用户可以用 Google 的账号进行登陆。</p><div class="post-button"><a class="btn" href="/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%89%8D%E7%AB%AF%E9%89%B4%E6%9D%83/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">前端安全</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:34:13" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">前端安全</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>12k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>11 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文主要讨论了常见的加密算法和网络攻击。</p><div class="post-button"><a class="btn" href="/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8/PWA%20%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%B5%8F%E8%A7%88%E5%99%A8/PWA%20%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">PWA 详解</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:37:00" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>12 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="1-PWA-概述"><a href="#1-PWA-概述" class="headerlink" title="1. PWA 概述"></a>1. PWA 概述</h3><p>PWA（Progressive Web Application，渐进式网页应用） 不是特指某一项技术，而是应用了多项技术的 <code>Web App</code>。其核心技术包括 <code>App Manifest</code>、<code>Service Worker</code>、<code>Web Push</code>等。自 2015 年以来，<code>PWA</code> 相关的技术不断升级优化，在用户体验和用户留存两方面都提供了非常好的解决方案。<code>PWA</code> 可以将 <code>Web</code> 和 <code>App</code> 各自的优势融合在一起：渐进式、可响应、可离线、实现类似 <code>App</code> 的交互、即时更新、安全、可以被搜索引擎检索、可推送、可安装、可链接。</p><div class="post-button"><a class="btn" href="/%E6%B5%8F%E8%A7%88%E5%99%A8/PWA%20%E8%AF%A6%E8%A7%A3/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8/HTTP%20%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%B5%8F%E8%A7%88%E5%99%A8/HTTP%20%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">HTTP 详解</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-12 23:37:17" itemprop="dateModified" datetime="2022-02-12T23:37:17+08:00">2022-02-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>16k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>15 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="（一）HTTP-简介"><a href="#（一）HTTP-简介" class="headerlink" title="（一）HTTP 简介"></a>（一）HTTP 简介</h2><p>HTTP（Hyper Text Transfer Protocol，超文本传输协议）是用于从万维网（WWW，World Wide Web ）服务器传输超文本到本地浏览器的传送协议。HTTP 基于 TCP/IP 通信协议来传递数据（HTML 文件、图片文件、查询结果等）。</p><p>HTTP 是一个属于应用层的面向对象的协议，由于其简洁快速的方式，适用于分布式超媒体信息系统。HTTP 协议工作于客户端-服务端架构上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求，Web 服务器根据接收到的请求向客户端发送响应信息。</p><div class="post-button"><a class="btn" href="/%E6%B5%8F%E8%A7%88%E5%99%A8/HTTP%20%E8%AF%A6%E8%A7%A3/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E6%A1%86%E6%9E%B6/Vue/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E4%B8%8E%E6%B8%B2%E6%9F%93/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%A1%86%E6%9E%B6/Vue/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E4%B8%8E%E6%B8%B2%E6%9F%93/" class="post-title-link" itemprop="url">Vue 模板编译与渲染</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-16 19:27:42" itemprop="dateModified" datetime="2022-02-16T19:27:42+08:00">2022-02-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>12 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vue = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>vue-cli</code> 配置齐全，大家也都习惯于使用 <code>vue-cli</code> 开发，因此可能会忽略了入口文件中 Vue 实例是怎么去 new 的，以及 <code>#app</code> 元素是怎么渲染到页面的。</p><div class="post-button"><a class="btn" href="/%E6%A1%86%E6%9E%B6/Vue/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E4%B8%8E%E6%B8%B2%E6%9F%93/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E6%A1%86%E6%9E%B6/Vue/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%A1%86%E6%9E%B6/Vue/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Vue 响应式原理</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-16 21:39:54" itemprop="dateModified" datetime="2022-02-16T21:39:54+08:00">2022-02-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>12k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>11 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>只要涉及到 MVVM 框架就不得不提到双向绑定，毕竟它是 Vue 的三要素之一。</p><ul><li>响应式：例如如何监听数据变化，其中的实现方法就是双向绑定</li><li>模板引擎：如何解析模板</li><li>渲染：Vue 如何将监听到的数据变化和解析后的 HTML 进行渲染</li></ul><div class="post-button"><a class="btn" href="/%E6%A1%86%E6%9E%B6/Vue/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E6%A1%86%E6%9E%B6/Vue/Vue%20%E5%9F%BA%E7%A1%80/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%A1%86%E6%9E%B6/Vue/Vue%20%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Vue 基础</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:46:40" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>14k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>12 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h2 id="（一）MVVM-模式"><a href="#（一）MVVM-模式" class="headerlink" title="（一）MVVM 模式"></a>（一）MVVM 模式</h2><h3 id="1-MVVM-是什么"><a href="#1-MVVM-是什么" class="headerlink" title="1. MVVM 是什么"></a>1. MVVM 是什么</h3><p>MVVM 模式，顾名思义即 Model-View-ViewModel 模式。它萌芽于2005年微软推出的基于 Windows 的用户界面框架 WPF ，前端最早的 MVVM 框架 knockout 在 2010 年发布。</p><ul><li><strong>Model 层</strong>： 对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model。</li><li><strong>View 层</strong>：作为视图模板存在，在 MVVM 里，整个 View 是⼀个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是数据绑定的声明、 指令的声明、 事件绑定的声明。</li><li><strong>ViewModel 层</strong>：把 View 需要的层数据暴露，并对 View 层的数据绑定声明、 指令声明、 事件绑定声明负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。⼀旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。</li></ul><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174612.png" alt="image-20210326141639536" style="zoom:67%"> <img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174619.png" alt="01-计数器的MVVM" style="zoom:80%"><h3 id="2-MVVM-优越点"><a href="#2-MVVM-优越点" class="headerlink" title="2. MVVM 优越点"></a>2. MVVM 优越点</h3><p><strong>优点:</strong></p><ol><li><p>分离视图和模型，降低代码耦合，提高视图或者逻辑的重用性；</p><p>比如 View 可以独立于 Model 变化和修改，⼀个 ViewModel 可以绑定在不同的 View 上，当 View 变化时 Model 可以不变，当 Model 变化时 View 也可以不变。你可以把⼀些视图逻辑放在⼀个 ViewModel 里面，让很多 view 重用这段视图逻辑 。</p></li><li><p>提高可测试性：ViewModel 的存在可以帮助开发者更好地编写测试代码 ；</p></li><li><p>自动更新 dom：利用双向绑定，数据更新后视图自动更新，让开发者从繁琐的手动 dom 中解放 。</p></li></ol><p><strong>缺点:</strong></p><ol><li>Bug 很难被调试：因为使用双向绑定的模式，当你看到界面异常了，有可能是 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方并不容易。另外，数据绑定的声明是指令式地写在 View 的模版当中的，这些内容是没办法去打断点 debug 的；</li><li>⼀个大的模块中 model 也会很大，虽然使用方便且容易保证数据的⼀致性，但是长期持有，不释放内存就造成了更多内存的浪费；</li><li>对于大型的图形应用程序，视图状态较多，ViewModel 的构建和维护的成本都会比较高。</li></ol><h2 id="（二）VUE-生命周期"><a href="#（二）VUE-生命周期" class="headerlink" title="（二）VUE 生命周期"></a>（二）VUE 生命周期</h2><p>详情可点击：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6874855535234170887">https://juejin.cn/post/6874855535234170887</a></p><h3 id="1-创建阶段"><a href="#1-创建阶段" class="headerlink" title="1. 创建阶段"></a>1. 创建阶段</h3><p>创建阶段可以看做一个 vue 实例生命的开始，可以把这一阶段比作组件从受精卵到胚胎的过程，这个阶段 vue 组件开始初始化，vue 开始观察数据，这个阶段有 beforeCreate 和 created 两个生命周期钩子函数。</p><p><strong>beforeCreate</strong></p><p><code>beforeCreate</code>：是 <code>new Vue()</code> 之后触发的第一个钩子，此时 data、methods、computed 以及 watch 上的数据和方法还未初始化，都不能被访问。</p><p><strong>created</strong></p><p><code>created</code>：在实例创建完成后被立即调用，此时已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，即真实 DOM 还没有生成，$el property 目前尚不可用。在这里可以使用并更改数据，对数据的更改不会触发 updated 函数。</p><p>可以做什么：</p><ul><li>data 和 methods 都已经初始化好了，如果要<strong>调用 methods 中的方法，或者操作 data 中的数据</strong>，最早可以在此阶段中操作。</li><li><strong>无法与 Dom 进行交互</strong>，如果非要想，可以通过 <code>vm.$nextTick</code> 来访问 Dom。</li><li><strong>异步数据的请求适合在 created 的钩子中使用</strong>，例如数据初始化。</li></ul><h3 id="2-挂载阶段"><a href="#2-挂载阶段" class="headerlink" title="2. 挂载阶段"></a>2. 挂载阶段</h3><p>这个阶段是 vue 实例的出生阶段，这个阶段将实现 DOM 的挂载，这标志着我们<strong>可以在浏览器里中看到页面</strong>了。</p><p><strong>beforeMount</strong></p><p><code>beforeMount</code>：发生在挂载之前，在这之前 template 模板已导入 render 渲染函数编译。此时虚拟 Dom 已经创建完成，即将开始渲染。在这一阶段也可以对数据进行更改，不会触发 updated。</p><p><strong>mounted</strong></p><p><code>mounted</code>：在挂载完成后发生，此时真实的 Dom 挂载完毕，数据完成双向绑定，<strong>可以访问到 Dom 节点，使用 $refs 属性对 Dom 进行操作</strong>。</p><p>mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 <code>vm.$nextTick</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-运行阶段"><a href="#3-运行阶段" class="headerlink" title="3. 运行阶段"></a>3. 运行阶段</h3><p>vue 实例不可能一直保持不变，当 vue 实例中的数据发生改变时，DOM 也会发生变化。</p><p><strong>beforeUpdate</strong></p><p><code>beforeUpdate</code>：发生在更新之前，即响应式数据发生更新，虚拟 dom 重新渲染之前被触发，在当前阶段对数据的更改不会造成重新渲染，但会再次触发当前钩子函数。</p><p><strong>updated</strong></p><p><code>updated</code>：发生在更新完成之后，此时 Dom 已经更新。现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，最好使用计算属性或 watcher 取而代之。最好不要在此期间更改数据，因为这可能会导致无限循环的更新。</p><p>updated 不会保证所有的子组件也都一起被重绘。如果希望等到整个视图都重绘完毕，可以在 updated 里使用 <code>vm.$nextTick</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">updated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been re-rendered（代码将在整个视图重新渲染后执行）</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-销毁阶段"><a href="#4-销毁阶段" class="headerlink" title="4. 销毁阶段"></a>4. 销毁阶段</h3><p>vue 实例的消亡阶段。实例还可以被使用，直到 <code>destroyed()</code>，我们可以最后做一些想做的事情。</p><p><strong>beforeDestroy</strong></p><p><code>beforeDestroy</code>：发生在实例销毁之前，在这期间实例完全可以被使用。此阶段适合进行善后收尾工作，比如清除计时器。</p><p><strong>destroyed</strong></p><p><code>destroyed</code>：发生在实例销毁之后，这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，事件监听器被移除，所有子实例也统统被销毁。</p><p>在大多数场景中你不应该调用这个方法。最好使用 v-if 和 v-for 指令以数据驱动的方式控制子组件的生命周期。</p><h2 id="（三）Vue-组件通信"><a href="#（三）Vue-组件通信" class="headerlink" title="（三）Vue 组件通信"></a>（三）Vue 组件通信</h2><h3 id="1-props-emit"><a href="#1-props-emit" class="headerlink" title="1. props / $emit"></a>1. props / $emit</h3><p><strong>父组件向子组件传值</strong></p><p>prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。下面通过一个例子说明父组件如何向子组件传递数据：在子组件 <code>article.vue</code> 中如何获取父组件 <code>section.vue</code> 中的数据 <code>articles:[&#39;红楼梦&#39;, &#39;西游记&#39;,&#39;三国演义&#39;]</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--section父组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;section&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com-article</span> <span class="attr">:articles</span>=<span class="string">&quot;articleList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">com-article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> comArticle <span class="keyword">from</span> <span class="string">&#x27;./test/article.vue&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span></span><br><span class="line">  components: &#123; comArticle &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      articleList: [<span class="string">&#x27;红楼梦&#x27;</span>, <span class="string">&#x27;西游记&#x27;</span>, <span class="string">&#x27;三国演义&#x27;</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--子组件 article.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in articles&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  props: [<span class="string">&#x27;articles&#x27;</span>]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>子组件向父组件传值</strong></p><p><code>$emit</code> 绑定一个自定义事件，当这个语句被执行时，就会将参数 arg 传递给父组件，父组件通过 v-on 监听并接收参数。在上个例子的基础上，点击页面渲染出来的 <code>ariticle</code> 的 <code>item</code>，父组件中显示在数组中的下标。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 父组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;section&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意，这里触发的方法没有带括号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com-article</span> <span class="attr">:articles</span>=<span class="string">&quot;articleList&quot;</span> @<span class="attr">onEmitIndex</span>=<span class="string">&quot;onEmitIndex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">com-article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;currentIndex&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> comArticle <span class="keyword">from</span> <span class="string">&#x27;./test/article.vue&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span></span><br><span class="line">  components: &#123; comArticle &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      currentIndex: -1,</span><br><span class="line"><span class="javascript">      articleList: [<span class="string">&#x27;红楼梦&#x27;</span>, <span class="string">&#x27;西游记&#x27;</span>, <span class="string">&#x27;三国演义&#x27;</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">onEmitIndex</span>(<span class="params">idx</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.currentIndex = idx</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--子组件中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in articles&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;emitIndex(index)&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  props: [<span class="string">&#x27;articles&#x27;</span>],</span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">emitIndex</span>(<span class="params">index</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;onEmitIndex&#x27;</span>, index)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-eventBus"><a href="#2-eventBus" class="headerlink" title="2. eventBus"></a>2. eventBus</h3><p><code>eventBus</code> 又称为事件总线，在 vue 中相当于所有组件共用的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。当项目较大时，eventBus 容易导致难以维护。其使用方法如下：</p><p><strong>① 初始化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><p><strong>② 发送事件</strong></p><p>假设你有两个组件: <code>additionNum</code> 和 <code>showNum</code>，这两个组件可以是兄弟组件也可以是父子组件；这里我们以兄弟组件为例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">show-num-com</span>&gt;</span><span class="tag">&lt;/<span class="name">show-num-com</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">addition-num-com</span>&gt;</span><span class="tag">&lt;/<span class="name">addition-num-com</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> showNumCom <span class="keyword">from</span> <span class="string">&#x27;./showNum.vue&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> additionNumCom <span class="keyword">from</span> <span class="string">&#x27;./additionNum.vue&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123; showNumCom, additionNumCom &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--addtionNum.vue 中发送事件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;additionHandle&quot;</span>&gt;</span>+加法器<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;EventBus&#125; <span class="keyword">from</span> <span class="string">&#x27;./event-bus.js&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(EventBus)</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span>&#123;</span></span><br><span class="line">      num:1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods:&#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">additionHandle</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      EventBus.$emit(<span class="string">&#x27;addition&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">        num:<span class="built_in">this</span>.num++</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③ 接收事件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// showNum.vue 中接收事件</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>计算和: &#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; EventBus &#125; <span class="keyword">from</span> <span class="string">&#x27;./event-bus.js&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    EventBus.$on(<span class="string">&#x27;addition&#x27;</span>, <span class="function"><span class="params">param</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.count = <span class="built_in">this</span>.count + param.num;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>④ 移除事件监听</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; eventBus &#125; <span class="keyword">from</span> <span class="string">&#x27;event-bus.js&#x27;</span></span><br><span class="line">EventBus.$off(<span class="string">&#x27;addition&#x27;</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-Vuex"><a href="#3-Vuex" class="headerlink" title="3. Vuex"></a>3. Vuex</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 解决了<strong>多个视图依赖于同一状态</strong>和<strong>来自不同视图的行为需要变更同一状态</strong>的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上。</p><p><strong>Vuex 各个模块</strong></p><ul><li><code>state</code>：用于数据的存储，是 store 中的唯一数据源</li><li><code>getters</code>：如 vue 中的计算属性一样，基于 state 数据的二次包装，常用于数据的筛选和多个数据的相关性计算</li><li><code>mutations</code>：类似函数，改变 state 数据的唯一途径，且不能用于处理异步事件</li><li><code>actions</code>：类似于 <code>mutation</code>，用于提交 <code>mutation</code> 来改变状态，而不直接变更状态，可以包含任意异步操作</li><li><code>modules</code>：类似命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ChildA</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ChildB</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> ChildA <span class="keyword">from</span> <span class="string">&#x27;./components/ChildA&#x27;</span> <span class="comment">// 导入A组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> ChildB <span class="keyword">from</span> <span class="string">&#x27;./components/ChildB&#x27;</span> <span class="comment">// 导入B组件</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    components: &#123;ChildA, ChildB&#125; <span class="comment">// 注册A、B组件</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--子组件childA--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;childA&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是A组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;transform&quot;</span>&gt;</span>点我让B组件接收到数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>因为你点了B，所以我的信息发生了变化：&#123;&#123;BMessage&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        AMessage: <span class="string">&#x27;Hello，B组件，我是A组件&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">BMessage</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这里存储从store里获取的B组件的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.BMsg</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">transform</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 触发receiveAMsg，将A组件的数据存放到store里去</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;receiveAMsg&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">          AMsg: <span class="built_in">this</span>.AMessage</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--子组件 childB--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;childB&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是B组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;transform&quot;</span>&gt;</span>点我让A组件接收到数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>因为你点了A，所以我的信息发生了变化：&#123;&#123;AMessage&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        BMessage: <span class="string">&#x27;Hello，A组件，我是B组件&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">AMessage</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这里存储从store里获取的A组件的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.AMsg</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">transform</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 触发receiveBMsg，将B组件的数据存放到store里去</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;receiveBMsg&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">          BMsg: <span class="built_in">this</span>.BMessage</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vuex的store.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="comment">// 初始化A和B组件的数据，等待获取</span></span><br><span class="line">  AMsg: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  BMsg: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="function"><span class="title">receiveAMsg</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将A组件的数据存放于state</span></span><br><span class="line">    state.AMsg = payload.AMsg</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">receiveBMsg</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将B组件的数据存放于state</span></span><br><span class="line">    state.BMsg = payload.BMsg</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-ref-refs"><a href="#4-ref-refs" class="headerlink" title="4. ref / $refs"></a>4. ref / $refs</h3><p><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个 <code>ref</code> 来访问组件的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件 A.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">&#x27;Vue.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件 app.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component-a ref=<span class="string">&quot;comA&quot;</span>&gt;&lt;/component-a&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      <span class="keyword">const</span> comA = <span class="built_in">this</span>.$refs.comA;</span><br><span class="line">      <span class="built_in">console</span>.log(comA.name);  <span class="comment">// Vue.js</span></span><br><span class="line">      comA.sayHello();  <span class="comment">// hello</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="（四）计算属性与监测"><a href="#（四）计算属性与监测" class="headerlink" title="（四）计算属性与监测"></a>（四）计算属性与监测</h2><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><ul><li>computed 是计算属性，也就是计算值，适用于计算比较消耗性能的计算场景</li><li>computed 具有缓存性，computed 的值在 getter 执行后是会缓存的，只有在它依赖的属性值改变之后，下⼀次获取 computed的值时才会重新调用对应的 getter 来计算</li></ul><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul><li>更多的是「观察」的作用，类似于某些数据的监听回调，用于观察和回调进行后续操作</li><li>无缓存性，页面重新渲染时值不变化也会执行或者本组件的值</li></ul><p><strong>小结</strong></p><ul><li>当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为 computed</li><li>如果你需要在某个数据变化时做⼀些事情，使用 watch 来观察这个数据变化</li></ul><h2 id="（六）v-if-和-v-show"><a href="#（六）v-if-和-v-show" class="headerlink" title="（六）v-if  和 v-show"></a>（六）v-if 和 v-show</h2><p>在切换 <strong>v-if</strong> 块时，Vue.js 有一个局部编译/卸载过程，因为 <strong>v-if</strong> 之中的模板也可能包括数据绑定或子组件。<strong>v-if</strong> 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。</p><p><strong>v-if</strong> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。</p><p>相比之下，<strong>v-show</strong> 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。</p><p>一般来说，<strong>v-if</strong> 有更高的切换消耗而 <strong>v-show</strong> 有更高的初始渲染消耗。因此，如果需要频繁切换 <strong>v-show</strong> 较好，如果在运行时条件不大可能改变 <strong>v-if</strong> 较好。</p><p>v-if 绝对是更消耗性能的，因为 v-if 在显示隐藏过程中有 DOM 的添加和删除，v-show 就简单多了，只是操作 css。</p><h2 id="（七）VUE-路由实现登录验证"><a href="#（七）VUE-路由实现登录验证" class="headerlink" title="（七）VUE 路由实现登录验证"></a>（七）VUE 路由实现登录验证</h2><p>在开发 webApp 的时候，考虑到用户体验，经常会把不需要调用个人数据的页面设置成游客可以访问，而当用户进入到一些需要个人数据的，例如购物车，个人中心，我的钱包等等，在进行登录的验证判断，如果判断已经登录，则显示页面，如果判断未登录，则直接跳转到登录页面提示用户登录，今天就来分享下如何使用 vue-router 的 beforEach 方法来实现这个需求。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>本篇文章默认您已经会使用<code>webpack</code>或者<code>vue-cli</code>来进行环境的搭建，并且具有一定的vue基础，如果您目前是一个新手，那么网上搜索一下就好，相关文章非常多，这里就不再赘述了。 话不多说，直接上代码。 为了方便日后代码的可维护性，我把相关方法写在了一个新建的filter.js文件里</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/21/164218da430c958a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>接下来进入filter.js文件中，首先引入vue-router：<code>import router from &quot;./router&quot;;</code>然后我们使用<code>router.beforEach</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//根据字段判断是否路由过滤</span></span><br><span class="line">    <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">record</span> =&gt;</span> record.meta.auth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getToken() !== <span class="literal">null</span>) &#123;</span><br><span class="line">            next()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//防止无限循环</span></span><br><span class="line">            <span class="keyword">if</span> (to.name === <span class="string">&#x27;login&#x27;</span>) &#123;</span><br><span class="line">                next();</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            next(&#123;</span><br><span class="line">                path: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next()<span class="comment">//若点击的是不需要验证的页面,则进行正常的路由跳转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>beforEach 其实是 vur-router 的钩子函数，可以理解为每个 router 跳转之前都会调用的一个方法，既然有before同理当然也有 afterEach，这个我们以后再讲。</p><p>首先来解释下 beforEach 的三个参数：</p><ol><li>to：router 即将进入的路由对象。</li><li>from：当前导航正要离开的路由。</li><li>next：一个 function，一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</li></ol><ul><li><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。</li><li><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。</li><li><strong>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</strong> 你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项，注意，next 可以通过 query 传递参数。</li><li><code>next(error)</code>: (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>好了，看到这里可能有些人还是没有理解，没关系，接下来我举个例子就可以明白了。<br>假设我们目前有三个路由：<code>/home，/mine，/login</code><br>我们初始进入为<code>/home</code>，这时候点击跳转<code>/mine</code>，但是由于我们没有登录，所以会自动跳转到<code>/login</code><br>在以上这种情况下，<br>to：代表着路由<code>/mine</code>，我们要进入的路由。<br>from：代表着路由<code>/home</code>，我们将要离开的路由。<br>注意，使用beforEach最后必须要调用<code>next()</code>，否则会报错，如果不传参数，我们就会成功进入到<code>/mine</code>，如果我们传递参数，例如<code>next(&#39;/login&#39;)</code>，那么我们在点击任何路由都会跳转到<code>/login</code>界面。<br>但是我们的需求是只有点击需要进行登录验证的页面才进行拦截跳转，因此，我们需要加一些判断条件来进行路由的筛选。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">record</span> =&gt;</span> record.meta.auth)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getToken() !== <span class="literal">null</span>) &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 to 就是上面讲的参数 to，<code>to.matched</code>是一个对象数组，里面有 to 指向路由的相关信息，例如：path，name，meta等等。<br>我们用该数组调用some()方法根据返回值<code>true</code>或者<code>false</code>来进行判断，所以我们要在router.js路由配置文件中为我们需要验证登录判断跳转的路由添加一个字段来作为判断条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path: &#39;&#x2F;mine&#39;,</span><br><span class="line">name: &#39;mine&#39;,</span><br><span class="line">component: mine,</span><br><span class="line">meta:&#123;auth:true&#125;  &#x2F;&#x2F;我们自己添加的字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于给路由添加了<code>meta:&#123;auth:true&#125;</code>，所以我们的<code>to.matched.some(record =&gt; record.meta.auth)</code>会返回<code>true</code>，这时我们就可以做登录判断了，我的项目是通过把token存入到<code>localstorage</code>来进行判断的， getToken()是我封装的一个获取<code>localstorage</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getToken() !== <span class="literal">null</span>) &#123;</span><br><span class="line">    next() <span class="comment">//若token不为null，则进行路由跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有token，我们下一步继续进行判断，也就是最终目的，进行路由拦截，跳转到登录页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    next(&#123;</span><br><span class="line">        path: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这时候我们会遇到新的问题，打开控制台会发现路由会无限的循环并最终崩溃，这是什么原因呢？仔细阅读上文红色加粗，我们可以理解为</p><ul><li><code>next()</code> 表示路由成功，直接进入to路由，不会再次调用router.beforeEach()</li><li><code>next(&#123; path: &#39;/login&#39;, &#125;);</code> 表示路由拦截成功，重定向至login，会再次调用router.beforeEach()</li></ul><p>也就是说beforeEach()必须调用next()，否则就会出现无限循环<br>next() 和 next(‘xxx’) 是不一样的，区别就是前者不会再次调用router.beforeEach()，后者会。而由于我们没有token，所以在重新调用router.beforeEach()后，会再次进入到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    next(&#123;</span><br><span class="line">        path: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以造成了无限循环，解决这个问题的方法也很简单，我们在<code>next(&#123; path: &#39;/login&#39;, &#125;);</code>之前增加一个判断条件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (to.name === <span class="string">&#x27;login&#x27;</span>) &#123;</span><br><span class="line">    next();</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们to的定向路由<code>name == &#39;login&#39;</code>,则执行<code>next();</code>并return终止代码运行。</p><p>以上就是通过router.beforEach方法进行路由拦截了，我们不仅仅可以只做登录判断，通过这个方法可以实现很多需求，只要是有关路由跳转的都可以，在下只是抛砖引玉，如果有哪里不对的地方或者有更好的方法可以直接在评论告诉我，非常感谢。</p><p><strong>tips</strong></p><p>2018.7.2<br>由于实际项目中很多界面都需要进行token的验证拦截,因此考虑后决定把过滤的方法设置在axios拦截器的<code>http response 拦截器</code>里,根据后端返回的错误码来判断是token过期或者无效之类的错误来进行跳转到登录页面。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E6%A1%86%E6%9E%B6/Vue/diff%20%E7%AE%97%E6%B3%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E6%A1%86%E6%9E%B6/Vue/diff%20%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">diff 算法详解</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:45:28" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>渲染真实 DOM 的开销是很大的。有时修改某个数据，如果直接渲染到真实 dom 上会引起整个 dom 树的重绘和重排。而 diff 算法可以只更新修改的那一小块 dom，而非更新整个 dom。</p><div class="post-button"><a class="btn" href="/%E6%A1%86%E6%9E%B6/Vue/diff%20%E7%AE%97%E6%B3%95/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9/" class="post-title-link" itemprop="url">移动端兼容</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25 / 修改时间：17:47:40" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/" itemprop="url" rel="index"><span itemprop="name">兼容适配</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>19k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>17 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h2 id="（一）响应式界面"><a href="#（一）响应式界面" class="headerlink" title="（一）响应式界面"></a>（一）响应式界面</h2><h3 id="1-什么是响应式设计"><a href="#1-什么是响应式设计" class="headerlink" title="1. 什么是响应式设计"></a>1. 什么是响应式设计</h3><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20976405">响应式布局</a></p><p>响应式界面能够适应不同的设备。描述响应式界面最著名的一句话就是“Content is like water”，翻译成中文便是“如果将屏幕看作容器，那么内容就像水一样”。</p><h3 id="2-响应式界面的四个层次"><a href="#2-响应式界面的四个层次" class="headerlink" title="2. 响应式界面的四个层次"></a>2. 响应式界面的四个层次</h3><ul><li>同一页面在不同大小和比例上看起来都应该是舒适的；</li><li>同一页面在不同分辨率上看起来都应该是合理;</li><li>同一页面在不同操作方式（如鼠标和触屏）下，体验应该是统一的；</li><li>同一页面在不同类型的设备（手机、平板、电脑）上，交互方式应该是符合习惯的。</li></ul><h3 id="3-响应式界面的基本规则"><a href="#3-响应式界面的基本规则" class="headerlink" title="3. 响应式界面的基本规则"></a>3. 响应式界面的基本规则</h3><p>① <strong>可伸缩的内容区块</strong>：内容区块在一定程度上能够自动调整，以确保填满整个页面</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174657.png" alt="image-20210327123558579" style="zoom:50%"><p>② <strong>适应页面尺寸的边距</strong>：到页面尺寸发生更大变化时，区块的边距也应该变化</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174658.png" alt="image-20210327123935190" style="zoom:50%"><p>③ <strong>能够适应比例变化的图片</strong>：对于常见的宽度调整，图片在隐去两侧部分时，依旧保持美观可用</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174659.png" alt="image-20210327124052768" style="zoom:50%"><p>④ <strong>能够自动隐藏/部分显示的内容</strong>：如在电脑上显示的的大段描述文本，在手机上就只能少量显示或全部隐藏</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174700.png" alt="image-20210327124148764" style="zoom:50%"><p>⑤ <strong>能自动折叠的导航和菜单</strong>：展开还是收起，应该根据页面尺寸来判断</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174701.png" alt="image-20210327124310687" style="zoom:50%"><p>⑥ 放弃使用像素作为尺寸单位：用dp(对于前端来说，这里可能是rem)尺寸等方法来确保页面在分辨率相差很大的设备上，看起来也能保持一致。同时也要求提供的图片应该比预想的更大，才能适应高分辨率的屏幕</p><p>简单总结起来，可以概括为：</p><ul><li>媒体查询，边界断点的规则设定（Media queries &amp;&amp; break point）</li><li>内容的可伸缩性效果（Flexible visuals）</li><li>流式网格布局(Fluid grids)</li><li>主要内容呈现及图片的高质量(Main content and high quality)</li></ul><h3 id="4-响应式与自适应"><a href="#4-响应式与自适应" class="headerlink" title="4. 响应式与自适应"></a>4. 响应式与自适应</h3><p>响应式设计是 Responsive Web Design（RWD），自适应设计是 Adaptive Web Design（AWD）。RWD 和 AWD 两者都是为了适配各种不同的移动设备，致力于提升用户体验所产生的的技术。核心思想是用技术来使网页适应从小到大（现在到超大）的不同分辨率的屏幕。<strong>通常认为，RWD 是 AWD 的子集</strong>。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174702.png" alt="image-20210327124723911" style="zoom:50%"><p>从定义上而言，RWD 是一套代码，适用于所有屏幕。而 AWD 则是多端多套代码。两者的本质都是致力于适配不同设备，更好地提升用户体验。</p><h2 id="（二）分辨率"><a href="#（二）分辨率" class="headerlink" title="（二）分辨率"></a>（二）分辨率</h2><h3 id="1-物理像素"><a href="#1-物理像素" class="headerlink" title="1. 物理像素"></a>1. 物理像素</h3><p>在电商网站购买手机时我们都会查看手机的参数，以 京东上的 iPhone7 为例：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174703.png" alt="image-20210327135258715" style="zoom:67%"><p>可以看到，iPhone7 的分辨率是 <code>1334 x 750</code>，这里描述的就是屏幕实际的物理像素。</p><p>物理像素，又称为设备像素。显示屏是由一个个物理像素点组成的，<code>1334 x 750</code> 表示手机分别在垂直和水平上所具有的像素点数。通过控制每个像素点的颜色，就可以使屏幕显示出不同的图像，屏幕从出厂起，其物理像素点就固定不变了，单位为pt。屏幕分辨率就是指一个屏幕具体由多少个物理像素点组成。</p><h3 id="2-设备独立像素"><a href="#2-设备独立像素" class="headerlink" title="2. 设备独立像素"></a>2. 设备独立像素</h3><p>以 iPhone6/7/8为例，这里我们打开 Chrome 开发者工具：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174704.png" alt="image-20210327135542887" style="zoom:80%"><p>这里的375*667表示的就是设备独立像素DIP（Device Independent Pixels）。</p><p>当我们设定一个宽度为 375px 的 div，刚好可以充满这个设备的一行，配合高度 667px ，则 div 的大小<strong>刚好</strong>可以充满整个屏幕。</p><h3 id="3-CSS像素"><a href="#3-CSS像素" class="headerlink" title="3. CSS像素"></a>3. CSS像素</h3><p>在写CSS时用到最多的单位是<code>px</code>，即CSS像素，当页面缩放比例为100%时，一个CSS像素等于一个设备独立像素。但是<code>CSS像素</code>是很容易被改变的，当用户对浏览器进行了放大，CSS像素会被放大，这时一个CSS像素会跨越更多的物理像素。</p><p><code>页面的缩放系数 = CSS像素 / 设备独立像素</code>。</p><h3 id="4-DPR"><a href="#4-DPR" class="headerlink" title="4. DPR"></a>4. DPR</h3><p>DPR（Device Pixel Ratio） 设备像素比，这个与我们通常说的视网膜屏（多倍屏，Retina屏）有关。设备像素比描述的是<strong>未缩放状态下</strong>，物理像素和设备独立像素的初始比例关系。</p><p><strong>DPR = 物理像素宽度 / 设备独立像素宽度</strong></p><p>套用上面 iPhone7 的数据：iPhone7’s DPR = iPhone7’s 物理像素宽度 / iPhone7’s 设备独立像素宽度 = 2</p><p>我们通常说的H5手机适配也就是指的这两个维度：</p><ul><li>适配不同屏幕大小，也就是适配不同屏幕下的 CSS 像素</li><li>适配不同像素密度，也就是适配不同屏幕下 dpr 不一致导致的一些问题</li></ul><h3 id="5-PPI"><a href="#5-PPI" class="headerlink" title="5. PPI"></a>5. PPI</h3><p><code>PPI(Pixel Per Inch)</code>：每英寸包括的物理像素数。<code>PPI</code>可以用于描述屏幕的清晰度以及一张图片的质量。使用<code>PPI</code>描述图片时，<code>PPI</code>越高，图片质量越高，使用<code>PPI</code>描述屏幕时，<code>PPI</code>越高，屏幕越清晰。</p><h3 id="6-DPI"><a href="#6-DPI" class="headerlink" title="6. DPI"></a>6. DPI</h3><p><code>DPI(Dot Per Inch)</code>：即每英寸包括的点数。这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点或者打印机的墨点。平时可能会看到使用<code>DPI</code>来描述图片和屏幕，这时的<code>DPI</code>应该和<code>PPI</code>是等价的，<code>DPI</code>最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。</p><p>一张图片在屏幕上显示时，它的像素点数是规则排列的，每个像素点都有特定的位置和颜色。当使用打印机进行打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是<code>DPI</code>所描述的：打印点的密度。打印机的<code>DPI</code>越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174705.png" alt="image-20210327143056556" style="zoom:50%"><h2 id="（三）适配屏幕方案"><a href="#（三）适配屏幕方案" class="headerlink" title="（三）适配屏幕方案"></a>（三）适配屏幕方案</h2><p>适配不同屏幕大小其实只需要遵循一条原则，确保页面元素大小的与屏幕大小保持一定比例。也就是：<strong>按比例还原设计稿</strong></p><h3 id="1-rem适配方案（old-fashioned）"><a href="#1-rem适配方案（old-fashioned）" class="headerlink" title="1. rem适配方案（old-fashioned）"></a>1. rem适配方案（old-fashioned）</h3><p>rem（font size of the root element），在 <a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-values-3/#lengths">CSS Values and Units Module Level 3</a>中的定义就是， 根据网页的根元素来设置字体大小，和 em（font size of the element）的区别是，em 是根据其父元素的字体大小来设置，而 rem 是根据网页的根元素（html）来设置字体大小。</p><h4 id="flexible"><a href="#flexible" class="headerlink" title="flexible"></a>flexible</h4><p>基于此，淘宝早年推行的一套以 rem 为基准的适配方案：<a target="_blank" rel="noopener" href="https://github.com/amfe/lib-flexible">lib-flexible</a>。其核心做法在于：</p><ul><li><del>根据设备的 dpr 动态改写 `` 标签，设置 viewport 的缩放</del></li><li><del>给 `` 元素添加 data-dpr 属性，并且动态改写 data-dpr 的值</del></li><li>根据 <code>document.documentElement.clientWidth</code> 动态修改 <code>&lt;html&gt;</code> 的 font-size ，页面其他元素使用 rem 作为长度单位进行布局，从而实现页面的等比缩放</li></ul><p>关于头两点，其实现在的 <code>lib-flexible</code> 库已经不这样做了，不再去缩放 Viewport，字体大小的设定也直接使用了 rem</p><h4 id="hotcss"><a href="#hotcss" class="headerlink" title="hotcss"></a>hotcss</h4><p><a target="_blank" rel="noopener" href="https://github.com/imochen/hotcss">hotcss</a> 不是一个库，也不是一个框架。它是一个移动端布局开发解决方案。使用 hotcss 可以让移动端布局开发更容易。本质的思想与 flexible 完全一致。</p><h4 id="对于-rem-方案的一些总结"><a href="#对于-rem-方案的一些总结" class="headerlink" title="对于 rem 方案的一些总结"></a>对于 rem 方案的一些总结</h4><p>使用 flexible/hotcss 作为屏幕宽度适配解决方案，是存在一些问题的：</p><ul><li>动态修改 Viewport 存在一定的风险的，譬如通过 Viewport 改变了页面的缩放之后，获取到的 <code>innerWidth/innerHeight</code> 也会随之发生变化，如果业务逻辑有获取此类高宽进行其他计算的，可能会导致意想不到的错误；到今天，其实存在很多在 flexible 基础上演化而来的各种 rem 解决方案，有的不会对 Viewport 进行缩放处理，自行处理 1px 边框问题。</li><li>flexible/hotcss 都并非纯 CSS 方案，需要引入一定的 Javascript 代码</li><li>rem 的设计初衷并非是用于解决此类问题，用 rem 进行页面的宽度适配多少有一种 hack 的感觉</li><li>存在一定的兼容性问题，对于安卓 4.4 以下版本系统不支持 viewport 缩放（当然，flexible 处理 Android 系列时，始终认为其 dpr 为 1，没有进行 viewport 缩放）</li></ul><h3 id="2-vw适配方案"><a href="#2-vw适配方案" class="headerlink" title="2. vw适配方案"></a>2. vw适配方案</h3><p>严格来说，使用 rem 进行页面适配其实是一种 hack 手段，rem 单位的初衷本身并不是用来进行移动端页面宽度适配的。到了今天，有了一种更好的替代方案，使用 vw 进行适配 。百分比适配方案的核心需要一个全局通用的基准单位，rem 是不错，但是需要借助 Javascript 进行动态修改根元素的 <code>font-size</code>，而 vw/vh的出现则很好弥补 rem 需要 JS 辅助的缺点。</p><p>根据 CSS Values and Units Module Level 4：<code>vw</code>等于初始包含块（html元素）宽度的1%，也就是</p><ul><li><code>1vw</code> 等于 <code>window.innerWidth</code> 的数值的 1%</li><li><code>1vh</code> 等于 <code>window.innerHeight</code> 的数值的 1%</li><li><code>vmin</code> : <code>vw</code> 和 <code>vh</code> 中的较小值</li><li><code>vmax</code> : <code>vw</code> 和 <code>vh</code> 中的较大值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174706.png" alt="image-20210327144751871"></p><blockquote><ul><li><p><code>window.innerHeight</code>：获取浏览器视觉视口高度（包括垂直滚动条）。</p></li><li><p><code>window.outerHeight</code>：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。</p></li><li><p><code>window.screen.Height</code>：获取获屏幕取理想视口高度，这个数值是固定的，设备的分辨率/设备像素比</p></li><li><p><code>window.screen.availHeight</code>：浏览器窗口可用的高度。</p></li><li><p><code>document.documentElement.clientHeight</code>：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。</p></li><li><p><code>document.documentElement.offsetHeight</code>：包括内边距、滚动条、边框和外边距。</p></li><li><p><code>document.documentElement.scrollHeight</code>：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与<code>clientHeight</code>相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。</p></li></ul></blockquote><p>根据相关的测试，可以使用 vw 进行长度单位的有：</p><ul><li>容器大小适配，可以使用 vw</li><li>文本大小的适配，可以使用 vw</li><li>大于 1px 的边框、圆角、阴影都可以使用 vw</li><li>内距和外距，可以使用 vw</li></ul><p><a target="_blank" rel="noopener" href="https://codepen.io/Chokcoco/pen/oNvWVYq?editors=1100">vw页面适配代码演示</a></p><img src="https://user-images.githubusercontent.com/8554143/64007393-a7ad3e80-cb03-11e9-988a-90a7a38990f6.gif" alt="vw" style="zoom:67%"><p>vw 看上去不错，但存在一些问题：</p><ol><li>没能很好解决 1px 边框在高清屏下的显示问题，需要自行处理；</li><li>由于 vw 方案是完全的等比缩放，在完全等比还原设计稿的同时无法很好限定一个最大最小宽度值，由于 rem 方案是借助 Javascript 的，所以这一点 rem 比 vw 会更加的灵活；</li><li><code>px</code>转换成<code>vw</code>不一定能完全整除，因此有一定的像素差；</li><li>比如当容器使用<code>vw</code>，<code>margin</code>采用<code>px</code>时，很容易造成整体宽度超过<code>100vw</code>，从而影响布局效果。当然我们也是可以避免的，例如使用<code>padding</code>代替<code>margin</code>，结合<code>calc()</code>函数使用等等。</li></ol><p>当然，两个方案现阶段其实都可以使用甚至一起搭配使用，更多详情可以读读：</p><ul><li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5a9d07ee6fb9a028c149f55b">再聊移动端页面的适配</a></li><li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NgGd9zSm6NEaF5Jxp5WBKg">H5必知必会之像素级还原设计稿</a></li><li><a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2016/05/fluid-typography/">Responsive And Fluid Typography With vh And vw Units</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wengxuesong/archive/2016/05/16/5497653.html">使用VH和VW实现真正的流体排版</a></li></ul><h2 id="（四）图片适配及优化"><a href="#（四）图片适配及优化" class="headerlink" title="（四）图片适配及优化"></a>（四）图片适配及优化</h2><p>图像通常占据了网页下载资源的绝大部分。优化图像通常可以最大限度地减少从网站下载的字节数以及提高网站性能。一些通用的优化手段如下：</p><ul><li>消除多余的图像资源</li><li><strong>尽可能利用 CSS3\SVG 矢量图像替代某些光栅图像</strong></li><li>谨慎使用字体图标，使用网页字体取代在图像中进行文本编码</li><li>选择正确的图片格式</li><li><strong>为不同 DPR 屏幕提供最适合的图片尺寸</strong></li></ul><p>首先就是上述的第二点，我们平时使用的图片大多数都属于位图（<code>png、jpg...</code>），位图由一个个像素点构成的，每个像素都具有特定的位置和颜色值。理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果。而在<code>dpr &gt; 1</code>的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确分配上对应位图像素的颜色，只能取近似值，所以相同的图片在<code>dpr &gt; 1</code>的屏幕上就会模糊。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174707.png" alt="image-20210328120230196" style="zoom:67%"><p>尽可能利用 CSS3\SVG 矢量图像替代某些光栅图像。某些简单的几何图标，可以用 CSS3 快速实现的图形，都应该尽量避免使用光栅图像。这样能够保证它们在任何尺寸下都不会失真。其次，实在到了必须使用光栅图像的地步，也是有许多方式能保证图像在各种场景下都不失真。</p><h3 id="1-在不同dpr屏幕下使图片不失真"><a href="#1-在不同dpr屏幕下使图片不失真" class="headerlink" title="1. 在不同dpr屏幕下使图片不失真"></a>1. 在不同dpr屏幕下使图片不失真</h3><h4 id="①-无脑多倍图（不可取）"><a href="#①-无脑多倍图（不可取）" class="headerlink" title="① 无脑多倍图（不可取）"></a>① 无脑多倍图（不可取）</h4><p>在移动端假设我们需要一张 CSS 像素为 300 x 200的图像，考虑到现在已经有了 dpr = 3 的设备，那么要保证图片在 dpr = 3 的设备下也正常高清展示，我们最大可能需要一张 900 x 600的原图。这样，不管设备的 dpr 是否为 3，我们统一都使用 3 倍图。这样即使在 dpr = 1，dpr = 2 的设备上，也能非常好的展示图片。当然这样并不可取，会造成大量带宽的浪费。现代浏览器，提供了更好的方式，让我们能够根据设备 dpr 的不同，提供不同尺寸的图片。</p><h4 id="②-srcset-配合像素密度描述符"><a href="#②-srcset-配合像素密度描述符" class="headerlink" title="② srcset 配合像素密度描述符"></a>② srcset 配合像素密度描述符</h4><p>srcset 可以根据不同的 dpr 拉取对应尺寸的图片：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;illustration&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;illustration-small.png&#x27;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">srcset</span>=<span class="string">&#x27;images/illustration-small.png 1x,</span></span></span><br><span class="line"><span class="tag"><span class="string">               images/illustration-big.png 2x&#x27;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">style</span>=<span class="string">&#x27;max-width: 500px&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面 <code>srcset</code> 里的 1x，2x 表示 <strong>像素密度描述符</strong>，表示</p><ul><li>当屏幕的 dpr = 1 时，使用 <code>images/illustration-small.png</code> 这张图</li><li>当屏幕的 dpr = 2 时，使用 <code>images/illustration-big.png</code> 这张图</li></ul><h4 id="③-srcset-配合w宽度描述符"><a href="#③-srcset-配合w宽度描述符" class="headerlink" title="③ srcset 配合w宽度描述符"></a>③ srcset 配合w宽度描述符</h4><p>上面 1x，2x 的写法比较容易接受易于理解。除此之外，srcset属性还有一个 w 宽度描述符，配合 sizes 属性一起使用，可以覆盖更多的面。</p><p>以如下代码为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">sizes</span> = <span class="string">“(min-width:</span> <span class="attr">600px</span>) <span class="attr">600px</span>, <span class="attr">300px</span>&quot; </span></span><br><span class="line"><span class="tag">    <span class="attr">src</span> = <span class="string">&quot;photo.png&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">srcset</span> = <span class="string">“photo@1x.png</span> <span class="attr">300w</span>,</span></span><br><span class="line"><span class="tag">               <span class="attr">photo</span>@<span class="attr">2x.png</span> <span class="attr">600w</span>,</span></span><br><span class="line"><span class="tag">               <span class="attr">photo</span>@<span class="attr">3x.png</span> <span class="attr">1200w</span>,&quot;</span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p><code>sizes = “(min-width: 600px) 600px, 300px&quot;</code></p><p>如果屏幕当前的 CSS 像素宽度大于或等于 600px，则图片的 CSS 宽度为 600px，否则图片的 CSS 宽度为 300px。sizes 属性声明了在不同宽度下图片的 CSS 宽度表现。大屏幕下图片宽度为 600px，小屏幕下图片宽度为 300px。注意，这里的 sizes 属性只是声明了在不同屏幕宽度下图片的 CSS 宽度表现，而具体使图片在大于600px的屏幕上展示为600px宽度的代码需要另外由 CSS 或者 JS 实现。</p><p><code>srcset = “photo@1x.png 300w, photo@2x.png 600w, photo@3x.png 1200w</code></p><p>里面的 300w，600w，900w 叫宽度描述符。假设当前屏幕 dpr = 2 ，屏幕CSS 宽度为 375px，图片 CSS 宽度为 300px，则分别用上述 3 个宽度描述符的数值除以 300，得：</p><ul><li>300 / 300 = 1</li><li>600 / 300 = 2</li><li>1200 / 300 = 4</li></ul><p>上式计算得到的结果即算出的有效像素密度，换算成和 x 描述符等价的值 。这里 600w 算出的 2 满足 dpr = 2 的情况，选择此张图。此方案考虑到了响应性布局的复杂性与屏幕的多样性，利用上述规则，可以<strong>一次适配 PC 端大屏幕和移动端高清屏</strong>。</p><h4 id="④-media查询"><a href="#④-media查询" class="headerlink" title="④ media查询"></a>④ media查询</h4><p>使用<code>media</code>查询判断不同的设备像素比来显示不同精度的图片（只适用于背景图）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span>&#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">conardLi_1x.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="selector-class">.avatar</span>&#123;</span><br><span class="line">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">conardLi_2x.png</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="selector-class">.avatar</span>&#123;</span><br><span class="line">        <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">conardLi_3x.png</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑤-image-set"><a href="#⑤-image-set" class="headerlink" title="⑤ image-set"></a>⑤ image-set</h4><p>使用<code>image-set</code>（只适用于背景图）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">-webkit-image-set</span>( <span class="string">&quot;conardLi_1x.png&quot;</span> <span class="number">1</span>x, <span class="string">&quot;conardLi_2x.png&quot;</span> <span class="number">2</span>x );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑥-使用svg"><a href="#⑥-使用svg" class="headerlink" title="⑥ 使用svg"></a>⑥ 使用svg</h4><p><code>SVG</code>的全称是可缩放矢量图（<code>Scalable Vector Graphics</code>）。不同于位图的基于像素，<code>SVG</code> 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。</p><h2 id="（五）字体适配方案"><a href="#（五）字体适配方案" class="headerlink" title="（五）字体适配方案"></a>（五）字体适配方案</h2><p>浏览器有最小字体限制：</p><ul><li>PC上最小 font-size=12px</li><li>手机上最小 font-size=8px</li></ul><p>如果小于最小字体，那么字体默认就是最小字体。其次，很多早期的文章规范都建议不要使用奇数级单位来定义字体大小（如 13px，15px…），容易在一些低端设备上造成字体模糊，出现锯齿。</p><h3 id="字体的选择展示"><a href="#字体的选择展示" class="headerlink" title="字体的选择展示"></a>字体的选择展示</h3><p>在字体适配上面，我们需要从<strong>性能</strong>和<strong>展示效果</strong>两个维度去考虑。</p><p>完整的一个字体资源实在太大了，所以应尽可能使用用户设备上已有的字体，而不是额外下载字体资源，从而使加载时间明显加快。而从展示效果层面来说，使用系统字体能更好与当前操作系统使用的相匹配，得到最佳的展示效果。所以我们在字体使用方面，有一个应该尽量去遵循的原则，也是现在大部分网站在字体适配上使用的策略：<strong>使用各个支持平台上的默认系统字体</strong>。</p><h3 id="兼顾各个操作系统"><a href="#兼顾各个操作系统" class="headerlink" title="兼顾各个操作系统"></a>兼顾各个操作系统</h3><p>常见的操作系统有 Windows、Windows Phone、Mac OS X、iPhone、Android Phone、Linux。当然对于普通用户而言，无须关注 Linux 系统。</p><p>下面就以 <a target="_blank" rel="noopener" href="https://css-tricks.com/">CSS-Trick</a> 网站最新的 font-family 为例，看看他们是如何在字体选择上做到适配各个操作系统的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: </span><br><span class="line">    system-ui,-apple-system,BlinkMacSystemFont,segoe ui,Roboto,</span><br><span class="line">    Helvetica,Arial,</span><br><span class="line">    sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-family-关键字"><a href="#font-family-关键字" class="headerlink" title="font-family 关键字"></a>font-family 关键字</h3><p>对于 CSS 中的 <code>font-family</code> 而言，它有两类取值。</p><ol><li>一类是类似这样的具体的<strong>字体族名</strong>定义：<code>font-family: Arial</code> 这里定义了一个具体的字体样式，字体族名为 <code>Arial</code>;</li><li>一类是<strong>通用字体族名</strong>，它是一种备选机制，用于在指定的字体不可用时给出较好的字体，类似这样：<code>font-family: sans-serif</code> 。</li></ol><p>其中，<code>sans-serif</code> 表无衬线字体族，例如， “Open Sans”, “Arial” “微软雅黑” 等等。</p><p>关于<strong>通用字体族名</strong>，在 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/#generic-font-families">CSS Fonts Module Level 3 – Basic Font Properties</a> 中，定义了 5 个，也就是我们熟知的几个通用字体族名：</p><ol><li>serif 衬线字体族</li><li>sans-serif 非衬线字体族</li><li>monospace 等宽字体，即字体中每个字宽度相同</li><li>cursive 草书字体</li><li>fantasy 主要是那些具有特殊艺术效果的字体</li></ol><h3 id="新增通用字体族关键字"><a href="#新增通用字体族关键字" class="headerlink" title="新增通用字体族关键字"></a>新增通用字体族关键字</h3><p>而在 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/css-fonts-4/#generic-font-families">CSS Fonts Module Level 4 – Generic font families</a> 中，新增了几个关键字：</p><ul><li>system-ui 系统默认字体</li><li>emoji 用于兼容 emoji 表情符号字符</li><li>math 适用于数学表达式</li><li>fangsong 此字体系列用于中文的（仿宋）字体。</li></ul><p>我们看看用的最多的 <code>system-ui</code>。</p><h3 id="system-ui"><a href="#system-ui" class="headerlink" title="system-ui"></a>system-ui</h3><p>简单而言，<code>font-family: system-ui</code> 的目的就是在不同的操作系统的 Web 页面下，自动选择本操作系统下的默认系统字体。</p><p>默认使用特定操作系统的系统字体可以提高性能，因为浏览器或者 webview 不必去下载任何字体文件，而是使用已有的字体文件。 <code>font-family: system-ui</code> 字体设置的优势之处在于它与当前操作系统使用的字体相匹配，对于文本内容而言，它可以得到最恰当的展示。</p><h2 id="（六）前端布局的兼容适配"><a href="#（六）前端布局的兼容适配" class="headerlink" title="（六）前端布局的兼容适配"></a>（六）前端布局的兼容适配</h2><p>前端工程师的一大工作内容就是页面布局。无论在PC端还是移动端，页面布局的兼容适配都是重中之重。在整个前端发展的历程中，布局的方法也在不断的推陈出新。</p><h3 id="布局发展历程"><a href="#布局发展历程" class="headerlink" title="布局发展历程"></a>布局发展历程</h3><p>简单来说，前端的布局发展历程经历了下面几个过程：</p><p><strong>表格布局 –&gt; 定位布局 –&gt; 浮动布局 –&gt; flexbox布局 –&gt; grid box布局</strong></p><p>每一种布局在特定时期都发挥了重要的作用，而每一种新的布局方式的出现，往往都是因为现有的布局方式已经在该时期已经无法很好的满足开发者的需求，无法满足越来越潮流的页面布局的方式。</p><p>以 Flexbox 的出现为例子，在 Flexbox 被大家广为接受使用之前。我们一直在使用定位+浮动的布局方式。像下面这个布局：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174708.png" alt="image-20210327163627097" style="zoom:67%"><p>容器宽度不定，内部三个元素，均分排列且占满整个空间，并且垂直居中。如果使用定位+浮动的布局方式，你无法很快想到最佳的解决方式。三个元素并排那么必然需要浮动或者绝对定位，容器宽度不定且中间元素始终居中，需要顾虑的方面就很多了。也许使用 <code>text-align: justify</code> 可以 hack 实现，等等等等。</p><p>然而，使用 flexbox 布局的话，只需要：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flexbox 的出现，一次性解决了流动布局，弹性布局，排列方式等多个问题。并且它是简洁的，可控的。</p><p>再来看一个例子，水平垂直居中一个元素。使用 flexbox 也许是最便捷的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://codepen.io/Chokcoco/pen/GarPev">最便捷的垂直居中方式</a></p><h3 id="CSS-Grid-Layout"><a href="#CSS-Grid-Layout" class="headerlink" title="CSS Grid Layout"></a>CSS Grid Layout</h3><p>OK，flexbox 已经足够优秀了，为什么 gird 网格布局的出现又是为什么？它解决了什么 flex 布局无法很好解决的问题？</p><p>看看下面这张图：</p><p><a target="_blank" rel="noopener" href="https://user-images.githubusercontent.com/8554143/62539277-6bc9e500-b887-11e9-9f7b-78c51cde312c.png"><img src="https://user-images.githubusercontent.com/8554143/62539277-6bc9e500-b887-11e9-9f7b-78c51cde312c.png" alt="css grid layout" style="zoom:25%"></a></p><p>flexbox 是一维布局，他只能在一条直线上放置你的内容区块；而grid是一个二维布局。它除了可以灵活的控制水平方向之外，还能轻易的控制垂直方向的布局模式。对于上图那样的九宫格布局，它就可以轻而易举的完成。</p><p>一图以蔽之，flexbox：</p><p><a target="_blank" rel="noopener" href="https://user-images.githubusercontent.com/8554143/62591778-51cde800-b903-11e9-9037-9c5b25c9b894.png"><img src="https://user-images.githubusercontent.com/8554143/62591778-51cde800-b903-11e9-9037-9c5b25c9b894.png" alt="flexbox" style="zoom:25%"></a></p><p>grid box：</p><p><a target="_blank" rel="noopener" href="https://user-images.githubusercontent.com/8554143/62591784-5397ab80-b903-11e9-9c70-e7d4316a3da0.png"><img src="https://user-images.githubusercontent.com/8554143/62591784-5397ab80-b903-11e9-9c70-e7d4316a3da0.png" alt="gridbox" style="zoom:25%"></a></p><p>在现阶段，移动端布局应当更多使用 flexbox 去完成（相对那些还在使用 float 布局的），而考虑到未来页面布局的推陈出新。对于 Grid 布局我们应当像前几年对待 flexbox 一样，重视起来，随着兼容性的普及，Grid 布局也会慢慢成为主流。</p><h2 id="（七）视口"><a href="#（七）视口" class="headerlink" title="（七）视口"></a>（七）视口</h2><p>视口(<code>viewport</code>)代表当前可见的计算机图形区域。在<code>Web</code>浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的<code>UI</code>， 菜单栏等，即你正在浏览的文档的那一部分。一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。</p><h3 id="1-布局视口"><a href="#1-布局视口" class="headerlink" title="1. 布局视口"></a>1. 布局视口</h3><p>首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为viewport的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如768×1024，或者1080×1920这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？前面我们已经说了，css中的1px并不是代表屏幕上的1px，你分辨率越大，css中1px代表的物理像素就会越多，device Pixel Ratio的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视device Pixel Ratio的值而定），就是满屏的宽度了。回到正题上来，如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。这个浏览器默认的viewport叫做layout viewport(布局视口)。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174709.png" alt="image-20210327213112704" style="zoom:67%"><p>当我们以百分比来指定元素的大小时，它的值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。所以，布局视口是网页布局的基准窗口，在<code>PC</code>浏览器上，布局视口就等于当前浏览器的窗口大小（不包括<code>borders</code> 、<code>margins</code>、滚动条）。在移动端，布局视口被赋予一个默认值，大部分为<code>980px</code>，这保证<code>PC</code>的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。</p><p>我们可以通过调用<code>document.documentElement.clientWidth / clientHeight</code>来获取布局视口大小。</p><h3 id="2-视觉视口"><a href="#2-视觉视口" class="headerlink" title="2. 视觉视口"></a>2. 视觉视口</h3><p>然而，layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，这个viewport叫做 **visual viewport(视觉视口)**，即用户通过屏幕真实看到的区域，默认等于当前浏览器的窗口大小（包括滚动条宽度）。visual viewport的宽度指的是浏览器可视区域的宽度。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174710.png" alt="image-20210327213406398" style="zoom:67%"><p>用户正在看到的网页的区域。用户可以通过缩放来查看网站的内容。如果用户缩小网站，我们看到的网站区域将变大，此时视觉视口也变大了，同理，用户放大网站，我们能看到的网站区域将缩小，此时视觉视口也变小了。不管用户如何缩放，都不会影响到布局视口的宽度。</p><p>我们可以通过调用<code>window.innerWidth / innerHeight</code>来获取视觉视口大小。</p><h3 id="3-理想视口"><a href="#3-理想视口" class="headerlink" title="3. 理想视口"></a>3. 理想视口</h3><p>现在我们已经有两个viewport了：layout viewport 和 visual viewport。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的viewport。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。viewport叫做 <strong>ideal viewport(理想视口)**，移动设备的理想viewport，ideal viewport 可通过</strong>window. screen. width**获取。</p><p>ideal viewport 并没有一个固定的尺寸，不同的设备拥有有不同的 ideal viewport。所有的 iphone 的 ideal viewport 宽度都是 320px，无论它的屏幕宽度是 320 还是 640，也就是说，在 iphone 中，css 中的 320px 就代表 iphone 屏幕的宽度。</p><p>但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://viewportsizes.com/">http://viewportsizes.com</a> 去查看一下，里面收集了众多设备的理想宽度。</p><p>移动设备上的viewport分为layout viewport 、 visual viewport 和 ideal viewport 三类，其中的 ideal viewport 是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美地呈现给用户。</p><blockquote><p><strong>1、</strong>在桌面浏览器上，浏览器窗口与视口的宽度一致，而视口（CSS标准文档中称为“初始包含块”）是CSS百分比宽度推算的根源，因此，浏览器窗口是约束CSS布局的视口；<br><strong>2、</strong>在手机上，有两个视口，布局视口会限制CSS布局；视觉视口决定用户看到的网站内容；<br><strong>3、</strong>移动端浏览器还有个理想视口，它是对特定设备上的特定浏览器的布局视口的一个理想尺寸；<br><strong>4、</strong>可以把布局视口尺寸定义为理想视口。这也是响应式设计的基础。</p></blockquote><h3 id="4-Meta-Viewport"><a href="#4-Meta-Viewport" class="headerlink" title="4. Meta Viewport"></a>4. Meta Viewport</h3><p>meta用来表示不能由其它HTML元相关元素之一表示的任何元数据信息，它可以高速浏览器如何解析页面。我们可以借助</p><meta>元素的viewport来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。<p></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面是<code>viewport</code>的一个配置，我们来看看它们的具体含义：</p><table><thead><tr><th><code>Value</code></th><th>可能值</th><th>描述</th></tr></thead><tbody><tr><td><code>width</code></td><td>正整数或<code>device-width</code></td><td>以<code>pixels</code>（像素）为单位， 定义布局视口的宽度。</td></tr><tr><td><code>height</code></td><td>正整数或<code>device-height</code></td><td>以<code>pixels</code>（像素）为单位， 定义布局视口的高度。</td></tr><tr><td><code>initial-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义页面初始缩放比率。</td></tr><tr><td><code>minimum-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义缩放的最小值；必须小于或等于<code>maximum-scale</code>的值。</td></tr><tr><td><code>maximum-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义缩放的最大值；必须大于或等于<code>minimum-scale</code>的值。</td></tr><tr><td><code>user-scalable</code></td><td>一个布尔值（<code>yes</code>或者<code>no</code>）</td><td>如果设置为 <code>no</code>，用户将不能放大或缩小网页。默认值为 yes。</td></tr></tbody></table><p>首先，如果不设置meta viewport标签，那么移动设备上浏览器默认的宽度值为800px，980px，1024px等这些，总之是大于屏幕宽度的。这里的宽度所用的单位px都是指CSS像素，而不是物理像素。</p><p>第二、每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度。我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用。所以，我们可以使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来得到一个理想的viewport（也就是前面说的ideal viewport）。</p><p>为什么需要有理想的viewport呢？比如一个分辨率为320x480的手机理想viewport的宽度是320px，而另一个屏幕尺寸相同但分辨率为640x960的手机的理想viewport宽度也是为320px，那为什么分辨率大的这个手机的理想宽度要跟分辨率小的那个手机的理想宽度一样呢？这是因为，只有这样才能保证同样的网站在不同分辨率的设备上看起来都是一样或差不多的。实际上，现在市面上虽然有那么多不同种类不同品牌不同分辨率的手机，但它们的理想viewport宽度归纳起来无非也就 320、360、384、400等几种，都是非常接近的，理想宽度的相近也就意味着我们针对某个设备的理想viewport而做出的网站，在其他设备上的表现也不会相差非常多甚至是表现一样的。</p><h3 id="5-移动端适配"><a href="#5-移动端适配" class="headerlink" title="5. 移动端适配"></a>5. 移动端适配</h3><p>为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。<code>device-width</code>就等于理想视口的宽度，所以设置<code>width=device-width</code>就相当于让布局视口等于理想视口。</p><p>缩放是相对于ideal viewport来缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。例如在iphone中，ideal viewport的宽度是320px，如果我们设置 initial-scale=2 ，此时viewport的宽度会变为只有160px了，这也好理解，放大了一倍嘛，就是原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了。因此<code>initial-scale = 理想视口宽度 / 视觉视口宽度</code>，所以我们设置<code>initial-scale=1;</code>就相当于让视觉视口等于理想视口。这时，1个<code>CSS</code>像素就等于1个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。</p><p>值得注意的是，安卓自带的webkit浏览器只有在 initial-scale = 1 以及没有设置width属性时才是表现正常的，也就相当于这理论在它身上基本没用；而IE则根本不甩initial-scale这个属性，无论你给他设置什么，initial-scale表现出来的效果永远是1。</p><p>再来说下initial-scale的默认值问题，就是不写这个属性的时候，它的默认值会是多少呢？很显然不会是1，因为当 initial-scale = 1 时，当前的layout viewport宽度会被设为 ideal viewport的宽度，但前面说了，各浏览器默认的 layout viewport宽度一般都是980啊，1024啊，800啊等等这些个值，没有一开始就是 ideal viewport的宽度的，所以 initial-scale的默认值肯定不是1。安卓设备上的initial-scale默认值好像没有方法能够得到，或者就是干脆它就没有默认值，一定要你显示的写出来这个东西才会起作用，我们不管它了，这里我们重点说一下iphone和ipad上的initial-scale默认值。</p><p>根据测试，我们可以在iphone和ipad上得到一个结论，就是无论你给layout viewport设置的宽度是多少，而又没有指定初始的缩放值的话，那么iphone和ipad会自动计算initial-scale这个值，以保证当前layout viewport的宽度在缩放后就是浏览器可视区域的宽度，也就是说不会出现横向滚动条。比如说，在iphone上，我们不设置任何的viewport meta标签，此时layout viewport的宽度为980px，但我们可以看到浏览器并没有出现横向滚动条，浏览器默认的把页面缩小了。根据上面的公式，当前缩放值 = ideal viewport宽度 / visual viewport宽度，我们可以得出：<strong>当前缩放值 = 320 / 980</strong><br>也就是当前的initial-scale默认值应该是 0.33这样子。当你指定了initial-scale的值后，这个默认值就不起作用了。</p><p>总之记住这个结论就行了：在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。</p><h3 id="6-缩放"><a href="#6-缩放" class="headerlink" title="6. 缩放"></a>6. 缩放</h3><p>上面提到<code>width</code>可以决定布局视口的宽度，实际上它并不是布局视口的唯一决定性因素，设置<code>initial-scale</code>也有可能影响到布局视口，因为布局视口宽度取的是<code>width</code>和视觉视口宽度的最大值。</p><p>例如：若手机的理想视口宽度为<code>400px</code>，设置<code>width=device-width</code>，<code>initial-scale=2</code>，此时<code>视觉视口宽度 = 理想视口宽度 / initial-scale</code>即<code>200px</code>，布局视口取两者最大值即<code>device-width</code> <code>400px</code>。</p><p>若设置<code>width=device-width</code>，<code>initial-scale=0.5</code>，此时<code>视觉视口宽度 = 理想视口宽度 / initial-scale</code>即<code>800px</code>，布局视口取两者最大值即<code>800px</code>。</p><h2 id="（八）1px问题"><a href="#（八）1px问题" class="headerlink" title="（八）1px问题"></a>（八）1px问题</h2><p>为了适配各种屏幕，我们写代码时一般使用设备独立像素来对页面进行布局。而在设备像素比大于<code>1</code>的屏幕上，我们写的<code>1px</code>实际上是被多个物理像素渲染，这就会出现<code>1px</code>在有些屏幕上看起来很粗的现象。</p><h3 id="1-border-image"><a href="#1-border-image" class="headerlink" title="1. border-image"></a>1. border-image</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">        <span class="attribute">border-bottom</span>: none;</span><br><span class="line">        <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">../img/1pxline.png</span>) <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> stretch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-background-image"><a href="#2-background-image" class="headerlink" title="2. background-image"></a>2. background-image</h3><p>和<code>border-image</code>类似，准备一张符合条件的边框背景图，模拟在背景上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">../img/1pxline.png</span>) repeat-x left bottom;</span><br><span class="line">        <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">1px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种都需要单独准备图片，而且圆角不是很好处理，但是可以应对大部分场景。</p><h3 id="3-伪元素-transform"><a href="#3-伪元素-transform" class="headerlink" title="3. 伪元素+transform"></a>3. 伪元素+transform</h3><p>基于<code>media</code>查询判断不同的设备像素比对线条进行缩放：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="selector-class">.border_1px</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="selector-class">.border_1px</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式可以满足各种场景，如果需要满足圆角，只需要给伪类也加上<code>border-radius</code>即可。</p><h3 id="4-svg"><a href="#4-svg" class="headerlink" title="4. svg"></a>4. svg</h3><p>上面我们<code>border-image</code>和<code>background-image</code>都可以模拟<code>1px</code>边框，但是使用的都是位图，还需要外部引入。</p><p>借助<code>PostCSS</code>的<code>postcss-write-svg</code>我们能直接使用<code>border-image</code>和<code>background-image</code>创建<code>svg</code>的<code>1px</code>边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@svg</span> border_1px &#123; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2px</span>; </span><br><span class="line">  <span class="keyword">@rect</span> &#123; </span><br><span class="line">    fill: <span class="built_in">var</span>(--color, black); </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50%</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"><span class="selector-class">.example</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid transparent; <span class="attribute">border-image</span>: <span class="built_in">svg</span>(border_1px <span class="built_in">param</span>(--color <span class="number">#00b1ff</span>)) <span class="number">2</span> <span class="number">2</span> stretch; &#125;</span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid transparent; <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; height=&#x27;2px&#x27;%3E%3Crect fill=&#x27;%2300b1ff&#x27; width=&#x27;100%25&#x27; height=&#x27;50%25&#x27;/%3E%3C/svg%3E&quot;</span>) <span class="number">2</span> <span class="number">2</span> stretch; &#125;</span><br></pre></td></tr></table></figure><p>该方法基本可以满足所有场景，而且不需要外部引入，这是比较推荐的一种方案。</p><h3 id="5-设置viewport"><a href="#5-设置viewport" class="headerlink" title="5. 设置viewport"></a>5. 设置viewport</h3><p>通过设置缩放，让<code>CSS</code>像素等于真正的物理像素。</p><p>例如：当设备像素比为<code>3</code>时，我们将页面缩放<code>1/3</code>倍，这时<code>1px</code>等于一个真正的屏幕像素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="keyword">const</span> viewport = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!viewport) &#123;</span><br><span class="line">    viewport = <span class="built_in">document</span>.createElement(<span class="string">&#x27;meta&#x27;</span>);</span><br><span class="line">    viewport.setAttribute(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;viewport&#x27;</span>);</span><br><span class="line">    <span class="built_in">window</span>.document.head.appendChild(viewport);</span><br><span class="line">&#125;</span><br><span class="line">viewport.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;width=device-width,user-scalable=no,initial-scale=&#x27;</span> + scale + <span class="string">&#x27;,maximum-scale=&#x27;</span> + scale + <span class="string">&#x27;,minimum-scale=&#x27;</span> + scale);</span><br></pre></td></tr></table></figure><p>实际上，上面这种方案是早先<code>flexible</code>采用的方案。</p><p>当然，这样做是要付出代价的，这意味着你页面上所有的布局都要按照物理像素来写。这显然是不现实的，这时，我们可以借助<code>flexible</code>或<code>vw、vh</code>来帮助我们进行适配。</p><h2 id="（九）适配-iphone-X"><a href="#（九）适配-iphone-X" class="headerlink" title="（九）适配 iphone X"></a>（九）适配 iphone X</h2><p><code>iPhoneX</code>的出现将手机的颜值带上了一个新的高度，它取消了物理按键，改成了底部的小黑条，但是这样的改动给开发者适配移动端又增加了难度。</p><h3 id="1-安全区域"><a href="#1-安全区域" class="headerlink" title="1. 安全区域"></a>1. 安全区域</h3><p>在<code>iPhoneX</code>发布后，许多厂商相继推出了具有边缘屏幕的手机。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/331ae1667fbd495892819ea0a3750ad6~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:25%"><p>这些手机和普通手机在外观上无外乎做了三个改动：圆角（<code>corners</code>）、刘海（<code>sensor housing</code>）和小黑条（<code>Home Indicator</code>）。为了适配这些手机，安全区域这个概念变诞生了：安全区域就是一个不受上面三个效果的可视窗口范围。</p><p>为了保证页面的显示效果，我们必须把页面限制在安全范围内，但是不影响整体效果。</p><h3 id="2-viewport-fit"><a href="#2-viewport-fit" class="headerlink" title="2. viewport-fit"></a>2. viewport-fit</h3><p><code>viewport-fit</code>是专门为了适配<code>iPhoneX</code>而诞生的一个属性，它用于限制网页如何在安全区域内进行展示。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc930e75508a4e2d93f92fabe835931c~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:67%"><ul><li><code>contain</code>: 可视窗口完全包含网页内容</li><li><code>cover</code>：网页内容完全覆盖可视窗口</li></ul><p>默认情况下或者设置为<code>auto</code>和<code>contain</code>效果相同。</p><h3 id="3-env、constant"><a href="#3-env、constant" class="headerlink" title="3. env、constant"></a>3. env、constant</h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37944c89b2244681a6fa1e7a63c64d4c~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:50%"><p>我们需要将顶部和底部合理的摆放在安全区域内，<code>iOS11</code>新增了两个<code>CSS</code>函数<code>env、constant</code>，用于设定安全区域与边界的距离。</p><p>函数内部可以是四个常量：</p><ul><li><code>safe-area-inset-left</code>：安全区域距离左边边界距离</li><li><code>safe-area-inset-right</code>：安全区域距离右边边界距离</li><li><code>safe-area-inset-top</code>：安全区域距离顶部边界距离</li><li><code>safe-area-inset-bottom</code>：安全区域距离底部边界距离</li></ul><p>注意：我们必须指定<code>viweport-fit</code>后才能使用这两个函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;viewport-fit=cover&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>constant</code>在<code>iOS &lt; 11.2</code>的版本中生效，<code>env</code>在<code>iOS &gt;= 11.2</code>的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用底部固定导航栏时，我们要为他们设置<code>padding</code>值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（十）横屏适配"><a href="#（十）横屏适配" class="headerlink" title="（十）横屏适配"></a>（十）横屏适配</h2><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106174711.png" alt="image-20210328113924163" style="zoom:50%"><p>很多视口我们要对横屏和竖屏显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式：</p><h3 id="1-JavaScript检测横屏"><a href="#1-JavaScript检测横屏" class="headerlink" title="1. JavaScript检测横屏"></a>1. JavaScript检测横屏</h3><p><code>window.orientation</code>:获取屏幕旋转方向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.orientation === <span class="number">180</span> || <span class="built_in">window</span>.orientation === <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// 正常方向或屏幕旋转180度</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;竖屏&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.orientation === <span class="number">90</span> || <span class="built_in">window</span>.orientation === -<span class="number">90</span> )&#123; </span><br><span class="line">       <span class="comment">// 屏幕顺时钟旋转90度或屏幕逆时针旋转90度</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;横屏&#x27;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><h3 id="2-CSS检测横屏"><a href="#2-CSS检测横屏" class="headerlink" title="2. CSS检测横屏"></a>2. CSS检测横屏</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (orientation: portrait) &#123;</span><br><span class="line">  <span class="comment">/*竖屏...*/</span></span><br><span class="line">&#125; </span><br><span class="line">@media screen and (orientation: landscape) &#123;</span><br><span class="line">  <span class="comment">/*横屏...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">前端性能优化方案</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-14 23:26:54" itemprop="dateModified" datetime="2022-02-14T23:26:54+08:00">2022-02-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>55k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>50 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210701211849.png" alt="image-20210415153410699"></p><p>关于 Web 应用性能优化，有一点是毫无疑问的：「<strong>页面加载越久，用户体验就越差</strong>」。Web 应用性能优化的关键之处就在于：<strong>减少页面初载时所需加载资源的「数量」和「体积」</strong>。</p><div class="post-button"><a class="btn" href="/%E5%85%BC%E5%AE%B9%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){const e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">mohui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">484k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">7:20</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>