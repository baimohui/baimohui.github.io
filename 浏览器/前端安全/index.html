<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"baimohui.github.io",root:"/",images:"/images",scheme:"Muse",version:"8.2.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12},copycode:!1,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"}}</script><meta name="description" content="本文主要讨论了常见的加密算法和网络攻击。"><meta property="og:type" content="article"><meta property="og:title" content="前端安全"><meta property="og:url" content="https://baimohui.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/index.html"><meta property="og:site_name" content="白抹灰"><meta property="og:description" content="本文主要讨论了常见的加密算法和网络攻击。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173355.png"><meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/21/1690efb5388875bf?imageslim"><meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/21/1690efc4dc5d6c0f?imageslim"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173356.png"><meta property="og:image" content="https://zoucz.com/blogimgs/2016-12-29/1482947182838.png"><meta property="og:image" content="https://zoucz.com/blogimgs/2016-12-29/1482947888248.png"><meta property="og:image" content="https://zoucz.com/blogimgs/2016-12-29/1482948021700.png"><meta property="og:image" content="https://zoucz.com/blogimgs/2016-12-29/1482948705744.png"><meta property="og:image" content="https://zoucz.com/blogimgs/2016-12-29/1482948740608.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173357.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173358.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173359.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173400.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173401.png"><meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/21/1690e0ca6c93e74a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><meta property="article:published_time" content="2023-04-01T05:49:11.933Z"><meta property="article:modified_time" content="2023-04-11T14:53:32.819Z"><meta property="article:author" content="mohui"><meta property="article:tag" content="浏览器"><meta property="article:tag" content="算法"><meta property="article:tag" content="前端安全"><meta property="article:tag" content="XSS"><meta property="article:tag" content="CSRF"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173355.png"><link rel="canonical" href="https://baimohui.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>前端安全 | 白抹灰</title><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">白抹灰</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%8A%A0%E5%AF%86"><span class="nav-text">（一）加密</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="nav-text">1. 散列函数相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">① 应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A0-%E6%96%87%E4%BB%B6%E4%B8%80%E8%87%B4%E6%80%A7%E6%A3%80%E9%AA%8C"><span class="nav-text">Ⅰ. 文件一致性检验</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A1-%E6%96%87%E4%BB%B6%E7%A7%92%E4%BC%A0"><span class="nav-text">Ⅱ. 文件秒传</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A2-%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="nav-text">Ⅲ. 保存用户密码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1-%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB"><span class="nav-text">② 算法分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A0-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%88Hash%EF%BC%89"><span class="nav-text">Ⅰ. 哈希算法（Hash）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A1-%E5%8A%A0%E7%9B%90%EF%BC%88Adding-Salt%EF%BC%89"><span class="nav-text">Ⅱ. 加盐（Adding Salt）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A2-%E6%85%A2%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%EF%BC%88Slow-Hash-Function%EF%BC%89"><span class="nav-text">Ⅲ. 慢哈希函数（Slow Hash Function）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A3-%E5%AF%86%E9%92%A5%E5%93%88%E5%B8%8C"><span class="nav-text">Ⅳ. 密钥哈希</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A4-XOR"><span class="nav-text">Ⅴ. XOR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A5-HMAC"><span class="nav-text">Ⅵ. HMAC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-text">2. 对称加密算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-text">3. 非对称加密算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BB%84%E5%90%88%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF"><span class="nav-text">4. 组合加密技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A0-HMAC-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-text">Ⅰ. HMAC 加密算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A1-RSA-%E7%AD%BE%E5%90%8D%E3%80%81%E6%A0%A1%E9%AA%8C"><span class="nav-text">Ⅱ. RSA 签名、校验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%94%BB%E5%87%BB"><span class="nav-text">（二）攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-XSS-%E6%94%BB%E5%87%BB"><span class="nav-text">1. XSS 攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0-%E5%88%86%E7%B1%BB"><span class="nav-text">① 分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%9E%8B-XSS"><span class="nav-text">存储型 XSS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E5%9E%8B-XSS"><span class="nav-text">反射型 XSS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DOM-%E5%9E%8B-XSS"><span class="nav-text">DOM 型 XSS</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1-%E9%98%B2%E5%BE%A1-XSS"><span class="nav-text">② 防御 XSS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A0-%E5%B8%B8%E7%94%A8%E9%98%B2%E8%8C%83%E6%96%B9%E6%B3%95"><span class="nav-text">Ⅰ. 常用防范方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A1-%E9%A2%84%E9%98%B2%E5%AD%98%E5%82%A8%E5%9E%8B%E5%92%8C%E5%8F%8D%E5%B0%84%E5%9E%8B-XSS-%E6%94%BB%E5%87%BB"><span class="nav-text">Ⅱ. 预防存储型和反射型 XSS 攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A2-%E9%A2%84%E9%98%B2-DOM-%E5%9E%8B-XSS-%E6%94%BB%E5%87%BB"><span class="nav-text">Ⅲ. 预防 DOM 型 XSS 攻击</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-CSRF-%E6%94%BB%E5%87%BB"><span class="nav-text">2. CSRF 攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A0-CSRF-%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="nav-text">Ⅰ. CSRF 攻击流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A1-CSRF-%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B"><span class="nav-text">Ⅱ. CSRF 攻击类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GET-%E7%B1%BB%E5%9E%8B%E7%9A%84-CSRF"><span class="nav-text">GET 类型的 CSRF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POST-%E7%B1%BB%E5%9E%8B%E7%9A%84-CSRF"><span class="nav-text">POST 类型的 CSRF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E7%B1%BB%E5%9E%8B%E7%9A%84-CSRF"><span class="nav-text">链接类型的 CSRF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A2-CSRF-%E7%89%B9%E7%82%B9"><span class="nav-text">Ⅲ. CSRF 特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A3-CSRF-%E4%B8%8E-XSS-%E5%8C%BA%E5%88%AB"><span class="nav-text">Ⅳ. CSRF 与 XSS 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A4-%E9%98%B2%E5%BE%A1"><span class="nav-text">Ⅴ. 防御</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">mohui</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">81</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">77</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">前端安全</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-04-01 13:49:11" itemprop="dateCreated datePublished" datetime="2023-04-01T13:49:11+08:00">2023-04-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-04-11 22:53:32" itemprop="dateModified" datetime="2023-04-11T22:53:32+08:00">2023-04-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">前端安全</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>12k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>11 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文主要讨论了常见的加密算法和网络攻击。<a id="more"></a></p><h2 id="（一）加密"><a href="#（一）加密" class="headerlink" title="（一）加密"></a>（一）加密</h2><p>目前在项目中应用较多的加密算法可以分为以下几个类别：</p><ul><li>散列/哈希函数算法</li><li>对称加密算法</li><li>非对称加密算法</li><li>组合加密技术</li></ul><h3 id="1-散列函数相关"><a href="#1-散列函数相关" class="headerlink" title="1. 散列函数相关"></a>1. 散列函数相关</h3><p>与其说散列函数是一种加密算法，不如说它是一种数据特征值提取算法。常用的散列函数包括：MD5、SHA1、SHA2（包括 SHA128、SHA256 等）散列函数的应用很广。以 MD5 算法为例，其具有以下特点：</p><ul><li>压缩性：任意长度的数据，算出的 MD5 值长度都是固定的。</li><li>容易计算：从原数据计算出 MD5 值很容易。</li><li>抗修改性：对原数据进行任何改动，哪怕只修改 1 个字节，所得到的 MD5 值都有很大区别。</li><li>强抗碰撞：已知原数据和其 MD5 值，想找到一个具有相同 MD5 值的数据（即伪造数据）是非常困难的。散列算法的过程是不可逆的，可以通过数据得到其特征值，但是没办法根据特征值还原数据。</li></ul><h4 id="①-应用场景"><a href="#①-应用场景" class="headerlink" title="① 应用场景"></a>① 应用场景</h4><h5 id="Ⅰ-文件一致性检验"><a href="#Ⅰ-文件一致性检验" class="headerlink" title="Ⅰ. 文件一致性检验"></a>Ⅰ. 文件一致性检验</h5><p>假如有一份 1G 大小的文件需要发送给用户，但数据传输通道不可靠，那么可以计算出文件的散列值（为保证散列值不被窃取，可用其他加密方式将散列值加密并发送给用户），用户收到文件后自行计算其散列值，计算结果和收到的散列值相同则认为文件没有被篡改，否则说明文件遭到了篡改。</p><h5 id="Ⅱ-文件秒传"><a href="#Ⅱ-文件秒传" class="headerlink" title="Ⅱ. 文件秒传"></a>Ⅱ. 文件秒传</h5><p>以百度云秒传功能为例，几 G 大小的视频可能不到一分钟就成功上传到网盘，其原理并非百度的服务写入速度或用户网速有多快，而是依赖于以下流程：</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173355.png" alt="image-20210501101926968" style="zoom:80%"><h5 id="Ⅲ-保存用户密码"><a href="#Ⅲ-保存用户密码" class="headerlink" title="Ⅲ. 保存用户密码"></a>Ⅲ. 保存用户密码</h5><p>为了防止被黑客脱裤，不建议在数据库明文保存用户密码，而是保存密码的散列值。每次用户登录的时候，用散列函数对用户输入的密码进行计算，得到结果后和数据库里的散列值进行比对，一致则登录成功。当用户登录某个已注册网站时，在忘记密码的情况下需要重置密码，此时网站会给用户发一个随机密码或者一个邮箱激活链接，而不是用户之前的密码，这是因为哈希算法是不可逆的。</p><p>黑客脱裤成功拿到用户密码散列值后，可能拿彩虹表对用户密码的散列值进行暴力匹配，一些较简单的密码如“123456”、生日组合等，它们的散列值是固定的，因此会被黑客匹配上。为了应对这种情况可以对用户密码“加盐”，将“盐”和散列值一起保存。“123456”对应的散列值在彩虹表中有存储，但是“123456salt-asdgasdgsagasazsdasdf233zxcsdf”，在彩虹表中就没有了，这样黑客就没办法从彩虹表中获取常见密码的原文了！</p><h4 id="②-算法分类"><a href="#②-算法分类" class="headerlink" title="② 算法分类"></a>② 算法分类</h4><h5 id="Ⅰ-哈希算法（Hash）"><a href="#Ⅰ-哈希算法（Hash）" class="headerlink" title="Ⅰ. 哈希算法（Hash）"></a>Ⅰ. 哈希算法（Hash）</h5><p><strong>哈希（Hash）是将目标文本转换成具有固定长度的字符串（或叫做消息摘要）。</strong> 当输入发生改变时，产生的哈希值也完全不同。基于哈希算法的特性，其适用于该场景：被保护数据仅仅用作比较验证且不需要还原成明文形式。比较常用的哈希算法是 MD5 和 SHA1。</p><p>现在，对于简单的哈希算法的攻击方法主要有：寻找碰撞法和穷举法。所以，为了保证数据的安全，可以<strong>在哈希算法的基础上进一步的加密，常见的方法有：加盐、慢哈希、密钥哈希、XOR 等。</strong></p><h5 id="Ⅱ-加盐（Adding-Salt）"><a href="#Ⅱ-加盐（Adding-Salt）" class="headerlink" title="Ⅱ. 加盐（Adding Salt）"></a>Ⅱ. 加盐（Adding Salt）</h5><p>加盐加密是一种对系统登录口令的加密方式，它实现的方式是将每一个口令和一个叫做盐（salt）的 n 位随机数相关联。</p><p>为了方便理解，这里引用这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/jblock/article/details/78446604">文章</a>进行说明：使用 salt 加密，它的基本思路如下。</p><ul><li>用户注册时，在密码上撒一些盐。生成一种味道，记住味道。</li><li>用户再次登陆时，在输入的密码上撒盐，闻一闻，判断是否和原来的味道相同，相同就让你吃饭。</li></ul><p>由于验证密码时和最初散列密码时使用相同的盐值，所以 <strong>salt 存储在数据库</strong>。并且<strong>这个值是由系统随机产生的</strong>，而非硬编码。这就保证了所要保护对象的机密性。</p><p><strong>注册时：</strong></p><ul><li><ol><li>用户注册，系统随机产生 salt 值。</li></ol></li><li><ol start="2"><li>将 salt 值和密码连接起来，生产 Hash 值。</li></ol></li><li><ol start="3"><li>将 Hash 值和 salt 值分别存储在数据库中。</li></ol></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690efb5388875bf?imageslim" alt="img"></p><p><strong>登陆时：</strong></p><ul><li>系统根据用户名找到与之对应的密码 Hash。</li><li>将用户输入密码和 salt 值进行散列。</li><li>判断生成的 Hash 值是否和数据库中 Hash 相同。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690efc4dc5d6c0f?imageslim" alt="img"></p><p><strong>PS:</strong> 其实图中的这种登录也是不安全的，原因是后面提到的盐值复用</p><p>使用加盐加密时需要注意以下两点：</p><ul><li><strong>短盐值（Short Slat）</strong></li></ul><p>如果盐值太短，攻击者可以预先制作针对所有可能的盐值的查询表。例如，如果盐值只有三个 ASCII 字符，那么只有 95x95x95=857,375 种可能性，加大了被攻击的可能性。还有，不要使用可预测的盐值，比如用户名，因为针对某系统用户名是唯一的且被经常用于其他服务。</p><ul><li><strong>盐值复用（Salt Reuse）</strong></li></ul><p>在项目开发中，有时会遇到将盐值写死在程序里或者只有第一次是随机生成的，之后都会被重复使用，这种加盐方法是不起作用的。以登录密码为例，如果两个用户有相同的密码，那么他们就会有相同的哈希值，攻击者就可以使用反向查表法对每个哈希值进行字典攻击，使得该哈希值更容易被破解。</p><p><strong>所以正确的加盐方法如下：</strong></p><p>（1）盐值应该使用加密的安全伪随机数生成器（Cryptographically Secure Pseudo-Random Number Generator，CSPRNG）产生，比如 C 语言的 <code>rand()</code> 函数，这样生成的随机数高度随机、完全不可预测；</p><p>（2）盐值混入目标文本中，一起使用标准的加密函数进行加密；</p><p>（3）盐值要足够长（经验表明：盐值至少要跟哈希函数的输出一样长）且永不重复；</p><p>（4）盐值最好由服务端提供，前端取值使用。</p><h5 id="Ⅲ-慢哈希函数（Slow-Hash-Function）"><a href="#Ⅲ-慢哈希函数（Slow-Hash-Function）" class="headerlink" title="Ⅲ. 慢哈希函数（Slow Hash Function）"></a>Ⅲ. 慢哈希函数（Slow Hash Function）</h5><p>顾名思义，慢哈希函数是将哈希函数变得非常慢，使得攻击方法也变得很慢，慢到足以令攻击者放弃，而往往由此带来的延迟也不会引起用户的注意。降低攻击效率用到了密钥扩展（key stretching）的技术，而密钥扩展的实现使用了一种 CPU 密集型哈希函数（CPU-intensive hash function）。</p><p>如果想在一个 Web 应用中使用密钥扩展，则需要设定较低的迭代次数来降低额外的计算成本。我们一般直接选择使用标准的算法来完成，比如 PBKDF2 或 bcrypt。PHP、斯坦福大学的 JavaScript 加密库都包含了 PBKDF2 的实现，浏览器中则可以考虑使用 JavaScript 完成，否则这部分工作应该由服务端进行计算。</p><h5 id="Ⅳ-密钥哈希"><a href="#Ⅳ-密钥哈希" class="headerlink" title="Ⅳ. 密钥哈希"></a>Ⅳ. 密钥哈希</h5><p>密钥哈希是将密钥添加到哈希加密，这样只有知道密钥的人才可以进行验证。目前有两种实现方式：使用 ASE 算法对哈希值加密、使用密钥哈希算法 HMAC 将密钥包含到哈希字符串中。为了保证密钥的安全，需要将其存储在外部系统（比如一个物理上隔离的服务端）。</p><p>即使选择了密钥哈希，在其基础上进行加盐或者密钥扩展处理也是很有必要。目前密钥哈希用于服务端比较多，例如来应对常见的 SQL 注入攻击。</p><h5 id="Ⅴ-XOR"><a href="#Ⅴ-XOR" class="headerlink" title="Ⅴ. XOR"></a>Ⅴ. XOR</h5><p>XOR 大家都不陌生，它指的是逻辑运算中的异或运算。两个值相同时，返回 false，否则返回 true，用来判断两个值是否不同。</p><p>JavaScript 语言的二进制运算，有一个专门的 XOR 运算符，写作 ^。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 ^ 1 &#x2F;&#x2F; 0</span><br><span class="line">0 ^ 0 &#x2F;&#x2F; 0</span><br><span class="line">1 ^ 0 &#x2F;&#x2F; 1</span><br><span class="line">0 ^ 1 &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>XOR 运算有一个特性：<strong>如果对一个值连续做两次 XOR，会返回这个值本身。这也是其可以用于信息加密的根本。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message XOR key &#x2F;&#x2F; cipherText</span><br><span class="line">cipherText XOR key &#x2F;&#x2F; message</span><br></pre></td></tr></table></figure><p>目标文本 message，key 是密钥，第一次执行 XOR 会得到加密文本；在加密文本上再用 key 做一次 XOR 就会还原目标文本 message。为了保证 XOR 的安全，需要满足以下两点：</p><p>（1）key 的长度大于等于 message；</p><p>（2）key 必须是一次性的，且每次都要随机产生。</p><p>下面以登录密码加密为例介绍下 XOR 的使用：</p><p>第一步：使用 MD5 算法，计算密码的哈希；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const message &#x3D; md5(password);</span><br></pre></td></tr></table></figure><p>第二步：生成一个随机 key 值；</p><p>第三步：进行 XOR 运算，求出加密后的 message。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getXOR</span>(<span class="params">message, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="comment">//假设 key 是 32 位的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span>  m = <span class="built_in">parseInt</span>(message.substr(i, <span class="number">1</span>), <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">const</span> k = <span class="built_in">parseInt</span>(key.substr(i, <span class="number">1</span>), <span class="number">16</span>);</span><br><span class="line">        arr.push((m ^ k).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，使用 XOR 和一次性的密钥 key 对密码进行加密处理，只要 key 没有泄露，目标文本就不会被破解。</p><p>上面说了那么多，问题就来了：我们应该使用什么样的哈希算法呢？</p><p>（1）选择经过验证的成熟算法，如 PBKDF2 等；</p><p>（2）crypt 的安全版本；</p><p>（3）避免使用自己设计的加密算法。</p><h5 id="Ⅵ-HMAC"><a href="#Ⅵ-HMAC" class="headerlink" title="Ⅵ. HMAC"></a>Ⅵ. HMAC</h5><p>对于 HMAC 算法，和加盐类似，就是 salt 换成后端随机生成的 (好像可以防止重放攻击)，然后再通过 HMAC 算法得到摘要。关于 HMAC 算法部分可以详细看这篇<a target="_blank" rel="noopener" href="https://xiaix.me/ji-yu-hashhan-shu-de-mac-HMAC/">文章</a>。</p><p><strong>大概过程如下：</strong></p><ul><li>客户端发出登录请求</li><li>服务器返回一个随机值，在会话记录中保存这个随机值</li><li>客户端将该随机值作为密钥，用户密码进行 HMAC 运算，递交给服务器</li><li>服务器读取数据库中的用户密码，利用密钥做和客户端一样的 HMAC 运算，然后与用户发送的结果比较，如果一致，则用户身份合法。</li></ul><p><strong>好处：</strong></p><ul><li>与自定义的加 salt 算法不同，HMAC 算法对所有哈希算法都通用，无论是 MD5 还是 SHA-1。采用 HMAC 替代我们自己的 salt 算法，可以使程序算法更标准化，也更安全。(摘自雪峰大佬的<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0015108777177966ef0f4f8510a41b3b8c48cdcf7047b2d000">这篇文章</a>)</li><li>另外一个就是密码的安全性，由于不知道密钥，所以不可能获取到用户密码</li></ul><h3 id="2-对称加密算法"><a href="#2-对称加密算法" class="headerlink" title="2. 对称加密算法"></a>2. 对称加密算法</h3><p>对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥加密。也就是<strong>加密和解密都是用同一个密钥</strong>，这种方法在密码学中叫做对称加密算法。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173356.png" alt="image-20210501105656149" style="zoom:70%"><p>对称加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比 DES 的加密性好，而且对计算机功能要求也没有那么高。</p><p>常用的对称加密算法包括 DES 算法、AES 算法等。由于对称加密需要一个秘钥，而秘钥在加密者与解密者之间传输又很难保证安全性，所以目前用对称加密算法的话主要是用在加密者解密者相同，或者加密者解密者相对固定的场景。</p><h3 id="3-非对称加密算法"><a href="#3-非对称加密算法" class="headerlink" title="3. 非对称加密算法"></a>3. 非对称加密算法</h3><p>非对称加密算法的特点是，秘钥一次会生成一对，其中一份秘钥由自己保存，不能公开出去，称为私钥，另外一份是可以公开出去的，称为公钥。将原文用公钥进行加密，得到的密文只有对应私钥才可以解密；将原文用私钥加密得到的密文，也只有用对应的公钥才能解密。这样就解决了对称加密的秘钥传输过程无法保证安全的问题，加密者想与多方通信，也只需要公开一份自己的公钥就行了，无需对每个通信者生成多份秘钥。目前应用最广泛的非对称加密是 RSA 加密。</p><h3 id="4-组合加密技术"><a href="#4-组合加密技术" class="headerlink" title="4. 组合加密技术"></a>4. 组合加密技术</h3><p>各种加密算法都有自己的优缺点，很多场景并不能使用一种加密算法就能满足所有需求。现实应用中有很多“混搭”风格的加密技术正在被使用，下面列举一些我所了解到的算法或技术组合。<em>我要说话</em></p><h4 id="Ⅰ-HMAC-加密算法"><a href="#Ⅰ-HMAC-加密算法" class="headerlink" title="Ⅰ. HMAC 加密算法"></a>Ⅰ. HMAC 加密算法</h4><p>HMAC 加密算法是一种需要秘钥的散列算法，作为一个使用者我们暂时不去关心它的运算步骤，在使用理解方面，我认为可以将 HMAC 加密就理解为加盐的散列算法，此处的“盐”就相当于 HMAC 算法的秘钥，当然它们内部的计算逻辑是不同的。<img src="https://zoucz.com/blogimgs/2016-12-29/1482947182838.png" alt="img"></p><p>HMAC 加密算法主要用于校验客户端的身份，下面引用百度百科中的一个例子：HMAC 的一个典型应用是用在“质疑/应答”（Challenge/Response）身份认证中。</p><ol><li><p>先由客户端向服务器发出一个验证请求。</p></li><li><p>服务器接到此请求后生成一个随机数并通过网络传输给客户端（此为质疑）。</p></li><li><p>客户端将收到的随机数提供给 ePass，由 ePass 使用该随机数与存储在 ePass 中的密钥进行 HMAC-MD5 运算并得到一个结果作为认证证据传给服务器（此为响应）。</p></li><li><p>与此同时，服务器也使用该随机数与存储在服务器数据库中的该客户密钥进行 HMAC-MD5 运算，如果服务器的运算结果与客户端传回的响应结果相同，则认为客户端是一个合法用户安全性浅析由上面的介绍，我们可以看出，HMAC 算法更象是一种加密算法，它引入了密钥，其安全性已经不完全依赖于所使用的 HASH 算法，安全性主要有以下几点保证：（1）使用的密钥是双方事先约定的，第三方不可能知道。由 3.2 介绍的应用流程可以看出，作为非法截获信息的第三方，能够得到的信息只有作为“挑战”的随机数和作为“响应”的 HMAC 结果，无法根据这两个数据推算出密钥。由于不知道密钥，所以无法仿造出一致的响应。工作流程如下：</p><p><img src="https://zoucz.com/blogimgs/2016-12-29/1482947888248.png" alt="img"></p></li></ol><h4 id="Ⅱ-RSA-签名、校验"><a href="#Ⅱ-RSA-签名、校验" class="headerlink" title="Ⅱ. RSA 签名、校验"></a>Ⅱ. RSA 签名、校验</h4><p>RSA 签名算法是 RSA 加密配合散列函数的一种数据加密技术。如百度的证书</p><p><img src="https://zoucz.com/blogimgs/2016-12-29/1482948021700.png" alt="img"></p><p>CA 机构采用的就是 sha256RSA 算法对颁发给百度的证书进行签名。其实 sha256RSA 签名校验算法并不是单独发明的一种新的算法，而是 RSA 加密和 sha256 散列函数的一个组合使用，其原理如下：</p><p><img src="https://zoucz.com/blogimgs/2016-12-29/1482948705744.png" alt="img"></p><p>sha256RSA 签名流程</p><p><img src="https://zoucz.com/blogimgs/2016-12-29/1482948740608.png" alt="img"></p><p>sha256RSA 校验流程</p><h2 id="（二）攻击"><a href="#（二）攻击" class="headerlink" title="（二）攻击"></a>（二）攻击</h2><h3 id="1-XSS-攻击"><a href="#1-XSS-攻击" class="headerlink" title="1. XSS 攻击"></a>1. XSS 攻击</h3><p>Cross-Site Scripting（跨站脚本）简称 XSS，是一种<strong>代码注入攻击</strong>。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、Session ID 等，进而危害数据安全。</p><p>网页上任何可以输入的地方都有可能引起 XSS 攻击，包括 URL。XSS 常见的注入方法：</p><ul><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。</li><li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li><li>在标签的 href、src 等属性中，包含 <code>javascript:</code> (伪协议) 等可执行代码。</li><li>在 <code>onload</code>、<code>onerror</code>、<code>onclick</code> 等事件中，注入不受控制代码。</li><li>在 style 属性和标签中，包含类似 <code>background-image: url(&quot;javascript:...&quot;);</code> 的代码（新版本浏览器已经可以防范）。</li><li>在 style 属性和标签中，包含类似 <code>expression(...)</code> 的 CSS 表达式代码（新版本浏览器已经可以防范）。</li></ul><h4 id="①-分类"><a href="#①-分类" class="headerlink" title="① 分类"></a>① 分类</h4><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><h5 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h5><p><strong>攻击步骤</strong></p><ol><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户调用目标网站接口执行攻击者指定的操作。</li></ol><p>存储型 XSS（又称持久性 XSS）攻击常见于带有保存用户数据的网站功能，如论坛发帖、商品评论、用户私信等。它是最危险的一种跨站脚本，相比反射型 XSS 和 DOM 型 XSS 具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。任何允许用户存储数据的 web 程序都可能存在存储型 XSS 漏洞，当攻击者提交一段 XSS 代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被 XSS。</p><p><strong>实例分析</strong></p><p>这是一个可以发表评论的文章<a target="_blank" rel="noopener" href="https://www.kkkk1000.com/xss/Stored/index.html">界面</a>。但是服务端并没有对评论进行处理，所以如果在评论区输入 <code>&lt;script&gt;alert(&quot;xss&quot;)&lt;script&gt;</code> 并发送，那么所有打开这篇文章的人都会遭到存储型 XSS 攻击。这只是一个弹框，在实际攻击中，XSS 代码还能用于加载第三方 js 文件，或者用 <code>document.cookie</code> 盗取 cookie。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173357.png" alt="image-20210503094040445" style="zoom:67%"><h5 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h5><p><strong>攻击步骤</strong></p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户调用目标网站接口执行攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。反射型 XSS（也称非持久性 XSS）漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p><p><strong>实例分析</strong></p><p>打开某书城<a target="_blank" rel="noopener" href="https://www.kkkk1000.com/xss/Reflected/index.html">首页</a>，输入内容进行搜索。如果搜索的词条存在对应书籍，则直接返回相关列表。</p><p><code>https://www.kkkk1000.com/xss/Reflected/searchResult.html?kw=斗罗大陆</code></p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173358.png" alt="image-20210503094859145" style="zoom:50%"><p>如果没有搜索到结果，则后端会直接返回用户输入的内容，并显示在页面上。</p><p><code>https://www.kkkk1000.com/xss/Reflected/searchResult.html?kw=xxx</code></p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173359.png" alt="image-20210503095218734" style="zoom:67%"><p>后端在这里并没有对用户输入的数据进行处理，所以如果构造这样一个链接：</p><p><a target="_blank" rel="noopener" href="https://www.kkkk1000.com/xss/Reflected/searchResult.html?kw=alert(%22xss%22)">https://www.kkkk1000.com/xss/Reflected/searchResult.html?kw=alert(“xss”)</a></p><p>然后诱导他人点击该链接，就可以完成一次反射性 XSS 攻击。对于这么长的链接，还可以选择将其伪装成短网址或二维码。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173400.png" alt="image-20210503095552845" style="zoom:67%"><h5 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h5><p><strong>攻击步骤</strong></p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL。</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p><p>DOM 通常代表在 html、xhtml 和 xml 中的对象，使用 DOM 可以允许程序和脚本动态地访问和更新文档的内容、结构和样式。DOM 型 XSS 形成原因是通过修改页面的 DOM 节点形成的 XSS。</p><p><strong>实例分析</strong></p><p>下面是一个物流详情的页面，在 URL 上有快递编号这个参数，通过这个参数来获取数据。</p><p><a target="_blank" rel="noopener" href="https://www.kkkk1000.com/xss/dom/index.html?serialNumber=YT40359134268305">https://www.kkkk1000.com/xss/dom/index.html?serialNumber=YT40359134268305</a></p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173401.png" alt="image-20210503143908134" style="zoom:80%"><p>已知页面上显示的快递编号，是直接来自 URL 上的参数。所以如果构造这样一个网址：</p><p><a target="_blank" rel="noopener" href="https://www.kkkk1000.com/xss/dom/index.html?serialNumber=alert(%22xss%22)"><code>https://www.kkkk1000.com/xss/dom/index.html?serialNumber=alert(&quot;xss&quot;)</code></a></p><p>然后诱导他人点击这个<a target="_blank" rel="noopener" href="https://www.kkkk1000.com/xss/dom/index.html?serialNumber=alert(%22xss%22)">链接</a>，就可以完成一次 DOM 型 XSS 攻击。</p><hr><p><strong>对比</strong></p><table><thead><tr><th>类型</th><th>存储区</th><th>插入点</th></tr></thead><tbody><tr><td>存储型 XSS</td><td>后端数据库</td><td>HTML</td></tr><tr><td>反射型 XSS</td><td>URL</td><td>HTML</td></tr><tr><td>DOM 型 XSS</td><td>后端数据库/前端存储/URL</td><td>前端 JavaScript</td></tr></tbody></table><h4 id="②-防御-XSS"><a href="#②-防御-XSS" class="headerlink" title="② 防御 XSS"></a>② 防御 XSS</h4><p>只要有输入数据的地方，就可能存在 XSS 危险。</p><h5 id="Ⅰ-常用防范方法"><a href="#Ⅰ-常用防范方法" class="headerlink" title="Ⅰ. 常用防范方法"></a>Ⅰ. 常用防范方法</h5><ul><li><p><strong>HTTPOnly</strong> ：在 cookie 中设置 HTTPOnly 属性后，js 脚本将无法读取到 cookie 信息。</p></li><li><p><strong>输入过滤</strong>：一般是用于对于输入格式的检查，例如：邮箱、电话号码等，按照规定的格式输入。不仅仅是前端负责，后端也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</p></li><li><p><strong>转义 HTML</strong>：如果拼接 HTML 是必要的，就需要对引号、尖括号、斜杠进行转义，但这不够完善。要想对 HTML 模板各处插入点进行充分转义，就需要采用合适的转义库 (可以看下这个<a target="_blank" rel="noopener" href="https://jsxss.com/zh/index.html">库</a>，还是中文的)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&amp;amp;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quto;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#39;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">&#x27;&amp;#96;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">&#x27;&amp;#x2F;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>白名单：</strong>对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p></li></ul><h5 id="Ⅱ-预防存储型和反射型-XSS-攻击"><a href="#Ⅱ-预防存储型和反射型-XSS-攻击" class="headerlink" title="Ⅱ. 预防存储型和反射型 XSS 攻击"></a>Ⅱ. 预防存储型和反射型 XSS 攻击</h5><p>存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的数据被内嵌到代码中，被浏览器所执行。预防这两种漏洞，有两种常见做法：</p><ul><li>改成纯前端渲染，把代码和数据分隔开。</li><li>对 HTML 做充分转义。</li></ul><p>HTML 转义前面已经说过，这里仅谈纯前端渲染。</p><p><strong>纯前端渲染的过程：</strong></p><ol><li>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据；</li><li>然后浏览器执行 HTML 中的 JavaScript；</li><li>JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。</li></ol><p>在纯前端渲染中，浏览器被明确告知：下面要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还又或者式（<code>.style</code>）等。这样浏览器就不会被轻易欺骗，执行预期外的代码了。</p><p>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 <code>onload</code> 事件和 <code>href</code> 中的 <code>javascript:xxx</code> 等，请参考下文预防 DOM 型 XSS 攻击部分）。</p><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题，这时就需要对 HTML 进行充分的转义。</p><h5 id="Ⅲ-预防-DOM-型-XSS-攻击"><a href="#Ⅲ-预防-DOM-型-XSS-攻击" class="headerlink" title="Ⅲ. 预防 DOM 型 XSS 攻击"></a>Ⅲ. 预防 DOM 型 XSS 攻击</h5><p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。</p><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p><p>如果用 Vue/React 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</p><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onclick</span>=<span class="string">&quot;UNTRUSTED&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;UNTRUSTED&quot;</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png,&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 链接内包含恶意代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;UNTRUSTED&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// setTimeout()/setInterval() 中调用恶意代码</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">setTimeout</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">setInterval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// location 调用恶意代码</span></span></span><br><span class="line"><span class="javascript">location.href = <span class="string">&#x27;UNTRUSTED&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// eval() 中调用恶意代码</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">eval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-CSRF-攻击"><a href="#2-CSRF-攻击" class="headerlink" title="2. CSRF 攻击"></a>2. CSRF 攻击</h3><p>跨站请求伪造（Cross-site request forgery），也称 one-click attack 或 session riding，通常缩写为 CSRF 或者 XSRF，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h4 id="Ⅰ-CSRF-攻击流程"><a href="#Ⅰ-CSRF-攻击流程" class="headerlink" title="Ⅰ. CSRF 攻击流程"></a>Ⅰ. CSRF 攻击流程</h4><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690e0ca6c93e74a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="简而言之：网站过分相信用户" style="zoom:80%"><p>从上图可以看出，要完成一次 CSRF 攻击，受害者必须依次完成两个步骤：</p><ul><li>1.登录受信任网站 A，并在本地生成 Cookie。</li><li>2.在不登出 A 的情况下，访问危险网站 B。</li></ul><p>如果不满足以上条件中的任何一个，就不会受到 CSRF 的攻击。但用户往往不能保证以下情况不会发生：</p><ul><li>你不能保证你登录了一个网站后，不再打开一个 tab 页面并访问另外的网站。</li><li><strong>你不能保证关闭浏览器了后，你本地的 Cookie 立刻过期</strong>，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了）</li><li>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li></ul><h4 id="Ⅱ-CSRF-攻击类型"><a href="#Ⅱ-CSRF-攻击类型" class="headerlink" title="Ⅱ. CSRF 攻击类型"></a>Ⅱ. CSRF 攻击类型</h4><ul><li><h4 id="GET-类型的-CSRF"><a href="#GET-类型的-CSRF" class="headerlink" title="GET 类型的 CSRF"></a>GET 类型的 CSRF</h4></li></ul><p>GET 类型的 CSRF 利用非常简单，只需要一个 HTTP 请求，一般会这样利用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://bank.example/withdraw?amount=10000&amp;for=hacker&quot;</span> &gt;</span> </span><br></pre></td></tr></table></figure><p>在受害者访问含有这个 img 的页面后，浏览器会自动向<code>http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker</code> 发出一次 HTTP 请求。<code>bank.example</code> 就会收到包含受害者登录信息的一次跨域请求。</p><ul><li><h4 id="POST-类型的-CSRF"><a href="#POST-类型的-CSRF" class="headerlink" title="POST 类型的 CSRF"></a>POST 类型的 CSRF</h4></li></ul><p>这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://bank.example/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。</p><p>POST 类型的攻击通常比 GET 要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，<strong>后端接口不能将安全寄托在仅允许 POST 上面</strong>。</p><ul><li><h4 id="链接类型的-CSRF"><a href="#链接类型的-CSRF" class="headerlink" title="链接类型的 CSRF"></a>链接类型的 CSRF</h4></li></ul><p>链接类型的 CSRF 并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以夸张的说辞诱骗用户点击，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">    重磅消息！！</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Ⅲ-CSRF-特点"><a href="#Ⅲ-CSRF-特点" class="headerlink" title="Ⅲ. CSRF 特点"></a>Ⅲ. CSRF 特点</h4><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击<strong>利用受害者在被攻击网站的登录凭证，冒充受害者提交操作</strong>；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><p>CSRF 通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如<strong>可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。</strong></p><h4 id="Ⅳ-CSRF-与-XSS-区别"><a href="#Ⅳ-CSRF-与-XSS-区别" class="headerlink" title="Ⅳ. CSRF 与 XSS 区别"></a>Ⅳ. CSRF 与 XSS 区别</h4><ul><li>通常来说 CSRF 是由 XSS 实现的，CSRF 也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。</li><li>XSS 是代码注入问题，CSRF 是 HTTP 问题。XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF 则是因为浏览器在发送 HTTP 请求时自动带上 cookie，而一般网站的 session ID 都存在 cookie 里面 (Token 验证可以避免)。</li></ul><h4 id="Ⅴ-防御"><a href="#Ⅴ-防御" class="headerlink" title="Ⅴ. 防御"></a>Ⅴ. 防御</h4><ul><li>验证码：强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 CSRF，但是用户体验比较差。</li><li>Referer check：请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。</li><li>token：token 验证的 CSRF 防御机制是公认最合适的方案。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag"># 浏览器</a> <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" rel="tag"># 前端安全</a> <a href="/tags/XSS/" rel="tag"># XSS</a> <a href="/tags/CSRF/" rel="tag"># CSRF</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E6%A1%86%E6%9E%B6%E5%92%8C%E7%B1%BB%E5%BA%93/%E5%B7%A5%E5%85%B7%E5%BA%93/Vim/" rel="prev" title="Vscode 搭配 Vim 指南"><i class="fa fa-chevron-left"></i> Vscode 搭配 Vim 指南</a></div><div class="post-nav-item"><a href="/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%89%8D%E7%AB%AF%E9%89%B4%E6%9D%83/" rel="next" title="前端鉴权">前端鉴权 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){const e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">mohui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">573k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">8:41</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>