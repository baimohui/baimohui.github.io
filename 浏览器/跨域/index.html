<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"baimohui.github.io",root:"/",images:"/images",scheme:"Muse",version:"8.2.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12},copycode:!1,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"}}</script><meta name="description" content="&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstreamtitle: 跨域获取同源资源categories:   浏览器tags: 浏览器 跨域   AJAX 技术使开发者能够专注于互联网中数据的传输，而不再拘泥于数据传输的载体。通过它，我们获取数据的方式变得更加灵活，可控和优雅。但AJAX技术并不是一把万能钥匙，互联网中的数据隐私和数据安全（例如银行账号和密码）"><meta property="og:type" content="article"><meta property="og:title" content="白抹灰"><meta property="og:url" content="https://baimohui.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%B7%A8%E5%9F%9F/index.html"><meta property="og:site_name" content="白抹灰"><meta property="og:description" content="&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstreamtitle: 跨域获取同源资源categories:   浏览器tags: 浏览器 跨域   AJAX 技术使开发者能够专注于互联网中数据的传输，而不再拘泥于数据传输的载体。通过它，我们获取数据的方式变得更加灵活，可控和优雅。但AJAX技术并不是一把万能钥匙，互联网中的数据隐私和数据安全（例如银行账号和密码）"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210614230230.png"><meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/4/1601f323e28b9cd7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><meta property="article:published_time" content="2022-10-22T07:23:41.642Z"><meta property="article:modified_time" content="2022-10-22T07:23:41.642Z"><meta property="article:author" content="mohui"><meta property="article:tag" content="前端,JavaScript,html5,css3,Vue"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210614230230.png"><link rel="canonical" href="https://baimohui.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%B7%A8%E5%9F%9F/"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>| 白抹灰</title><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">白抹灰</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#lt-lt-lt-lt-lt-lt-lt-Updated-upstream"><span class="nav-text">&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="nav-text">一、同源策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E6%96%B9%E6%A1%88"><span class="nav-text">二、跨域请求资源方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JSONP"><span class="nav-text">1. JSONP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-CORS"><span class="nav-text">2. CORS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84AJAX%E8%AF%B7%E6%B1%82"><span class="nav-text">简单的AJAX请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E7%9A%84AJAX%E8%AF%B7%E6%B1%82"><span class="nav-text">复杂的AJAX请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-WebSocket"><span class="nav-text">3. WebSocket</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie%EF%BC%9A%E4%B8%BA-HTTP-%E5%8D%8F%E8%AE%AE%E6%B7%BB%E5%8A%A0%E7%8A%B6%E6%80%81"><span class="nav-text">Cookie：为 HTTP 协议添加状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebSocket%EF%BC%9A%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%9F%E5%8A%A8%E8%B5%B7%E6%9D%A5"><span class="nav-text">WebSocket：让服务器也动起来</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E5%8F%91%E8%B5%B7WebSocket%E8%AF%B7%E6%B1%82"><span class="nav-text">客户端如何发起WebSocket请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-postMessage"><span class="nav-text">4. postMessage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-proxy"><span class="nav-text">5. proxy</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">mohui</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">60</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%B7%A8%E5%9F%9F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"></h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-22 15:23:41" itemprop="dateCreated datePublished" datetime="2022-10-22T15:23:41+08:00">2022-10-22</time> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>14k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="lt-lt-lt-lt-lt-lt-lt-Updated-upstream"><a href="#lt-lt-lt-lt-lt-lt-lt-Updated-upstream" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream</h2><p>title: 跨域获取同源资源<br>categories:</p><ul><li>浏览器<br>tags:</li><li>浏览器</li><li>跨域</li></ul><hr><p>AJAX 技术使开发者能够专注于互联网中<strong>数据</strong>的传输，而不再拘泥于数据传输的<strong>载体</strong>。通过它，我们获取数据的方式变得更加灵活，可控和优雅。但AJAX技术并不是一把万能钥匙，互联网中的数据隐私和数据安全（例如银行账号和密码）非常重要，为了保护用户数据的隐私与安全，浏览器使用<strong>同源策略</strong>限制了AJAX技术获取数据的范围和能力。但有时我们不得不想办法绕过同源策略，实现跨域请求资源。因此跨域技术一直成为开发者们经久不衰的讨论话题。<a id="more"></a></p><h2 id="一、同源策略"><a href="#一、同源策略" class="headerlink" title="一、同源策略"></a>一、同源策略</h2><p>互联网的数据要么存储在<strong>服务端</strong>（即服务器，如数据库、硬盘等）中，要么存储在<strong>客户端</strong>（即浏览器，如 cookie，localStorage，sessionStorage）中。互联网数据的传输实际上就是客户端与服务端之间的交互。而所谓的数据隐私，说白了就是数据拥有者对数据索取者发出警告：“<strong>不是你的你别动</strong>”。如果你在客户端，想要获取服务端数据，首先需要通过服务器端的验证，证明你有权限获取数据；而如果你在服务端，想要获取客户端的某些数据，同样需要客户端通过某些方式验证你有资格获取相应的数据资源。</p><p>浏览器的同源策略是指：<strong>限制不同源之间执行特定操作</strong>。</p><p>① 一个<strong>源</strong>由<strong>协议</strong>，<strong>域名</strong>和<strong>端口</strong>三部分组成，这三者任意一个不同都会被浏览器识别为不同的源；</p><p>多数情况下，不同的源意味着它们在互联网中归属于不同的站点（或是不同的用途）。因此，它们可能是不同的项目，有不同的文件根目录，那么它们的数据自然不能共享，否则数据隐私和安全无法保障。</p><p>② 上文所提到的特定操作是指：</p><ul><li>读取 Cookie，LocalStorage 和 IndexDB；</li><li>获取 DOM 元素；</li><li>发送 AJAX 请求；</li></ul><p>假如浏览器允许我们执行这些特定操作，那会带来如下风险。<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004556040">cookie原理</a></p><p>首先，由于很多网站使用浏览器存储用户的账号和密码，那么便可以在A域中（在服务器上托管的网站）读取任意来访用户的所有Cookie信息（没有同源策略的保护，该用户所有网站的Cookie记录都是透明的），然后就能利用这些Cookie信息伪装成来访用户做任何事。正是出于同源政策的保护，我们只能访问用户该域下的Cookie信息，即服务端自己设置的Cookie信息。</p><p>其次，如果能够获取不同域下的DOM元素，我们就可以通过<code>&lt;iframe&gt;</code>标签在A域网站上引入B域网站，然后诱使用户在B域网站操作，由于我们能够跨域获取DOM元素，因此我们可以操作B域网站的DOM结构，用户输入的一切信息，以及用户操作的DOM元素都会被泄露。这正是同源策略想要规避的安全隐患。</p><p>当设置Cookie时，除了存放键值对形式的数据信息外，浏览器还会为Cookie的一些属性填充默认值（可手动修改属性值）。在这些属性中，domain代表域名，path代表路径，两者构成了一个确定这条Cookie何时被调用和访问的URL。与此同时，浏览器自己维护的Cookie文件中也会添加这一条新创建的Cookie数据。当在浏览器中发送HTTP请求时，浏览器首先会检查请求地址并在自己所维护的Cookie文件中寻找匹配的Cookie信息，将其添加到请求头中的<code>Cookie</code>属性内，然后向服务器发送请求。这个自动添加相应Cookie信息的过程是浏览器偷偷做的，即我们无法控制这个过程。当HTTP请求到达服务器时，服务器返回的响应中，响应头会原封不动返回浏览器发送给它的Cookie信息。我们虽然不能在发送请求前获得Cookie信息，但在发送请求后还是能够获得用户的Cookie！</p><p>再进一步解释一下这和AJAX的关系，假设我们在自己的服务器上托管了站点A，并在其中隐藏了一段脚本，每个登录站点A的人都会自动发送AJAX请求至站点B（假设站点B是一个银行），那么在没有浏览器同源策略的情况下，如果站点A中的访问者恰好有Cookie中保留站点B信息的用户，通过AJAX请求返回的响应头，我们一样可以拿到这位用户的站点B Cookie，从而伪装成用户在站点B登录，做一些违法乱纪的事情（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">CSRF</a>攻击即是利用了这个原理，只不过出于同源策略限制，并不能通过发起AJAX的方式）这也是为什么要禁止不同源的站点发送AJAX请求。<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004556040">https://segmentfault.com/a/1190000004556040</a>)</p><p>在浏览器同源策略的限制下，获取跨域Cookie，DOM结构和发送AJAX时的真实情况会是如下：</p><p>首先，我们在一个域下只能读取该域下的Cookie值。当我们在页面中使用<code>&lt;iframe&gt;</code>标签时，我们获取对应DOM节点下只有一个空空的<code>#document</code>节点，并没有额外的DOM信息。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210614230230.png" alt="image-20210330164155982" style="zoom:80%"><p>而对于AJAX，浏览器其实并没有阻止我们向不同域发送请求，其阻止的是这次请求的响应，也就是说服务端其实接收到了这次请求，只是响应被浏览器解析时被浏览器发现违背了同源策略而被拒绝，此时浏览器会在控制台中打印出一条错误信息。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/4/1601f323e28b9cd7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>另外对于XHR请求，实际上在请求报头也不会看到相应Cookie信息，因为CORS标准中规定默认情况下，浏览器在发送跨域请求时不能发送任何认证信息，比如<code>cookies</code>和<code>HTTP authentication schemes</code>。除非你显式地将<code>xhr</code>实例的<code>withCredentials</code>属性的值设置为<code>true</code>并且服务器端也允许客户端请求携带认证信息（即服务器端在响应头中设置了<code>Access-Control-Allow-Credentials: true</code>）。</p><h2 id="二、跨域请求资源方案"><a href="#二、跨域请求资源方案" class="headerlink" title="二、跨域请求资源方案"></a>二、跨域请求资源方案</h2><p>当我们拥有多个站点，并且这些站点又经常共享相同的数据，那么为每个站点存储一份数据看起来就蠢透了。更好的方案是，我们建设一台静态资源存储服务器，然后所有站点都从这一台服务器上获取资源。很理想的方案，但是现实中首要解决的问题便是浏览器的同源策略，不同域之间无法通过AJAX技术获取资源。这是需要跨域获取资源的主要情景。</p><p><strong>无论是怎样的跨域资源获取方案，本质上都需要服务器端的支持</strong>。跨域获取资源之所以能够成功，本质是服务器默许了你有权限获取相应资源。下面所运用的种种方式，实际上是客户端和服务端互相配合，绕过同源策略进行数据交互的工作。</p><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h3><p>正如标题所描述的那样，JSONP技术是早期的跨域资源获取方式，由于该技术的简单易用，逐渐变得流行，最终成为经典的跨域获取资源方案。JSONP是“JSON with padding”的简写，我将其翻译为“被包裹的JSON”。</p><p>首先，浏览器的同源策略<strong>只是阻止了通过AJAX技术跨域获取资源，而没有禁止跨域获取资源这件事本身</strong>，因此可以通过<code>&lt;link&gt;</code>标签<code>href</code>属性或<code>&lt;img&gt;</code>标签以及<code>&lt;script&gt;</code>标签中的<code>src</code>属性获取异域的CSS，JS资源和图片（其实并不能读取这些资源的内容）；其次，<code>&lt;script&gt;</code>标签通过<code>src</code>属性加载的JS资源，实际上只是将JS文件内容原封不动放置在<code>&lt;scritp&gt;</code>的标签内。</p><p>也就是说，如果sayHi.js文件只有这样一段代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sayHi.js</span></span><br><span class="line">alert(<span class="string">&#x27;Hi&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当我们在HTML文件中，成功加载sayHi.js文件时，浏览器只不过是做了如下操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 加载前 --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;sayHi.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 加载后 （为了方便阅读，我格式化了代码）--&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;sayHi.js&quot;</span>&gt;</span><br><span class="line">    alert(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这意味着被加载的文件与HTML文件下的其他JS文件共享一个全局作用域。也就是说，<code>&lt;scritp&gt;</code>标签加载到的资源是可以被全局作用域下的函数所使用。但如果<code>&lt;script&gt;</code>标签加载到的一些数据并不符合JavaScript语法规定的<strong>数据类型</strong>，JavaScript就无法处理这些错误，而且就算数据类型正常了，我们还应该将数据存储于一个<strong>变量</strong>内，然后调用这个变量。</p><p>但我们已经约定好了数据的格式为JSON，这是JavaScript可以处理的数据类型，并且JSON格式的数据可以承载大量信息。那么至于<strong>变量</strong>问题，我们则会通过向服务器传入一个函数的方式，将数据变为函数的参数，让我们直接看看JSONP的使用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">`You get the data : <span class="subst">$&#123;response&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">script.src = <span class="string">&#x27;http://somesite.com/json/?callback=handleResponse&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild)</span><br></pre></td></tr></table></figure><p>很容易看到，我们在1-3行中创建了一个函数，该函数用来处理我们将要获得的数据，该函数的参数<code>response</code>即是服务器响应的数据。在4-6行中我们所做的是利用JavaScript动态生成一个script标签，并将其插入HTML文档。但是注意第5行我们制定的src值，在URL末尾，我们有这样一段查询参数<code>callback=handleResponse</code>，callback的值正是我们先前创建的函数。</p><p>事情开始变得有些令人困惑了，究竟发生了什么呢？我们如何通过上述代码最终实现跨域获取资源？</p><p>答案就藏在服务端的代码中，当服务端支持JSONP技术时，会做如下一些设置：</p><ol><li>识别请求的URL，提取callback参数的值，并动态生成一个执行该参数值（一个函数）的JavaScript语句；</li><li>将需要返回的数据放入动态生成的函数中，等待其加在到页面时被执行；</li></ol><p>此时该文件内容看起来就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleResponse(response) <span class="comment">// response为被请求的JSON格式的数据</span></span><br></pre></td></tr></table></figure><p>因此，当资源加载到位，内容显示在script标签内时，浏览器引擎会执行这条语句，我们想要的数据就可以以任何想要的方式处理了。你现在知道为什么这项技术被命名为JSONP了吧？那个“padding”指的就是我们的“callback”函数，真是恰如其名。</p><p>最后，我们还要对JSONP技术再强调两点：</p><ol><li>JSONP技术与AJAX技术无关：虽然同样牵扯到跨域获取资源这个主题，但JSONP的本质是绕过AJAX获取资源的机制，使用原始的<code>src</code>属性获取异域资源；</li><li>JSONP技术存在三点缺陷：<ul><li>无法发送POST请求，也就是说JSONP技术只能用于请求异域资源，无法上传数据或修改异域数据；</li><li>无法监测JSONP请求是否失败；</li><li>可能存在安全隐患：JSONP之所以能成功获取异域服务器资源，靠的是服务器动态生成了回调函数，并在页面中执行，那么如果服务器在原有的回调函数下再添加些别的恶意JavaScript代码也会被执行！所以在使用JSONP技术时，一定要确保请求资源的服务器是值得信赖的；</li></ul></li></ol><p>虽然存在一些缺陷，但JSONP的浏览器兼容性却是非常好的，可以说是一种非常小巧高效的跨域资源获取技术。</p><hr><h3 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2. CORS"></a>2. CORS</h3><p>CORS是W3C颁布的一个浏览器技术规范，其全称为“跨域资源共享”（Cross-origin resource sharing），它是由W3C官方推广的允许通过AJAX技术跨域获取资源的规范，因此相较于JSONP而言，功能更加强大，使用起来也没有了hack的味道。</p><p>关于CORS的具体细节，建议移步阮一峰的<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/04/cors.html">同主题博客</a>阅读。</p><p>如果想要绕过浏览器同源策略，通过AJAX技术跨域获取资源，这需要服务端和客户端的协同合作。而对于CORS标准而言，实现AJAX跨域获取资源，重点在于服务器端返回的响应是否清楚告知了浏览器此次跨域AJAX请求的合法性。</p><p>根据AJAX请求的复杂程度不同，服务器要向浏览器做出的说明程度也不同。</p><h4 id="简单的AJAX请求"><a href="#简单的AJAX请求" class="headerlink" title="简单的AJAX请求"></a>简单的AJAX请求</h4><ol><li>请求方法只属于<strong>HEAD</strong>，<strong>GET</strong>，<strong>POST</strong>请求的其中一种；</li><li>HTTP 的头信息只限于以下字段：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type（只能为<code>application/x-www-form-urlencoded</code>，<code>multipart/form-data</code>和<code>text/plain</code>其中一种）</li></ul></li></ol><p>而当浏览器检测到一个简单的跨域AJAX请求，浏览器会首先为我们添加一个头部信息：<code>Origin</code>。它的值为请求方所在的源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 ...</span><br></pre></td></tr></table></figure><p>而当这样的一条HTTP请求发送到服务端时，服务端会检测该请求报头中的<code>Origin</code>字段的值是否在许可范围内，如果的确是服务端认可的域，那么服务端会在响应报文中添加如下字段：</p><ul><li><code>Access-Control-Allow-Origin</code>（必须）：该字段用来告知浏览器服务端接受的能够发送跨域AJAX请求的域，它的值要么是该次AJAX请求报头中由浏览器自动添加的<code>Origin</code>值，要么是一个<code>*</code>号，表示可以接受任意的域名请求；</li><li><code>Access-Control-Allow-Credentials</code>（可选）：该字段用来告知浏览器是否允许客户端向服务端发送Cookie。默认情况下，CORS规范会阻止跨域AJAX向服务端发送Cookie，因此该字段默认值为<code>false</code>，当你显式的将该字段值设置为<code>true</code>时，则表示允许此次跨域AJAX向服务端发送Cookie；</li><li><code>Access-Control-Expose-Headers</code>（可选）：该字段用来向客户端暴露可获取的响应头。</li></ul><p>CORS规范规定，客户端<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：</p><ul><li><code>Cache-Control</code>：表示响应遵循的缓存机制；</li><li><code>Content-Language</code>：表示响应体的语言；</li><li><code>Content-Type</code>：表示响应体的MIME类型；</li><li><code>Expires</code>：表示文档的过期时间，到期不再缓存；</li><li><code>Last-Modified</code>：表示文档的最后改动时间；</li><li><code>Pragma</code>：用来包含特定的指令。如果客户端想获取额外的响应头字段时，就需要服务端通过在该字段后定义相应的客户端可获取的响应头字段名称。</li></ul><blockquote><p><strong>CORS规范中为什么默认不允许跨域AJAX请求携带Cookie ？</strong></p><p>在客户端与服务端数据传输的过程中，Cookie一直是以明文的形式伴随着数据的传输，只要客户端发送了Cookie到服务端，服务端就会至少返回该段Cookie。而大多数网站都使用Cookie短暂存储用户会话中的身份信息，因此将Cookie暴露在外是存在安全隐患的，CSRF攻击的目的便是获取用户的Cookie信息，因此在跨域AJAX请求中，为了减少Cookie泄露的风险，CORS规范默认禁止跨域AJAX请求携带Cookie。</p><p><strong>如果通过客户端与服务端相互配合，使得客户端能够携带Cookie信息？</strong></p><p>Ⅰ. 客户端：开发者需要在创建XMLHttpRequest对象实例时，手动配置<code>withCredentials</code>属性，将其值设置为<code>true</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>某些浏览器会默认允许在跨域AJAX请求中发送Cookie，此时如果不想要发送Cookie，只需要将其值设置为<code>false</code>。</p><p>Ⅱ. 服务端：对于服务端而言，除了要在响应报头设置<code>Access-Control-Allow-Credential</code>字段的值为<code>true</code>之外，为了保护客户端与服务端Cookie的隐私和安全，还需要为<code>Access-Control-Allow-Origin</code>字段设置一个明确的域，不可以再使用<code>*</code>号。</p></blockquote><h4 id="复杂的AJAX请求"><a href="#复杂的AJAX请求" class="headerlink" title="复杂的AJAX请求"></a>复杂的AJAX请求</h4><p>与简单AJAX跨域请求不同，复杂的AJAX跨域请求一共会发送两次HTTP请求，其中第一次为<strong>查询请求</strong>，第二次才是正式的<strong>AJAX跨域请求</strong>。当发送复杂的AJAX跨域请求时，浏览器拿到请求开始识别，然后发现这个请求不满足简单跨域AJAX请求标准，于是会询问服务端是否允许异域的客户端向它发送额外的请求信息，这即是第一次HTTP请求（查询请求）。而服务端会给出相应的回答，然后浏览器就会根据回答的结果决定是否继续发送该跨域AJAX请求。</p><p>一个复杂的AJAX跨域请求如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://another.com/cors&#x27;</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&#x27;put&#x27;</span>, url, <span class="literal">true</span>) <span class="comment">// 这里我们设置请求的方式为&#x27;put&#x27;</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;Value&#x27;</span>) <span class="comment">// 这里我们自定义了一个请求头字段</span></span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure><p>当浏览器识别到该请求不简单时，就会自动向服务器发送一个查询请求，其报头信息大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;thisOne.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: another.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0...</span><br></pre></td></tr></table></figure><p>注意这次查询请求使用了OPTIONS的请求方法，表明了这是一个查询请求。请求头部的信息说明了<strong>请求来源的域</strong>，<strong>请求使用的HTTP方法</strong>以及<strong>请求额外发送的头部字段</strong>。</p><p>当服务端接收到浏览器发来的查询请求后，如果允许接收客户端的请求，则会返回浏览器如下的响应报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache&#x2F;2.0.61（Unix）</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;thisOne.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header &#x2F;&#x2F; 该字段值为以“,”号分割的字符串</span><br><span class="line">Content-type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout&#x3D;2, max&#x3D;100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text&#x2F;plain</span><br></pre></td></tr></table></figure><ul><li><code>Access-Control-Allow-Origin</code>：向浏览器说明了发起AJAX请求的域是被服务器认可的（字段值也可以为一个“*”号）；</li><li><code>Access-Control-Allow-Methods</code>：说明了服务器接收跨域AJAX的请求方式；</li><li><code>Access-Control-Allow-Headers</code>：说明了服务器允许跨域AJAX额外发送的报头信息；</li></ul><p>当浏览器收到服务端同意请求的响应后，就会正常发送接下来的跨域AJAX请求，而服务器也会正常回应。在服务端与客户端整个跨域AJAX请求的交互中，<code>Access-Control-Allow-Origin</code>头信息自始至终都是必须携带的。</p><p>而如果服务器在收到查询请求后不同意该请求，则会返回一个正常的HTTP响应，报文中包含任何与CORS规范有关的报头字段，用来表示服务器拒绝接收客户端的跨域AJAX请求，因此浏览器会返回一个错误状态（可以被XML对象实例使用onerror回调函数捕获）并在控制台打印一条错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http:&#x2F;&#x2F;another.com</span><br><span class="line">Origin http:&#x2F;&#x2F;thisOne.com is not allowed by Access-Control-Allow-Origin</span><br></pre></td></tr></table></figure><p>对于复杂的跨域AJAX请求，浏览器会向服务器发送两次HTTP请求，但如果能够一次搞定，就无需每次请求都重复两次。对于服务器而言，一次搞定的方法就在于，在浏览器第一次发送复杂的跨域AJAX查询请求时，在响应报头中添加<code>Access-Control-Max-Age</code>字段，这是一个可选的字段，它用来指定本次查询请求的有效期，单位为秒。通过该字段，服务器拥有了告知浏览器“这个请求我准了，X秒以内不需要再向我确认”的能力。至此，接下来的跨域请求数由两次节约为一次。</p><h3 id="3-WebSocket"><a href="#3-WebSocket" class="headerlink" title="3. WebSocket"></a>3. WebSocket</h3><p>WebSocket 是一种<strong>在单个 TCP 连接上进行全双工通讯的协议</strong>。HTML5 标准之所以提出了这种新的互联网通信协议，是为了弥补在<strong>服务端与客户端的双向通信</strong>时使用 HTTP 协议通信的一些不足。但这并不意味 WebSocket 协议可以完全取代 HTTP 协议，两者都有各自擅长的领域，时不时还能一同协作解决难题。</p><p>当我们使用 HTTP 协议时，客户端与服务端的通信模式始终是由客户端向服务端发送请求，服务端只负责验证请求并返回响应。而客户端发送的每一个请求，对于服务端而言都是全新的，也即是说 HTTP 协议是<strong>无状态的</strong>。乍看似乎不合理，但这种设计却使服务器的工作变得简单可控，提升了服务器的工作效率。</p><p>但这样的设计仍然存在两个问题：</p><ol><li>每一个请求都需要身份验证，这对于用户而言意味着需要在每一次发送请求时输入身份信息；</li><li>当客户端所请求的资源是动态生成时，客户端无法在资源生成时得到通知；</li></ol><p>对于前者，可以使用 <strong>Cookie</strong> 解决，而对于后者，则轮到WebSocket大显身手。在讨论 WebSocket 之前，让我们先稍微绕点路，谈谈“Cookie”是如何解决“每一个请求都需要身份验证”的问题的。</p><h4 id="Cookie：为-HTTP-协议添加状态"><a href="#Cookie：为-HTTP-协议添加状态" class="headerlink" title="Cookie：为 HTTP 协议添加状态"></a>Cookie：为 HTTP 协议添加状态</h4><p>HTTP 协议下，客户端与服务端的通信是无状态的，即如果服务器中的某部分资源是由特定客户专属的，那么每当这个客户想要获取资源时，都需要先在浏览器中输入账号密码，然后再发送请求，并在被服务器识别身份信息成功后获取请求的资源。为了避免这般繁琐的操作，我们引入了 Cookie：它既可以存储在浏览器，又会被浏览器发送 HTTP 请求时默认发送至服务端，并且还受浏览器同源策略保护，帮助我们提高发起一次请求的效率。</p><p>在有了 Cookie 后，我们可以在一次会话中（从用户登录到浏览器关闭）只输入一次账号密码，然后将其保存在 Cookie中，在整个会话期间，Cookie 都会伴随着 HTTP 请求的发送被服务器识别，从而避免了重复输入身份信息。</p><p>而且基于 Cookie 可以保存在浏览器内并在浏览器发送 HTTP 请求时默认携带的特性，服务端也可以操作 Cookie。Cookie还可以帮助我们节省网络请求的发起数量。例如，在制作一个购物网站时，我们不希望用户在每添加一个商品到购物车就向服务器发送一个请求（请求数量越少，服务器压力就越小），此时我们可以将添加商品所导致的数据变动存储在 Cookie 内，然后等待下次发送请求时，一并发送给服务器处理。Cookie 的出现，为无状态的 HTTP 协议通信添加了状态。</p><p>Cookie 多数情况下都保存着用户的身份信息，因此对于 Cookie 的恶意攻击层出不穷。其本质上就是想要获得用户的 Cookie，再利用其中的身份信息伪装成用户获取相应资源，而浏览器的同源策略本质上就是保护用户的 Cookie 信息不会泄露。</p><h4 id="WebSocket：让服务器也动起来"><a href="#WebSocket：让服务器也动起来" class="headerlink" title="WebSocket：让服务器也动起来"></a>WebSocket：让服务器也动起来</h4><p><strong>客户端无法获知请求的动态资源何时到位</strong>。有时候客户端想要请求的资源，服务器需要一定时间后才能返回（比如该资源依赖于其他服务器的计算返回结果），由于在 HTTP 协议下，网络通信是单向的，因此服务器并不具备当资源准备就绪时，通知浏览器的功能（要保障服务器的工作效率）。因此，基于 HTTP 协议通常的做法是，设置一个定时器，每隔一定时间由浏览器向服务器发送一次请求以探测资源是否到位。这种做法显然浪费了很多请求或者说带宽（每个请求都要携带 Cookie 和报头，这些都会占用带宽传输），低效且不够优雅。</p><p>我们希望当服务器资源到位时，能主动通知浏览器并返回相应资源。为了实现这一点，HTML5 标准推出了 WebSocket 协议，使浏览器和服务器实现了双向通信。除了 IE9 及以下的 IE 浏览器，所有的浏览器都支持 WebSocket 协议。</p><p>客户端告知服务端要升级为 WebSocket 协议的报头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure><p>服务端向客户端返回的响应报头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><h4 id="客户端如何发起WebSocket请求"><a href="#客户端如何发起WebSocket请求" class="headerlink" title="客户端如何发起WebSocket请求"></a>客户端如何发起WebSocket请求</h4><p>像发起 AJAX 请求一样，发起 WebSocket 请求需要借助浏览器提供的 <code>WebSocket</code> 对象，该对象提供了用于创建和管理 WebSocket 连接，以及通过该连接收发数据的 API。所有的浏览器都默认提供了 WebSocket 对象。</p><p>和使用 <code>XHRHttpRequest</code> 对象一样，我们首先要实例化一个 <code>WebSocket</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://echo.websocket.org&quot;</span>)</span><br></pre></td></tr></table></figure><p>传入的参数为响应WebSocket请求的地址。</p><p>与 AJAX 类似的是，<code>WebSocket</code> 对象也有一个 <code>readyState</code> 属性，用来表示对象实例当前所处的链接状态，有四个值：</p><ul><li><strong>0</strong>：表示正在连接中（CONNECTING）；</li><li><strong>1</strong>：表示连接成功，可以通信（OPEN）；</li><li><strong>2</strong>：表示连接正在关闭（CLOSING）；</li><li><strong>3</strong>：表示连接已经关闭或打开连接失败（CLOSED）；</li></ul><p>可以通过判断这个值来执行相应的代码。</p><p>除此之外，<code>WebSocket</code>对象还提供一系列事件属性来控制连接过程中的通信行为：</p><ul><li><code>onopen</code>：用于指定连接成功后的回调函数；</li><li><code>onclose</code>：用于指定连接关闭后的回调函数；</li><li><code>onmessage</code>：用于指定收到服务器数据后的回调函数；</li><li><code>onerror</code>：用于指定报错时的回调函数；</li></ul><p>通过<code>.send()</code>方法，我们拥有了向服务器发送数据的能力（WebSocket还允许我们发送二进制数据）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">&#x27;Hi, server!&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>WebSocket</code>对象的<code>bufferedAmount</code>属性的返回值表示了还有多少字节的二进制数据没有发送出去，所以可以通过判断该值是否为0而确定数据是否发送结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1000000</span>)</span><br><span class="line">ws.send(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 还在发送</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebSocket是如何绕过浏览器的同源策略实现跨域资源共享，那就是<strong>当客户端与服务端创建WebSocket连接后，本身就可以天然的实现跨域资源共享</strong>，WebSocket协议本身就不受浏览器同源策略的限制（同源策略只限制了跨域的AJAX请求）。</p><p>但如果没有浏览器同源策略的限制，那么用户的Cookie安全又由谁来保护呢？Cookie的存在就是为了给无状态的HTTP协议通讯添加状态，因为Cookie是明文传输的，且通常包含用户的身份信息，所以非常受到网络攻击者的“关注”。但是想想WebSocket协议下的通讯机制，客户端和服务端一旦建立连接，就可以顺畅互发数据，因此WebSocket协议本身就是“<strong>有状态的</strong>”，不需要Cookie的帮忙，既然没有Cookie，自然也不需要同源策略去保护，因此其实这个问题也不成立。</p><h3 id="4-postMessage"><a href="#4-postMessage" class="headerlink" title="4. postMessage"></a>4. postMessage</h3><p>JSONP，CORS 与 WebSocket 这些跨域技术都只适用于客户端请求异域服务端资源的情景。而有时候我们需要在异域的两个客户端之间共享数据，例如页面与内嵌 iframe 窗口通讯，页面与新打开异域页面通讯。</p><p>使用 <code>postMessage</code> 技术实现跨域的原理非常简单，一方面，主窗口通过 <code>postMessage</code>API 向异域的窗口发送数据，另一方面我们在异域的页面脚本中始终监听 <code>message</code> 事件，当获取主窗口数据时处理数据或者以同样的方式返回数据从而实现跨窗口的异域通讯。</p><p>让我们用具体的业务场景与代码进一步说明，假如我们的页面现在有两个窗口，窗口1命名为“window_1”， 窗口2命名为“window_2”，当然，窗口1与窗口2的“域”是不同的，我们的需求是由窗口1向窗口2发送数据，而当窗口2接收到数据时，将数据再返回给窗口1。先让我们看看窗口1<code>script</code>标签内的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window_1 域名为 http://winodow1.com:8080</span></span><br><span class="line"><span class="built_in">window</span>.postMessage(<span class="string">&quot;Hi, How are you!&quot;</span>, <span class="string">&quot;http://window2.com:8080&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到，<code>postMessage</code>函数接收两个参数，第一个为要发送的信息（可以是任何JavaScript类型数据，但部分浏览器只支持字符串格式），第二个为信息发送的目标地址。让我们再看看窗口2<code>script</code>标签内的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window_2 域名为 http://window2.com:8080</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;message&quot;</span>, receiveMessage, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对于Chorme，origin属性为originalEvent.origin属性</span></span><br><span class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin</span><br><span class="line">    <span class="keyword">if</span> (origin !== <span class="string">&quot;http://window1.com:8080&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.postMessage(<span class="string">&quot;I\&#x27;m ok&quot;</span>, <span class="string">&quot;http://window1.com:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在window上绑定了一个事件监听函数，监听<code>message</code>事件。一旦我们接收到其他域通过<code>postMessage</code>发送的信息，就会触发<code>receiveMessage</code>回调函数。该函数会首先检查发送信息的域是否是我们想要的，如果验证成功则会向窗口1发送一条消息。</p><p>一方发送信息，一方捕捉信息。但是所有跨域技术都需要关注安全问题。postMessage技术之所以能实现跨域资源共享，本质上依赖于客户端脚本设置了相应的<code>message</code>监听事件。因此只要有消息通过<code>postMessage</code>发送过来，我们的脚本都会接收并进行处理。由于任何域都可以通过<code>postMessage</code>发送跨域信息，因此对于设置了事件监听器的页面来说，判断到达页面的信息是否是安全的是非常重要的事，因为我们并不想要执行有危险的数据。</p><p>那么如何鉴别发送至页面的信息呢？答案是通过 <code>message</code>事件监听函数的事件对象，我们称它为<code>event</code>，该对象有三个属性：</p><ul><li><strong>data</strong>：值为其他window传递过来的对象；</li><li><strong>origin</strong>：值为消息发送方窗口的域名；</li><li><strong>source</strong>：值为对发送消息的窗口对象的引用；</li></ul><p>应该着重检测<code>event</code>对象的<code>origin</code>属性，建立一个白名单对<code>origin</code>属性进行检测通常是一个明智的做法。</p><p>最后，除了IE8以下的IE浏览器，所有的浏览器都支持postMessage方法！</p><h3 id="5-proxy"><a href="#5-proxy" class="headerlink" title="5. proxy"></a>5. proxy</h3><p>Vue 中配置 proxy。vue 的转发机制 proxyTable，proxyTable 代理功能可以实现转发机制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">   devServer: &#123;</span><br><span class="line">   <span class="comment">//设置完成后重启npm</span></span><br><span class="line">       	host: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    	port: <span class="number">8080</span>,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">        	<span class="comment">//设置代理</span></span><br><span class="line">            <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">                target: <span class="string">&quot;http://0.0.0.0:3000&quot;</span>, <span class="comment">// 要跨域的域名</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>, <span class="comment">// 是否开启跨域。如果接口跨域，需要进行这个参数配置</span></span><br><span class="line">                ws: <span class="literal">true</span>, <span class="comment">// proxy websockets</span></span><br><span class="line">                pathRewrite: &#123; <span class="comment">// 重写接口地址</span></span><br><span class="line">                    <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;&quot;</span>	<span class="comment">//通配符</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先浏览器是禁止跨域的，但是服务端不禁止，在本地运行 npm run dev 等命令时实际上是用 node 运行了一个服务器，因此 proxyTable 实际上是将请求发给自己的服务器，再由服务器转发给后台服务器，做了一层代理。vue 的 proxyTable 用的是 http-proxy-middleware 中间件, 因此不会出现跨域问题。</p><p>在请求跨域接口的时候就可以利用本地服务加上要跨域的接口地址即可。也就是说，代理服务器通过请求本地的服务器，然后本地的服务器再去请求远程的服务器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如本地服务端口  localhost:8080</span></span><br><span class="line">axios.get(<span class="string">&#x27;http://localhost:8080/api/login&#x27;</span>)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/%E6%A1%86%E6%9E%B6/Vue2/%E6%96%87%E5%AD%97%E8%B7%91%E9%A9%AC%E7%81%AF/" rel="prev" title="Vue transition-group组件实现文字跑马灯效果"><i class="fa fa-chevron-left"></i> Vue transition-group组件实现文字跑马灯效果</a></div><div class="post-nav-item"><a href="/%E6%B5%8F%E8%A7%88%E5%99%A8/PWA%20%E8%AF%A6%E8%A7%A3/" rel="next" title="PWA 详解">PWA 详解 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){const e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">mohui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">531k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">8:03</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>