<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"baimohui.github.io",root:"/",images:"/images",scheme:"Muse",version:"8.2.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12},copycode:!1,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"}}</script><meta name="description" content="AJAX（一）AJAX概述AJAX（Asynchronous JavaScript And XML，异步的JavaScript和XML），是一种实现无页面刷新获取服务器数据的混合技术。它能够使浏览器在不刷新页面的情况下获取服务器响应，这将大大提升互联网用户的使用体验，同时，由于AJAX请求获取的是数据而不是HTML文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。"><meta property="og:type" content="article"><meta property="og:title" content="异步请求方法总结"><meta property="og:url" content="https://baimohui.github.io/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/index.html"><meta property="og:site_name" content="白抹灰"><meta property="og:description" content="AJAX（一）AJAX概述AJAX（Asynchronous JavaScript And XML，异步的JavaScript和XML），是一种实现无页面刷新获取服务器数据的混合技术。它能够使浏览器在不刷新页面的情况下获取服务器响应，这将大大提升互联网用户的使用体验，同时，由于AJAX请求获取的是数据而不是HTML文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210614230230.png"><meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/4/1601f323e28b9cd7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210614225916.png"><meta property="article:published_time" content="2021-06-14T15:04:14.074Z"><meta property="article:modified_time" content="2021-07-17T14:18:13.275Z"><meta property="article:author" content="mohui"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="异步"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210614230230.png"><link rel="canonical" href="https://baimohui.github.io/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>异步请求方法总结 | 白抹灰</title><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">白抹灰</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#AJAX"><span class="nav-text">AJAX</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89AJAX%E6%A6%82%E8%BF%B0"><span class="nav-text">（一）AJAX概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-XML-%E5%92%8C-JSONP"><span class="nav-text">1. XML 和 JSONP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%97%A0%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0"><span class="nav-text">2. 无页面刷新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%B7%B7%E5%90%88%E6%8A%80%E6%9C%AF"><span class="nav-text">3. 混合技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8E%9F%E7%94%9FAJAX%E4%BD%BF%E7%94%A8"><span class="nav-text">（二）原生AJAX使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-XMLHttpRequest%E5%AF%B9%E8%B1%A1"><span class="nav-text">1. XMLHttpRequest对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%87%86%E5%A4%87AJAX%E8%AF%B7%E6%B1%82"><span class="nav-text">2. 准备AJAX请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="nav-text">3. 设置请求头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="nav-text">4. 发送请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94"><span class="nav-text">5. 处理响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%8F%96%E6%B6%88%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="nav-text">6. 取消异步请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-XMLHttpRequest-2%E7%BA%A7%E8%A7%84%E8%8C%83"><span class="nav-text">7. XMLHttpRequest 2级规范</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0-FormData-%E7%B1%BB%E5%9E%8B"><span class="nav-text">① FormData 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1-%E8%B6%85%E6%97%B6%E8%AE%BE%E5%AE%9A"><span class="nav-text">② 超时设定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2-overrideMimeType-%E6%96%B9%E6%B3%95"><span class="nav-text">③ overrideMimeType()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3-%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6"><span class="nav-text">④ 进度事件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89jQuery-AJAX%E4%BD%BF%E7%94%A8"><span class="nav-text">（三）jQuery AJAX使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-jQuery%E5%8A%A0%E8%BD%BD"><span class="nav-text">1. jQuery加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-jQuery-GET-POST"><span class="nav-text">2. jQuery GET&#x2F;POST</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B7%A8%E5%9F%9F%E8%8E%B7%E5%8F%96%E5%90%8C%E6%BA%90%E8%B5%84%E6%BA%90"><span class="nav-text">（四）跨域获取同源资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="nav-text">1. 同源策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E6%96%B9%E6%A1%88"><span class="nav-text">2. 跨域请求资源方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0-JSONP"><span class="nav-text">① JSONP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1-CORS"><span class="nav-text">② CORS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84AJAX%E8%AF%B7%E6%B1%82"><span class="nav-text">简单的AJAX请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E7%9A%84AJAX%E8%AF%B7%E6%B1%82"><span class="nav-text">复杂的AJAX请求</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2-WebSocket"><span class="nav-text">③ WebSocket</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Cookie%EF%BC%9A%E4%B8%BAHTTP%E5%8D%8F%E8%AE%AE%E6%B7%BB%E5%8A%A0%E7%8A%B6%E6%80%81"><span class="nav-text">Cookie：为HTTP协议添加状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WebSocket%EF%BC%9A%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%9F%E5%8A%A8%E8%B5%B7%E6%9D%A5"><span class="nav-text">WebSocket：让服务器也动起来</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E5%8F%91%E8%B5%B7WebSocket%E8%AF%B7%E6%B1%82"><span class="nav-text">客户端如何发起WebSocket请求</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3-postMessage"><span class="nav-text">④ postMessage</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fetch"><span class="nav-text">Fetch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89Fetch%E5%AE%9E%E7%8E%B0"><span class="nav-text">（一）Fetch实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Fetch%E5%AE%9E%E4%BE%8B"><span class="nav-text">（二）Fetch实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89Fetch%E4%BD%BF%E7%94%A8"><span class="nav-text">（三）Fetch使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Headers"><span class="nav-text">Headers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request"><span class="nav-text">Request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Response"><span class="nav-text">Response</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89Fetch%E7%BC%BA%E7%82%B9"><span class="nav-text">（四）Fetch缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Axios"><span class="nav-text">Axios</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89Axios%E4%BD%BF%E7%94%A8"><span class="nav-text">（一）Axios使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="nav-text">1. 发送请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B7%BB%E5%8A%A0%E6%8B%A6%E6%88%AA%E5%99%A8%E5%87%BD%E6%95%B0"><span class="nav-text">2. 添加拦截器函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%92%A4%E9%94%80-HTTP-%E8%AF%B7%E6%B1%82"><span class="nav-text">3. 撤销 HTTP 请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Axios-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="nav-text">（二）Axios 核心模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97"><span class="nav-text">HTTP 请求模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A8%A1%E5%9D%97"><span class="nav-text">拦截器模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E9%94%80%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97"><span class="nav-text">撤销请求模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axios-%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">axios 这样设计的好处是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="nav-text">发送请求函数的处理逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="nav-text">适配器的处理逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E9%94%80-HTTP-%E8%AF%B7%E6%B1%82%E7%9A%84%E9%80%BB%E8%BE%91"><span class="nav-text">撤销 HTTP 请求的逻辑</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">mohui</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">异步请求方法总结</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-06-14 23:04:14" itemprop="dateCreated datePublished" datetime="2021-06-14T23:04:14+08:00">2021-06-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-07-17 22:18:13" itemprop="dateModified" datetime="2021-07-17T22:18:13+08:00">2021-07-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>36k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>33 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="（一）AJAX概述"><a href="#（一）AJAX概述" class="headerlink" title="（一）AJAX概述"></a>（一）AJAX概述</h2><p>AJAX（Asynchronous JavaScript And <strong>XML</strong>，异步的JavaScript和XML），是一种实现<strong>无页面刷新</strong>获取服务器数据的<strong>混合技术</strong>。它能够使浏览器在不刷新页面的情况下获取服务器响应，这将大大提升互联网用户的使用体验，同时，由于AJAX请求获取的是数据而不是HTML文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。<a id="more"></a></p><h3 id="1-XML-和-JSONP"><a href="#1-XML-和-JSONP" class="headerlink" title="1. XML 和 JSONP"></a>1. XML 和 JSONP</h3><p>XML（Extensible Markup Language，可拓展标记语言）是一种类似HTML，用来描述数据是什么，并承载数据的标记语言。</p><p>而JSON仅仅是一种数据格式，在JSON发明之前，人们大量使用XML作为数据传输的载体，也正因如此，AJAX技术的最后一个字母为“X”。而如今情况则发生了些变化，JSON这种类似于字符串对象的轻量级的数据格式越来越受到开发者青睐，几乎变成了AJAX技术的标准数据格式。需要注意的是，JSON并不是XML的替代品，两者各自有其适应的场景。</p><h3 id="2-无页面刷新"><a href="#2-无页面刷新" class="headerlink" title="2. 无页面刷新"></a>2. 无页面刷新</h3><p>互联网最主要的功能在于资源交换，虽然在互联网中资源交换的主体都是计算机，但为了方便交流，我们通常将获取资源的一方称为客户端（主要的工具是浏览器），而将派发资源的一方称为服务端。</p><p>在AJAX技术出现之前，如果浏览器需要从服务器请求资源，其交互模式为“客户端发出请求 -&gt; 服务端接收请求并返回相应HTML文档 -&gt; 页面刷新，客户端加载新的HTML文档”。这种交互模式简洁明了，但是随着时代的进步，越来越多商业化网站的出现，使互联网不再局限于满足人们资源交换的需求，人们开始期待能够在互联网中获得更好的<strong>使用体验</strong>，而这种用户每次点击都会刷新页面的交互方式显然不够妥当。当用户点击页面中的某个按钮向服务器发送请求时，页面本质上可能只是一些数据发生了变化，而此时服务器却要将重绘的整个页面再返回给浏览器加载，这显然有悖于程序员的“DRY”原则，而且明明只是一些数据的变化却迫使服务器要返回整个HTML文档，这本身也会给网络带宽带来不必要的开销。</p><p>而AJAX能够在页面数据变动时，只向服务器请求新的数据，并且在阻止页面刷新的情况下，动态替换页面中展示的数据。AJAX技术的问世，不仅通过阻止浏览器接受响应时刷新页面提升了互联网用户的使用体验，还使开发者能够以更加微观的视角重新思考互联网应用的构建，在数据层面而非资源层面以更高的自由度构建网站和Web应用。</p><h3 id="3-混合技术"><a href="#3-混合技术" class="headerlink" title="3. 混合技术"></a>3. 混合技术</h3><p>AJAX技术并不只是操作<code>XMLHttpRequest</code>对象发起异步请求，而是为了实现<strong>无页面刷新的资源获取</strong>的一系列技术的统称，这些技术包括了：</p><ul><li>JavaScript：用来在获取数据后，通过操作DOM或其他方式达成目标；</li><li>客户端（即浏览器）提供的实现异步服务器通信的<code>XMLHttpRequest</code>对象；</li><li>服务器端允许浏览器向其发起AJAX请求的相关设置；</li></ul><p>明白AJAX并不只是操作<code>XMLHttpRequest</code>对象，对于初学者而言是十分必要的。</p><h2 id="（二）原生AJAX使用"><a href="#（二）原生AJAX使用" class="headerlink" title="（二）原生AJAX使用"></a>（二）原生AJAX使用</h2><h3 id="1-XMLHttpRequest对象"><a href="#1-XMLHttpRequest对象" class="headerlink" title="1. XMLHttpRequest对象"></a>1. XMLHttpRequest对象</h3><p><code>XMLHttpRequest</code>对象是浏览器提供的一个API，用来向服务器发送请求并解析服务器响应，整个过程中浏览器页面不会被刷新。<code>XMLHttpRequest</code>只是一个JavaScript对象，或者说是一个<strong>构造函数</strong>，它是由客户端(即浏览器)提供的（而不是JavaScript原生的）。它有属性和方法，需要通过<code>new</code>关键字进行实例化。</p><p><code>XMLHttpRequest</code>对象是不断被扩展的。随着XML对象被广泛的接收，W3C也开始着手制定相应的标准来规范其行为。目前，<code>XMLHttpRequest</code>有两个级别：1级提供了XML对象的实现细节，2级进一步发展了XML对象，额外添加了一些方法，属性和数据类型。但是并非所有浏览器都实现了XML对象2级的内容。</p><p>从一个XML对象的实例来剖析<code>XMLHttpRequest</code>实例的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br></pre></td></tr></table></figure><p>该实例的方法有：</p><ul><li><code>.open()</code>：准备启动一个AJAX请求；</li><li><code>.setRequestHeader()</code>：设置请求头部信息；</li><li><code>.send()</code>：发送AJAX请求；</li><li><code>.getResponseHeader()</code>: 获得响应头部信息；</li><li><code>.getAllResponseHeader()</code>：获得一个包含所有头部信息的长字符串；</li><li><code>.abort()</code>：取消异步请求；</li></ul><p>该实例的属性有：</p><ul><li><code>.responseText</code>：包含响应主体返回文本；</li><li><code>.responseXML</code>：如果响应的内容类型时<code>text/xml</code>或<code>application/xml</code>，该属性将保存包含着相应数据的XML DOM文档；</li><li><code>.status</code>：响应的HTTP状态；</li><li><code>.statusText</code>：HTTP状态的说明；</li><li><code>.readyState</code>：表示请求/响应过程的当前活动阶段</li></ul><p>浏览器还为该对象提供了一个<code>onreadystatechange</code>监听事件，每当XML实例的<code>readyState</code>属性变化时，就会触发该事件。</p><p>至此，关于XMLHttpRequest实例对象的属性方法就全部罗列完毕了，接下来，我们将更进一步的探究如何使用这些方法，属性完成发送AJAX请求的流程。</p><h3 id="2-准备AJAX请求"><a href="#2-准备AJAX请求" class="headerlink" title="2. 准备AJAX请求"></a>2. 准备AJAX请求</h3><p><code>.open()</code>方法接收三个参数：<strong>请求方式</strong>，<strong>请求URL地址</strong>和<strong>是否为异步请求的布尔值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该段代码会启动一个针对“example.php”的GET同步请求。</span></span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p><strong>① GET 与 POST</strong></p><ul><li>GET请求</li></ul><p>GET请求用于<strong>获取数据</strong>，有时需要获取的数据得通过查询参数进行定位，在这种情况下应将查询参数追加到URL的末尾，令服务器解析。查询参数是指一个由<code>?</code>号起始，由<code>&amp;</code>符号分割的包含相应键值对的字符串，用来告知浏览器所要查询的特定资源。查询字符串中每个参数的名和值都必须使用encodeURIComponent()进行编码（这是因为URL中有些字符会引起歧义，例如“&amp;”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> query = <span class="string">&quot;example.php?name=tom&amp;age=24&quot;</span> <span class="comment">// &quot;?name=tom&amp;age=24&quot;即是一个查询参数</span></span><br></pre></td></tr></table></figure><ul><li>POST请求</li></ul><p>POST请求用于<strong>向服务器发送应该被保存的数据</strong>，因此POST请求比GET请求多一份<strong>需要被保存的数据</strong>。需要发送的数据会作为<code>.send()</code>方法的参数最终被发往服务器，该数据可以是任意大小，任意类型。</p><p>这里需要注意以下两点：</p><ul><li><code>.send()</code>方法的参数是不可为空的，对于无需发送任何数据的GET请求，也需要在调用<code>.send()</code>方法时，向其传入<code>null</code>值；</li><li>服务器对待<strong>表单提交</strong>以及<strong>发送POST请求</strong>并不一视同仁，这意味着服务器需要有相应的代码专门处理POST请求发送来的原始数据。</li></ul><p>但好在我们可以通过POST请求模拟表单提交，只需要简单两步：</p><ol><li>设置请求头参数：<code>Content-Type: application/x-www-form-urlencoded</code>（表单提交时的内容类型）；</li><li>将表单数据序列化为查询字符串形式，传入<code>.send()</code>方法；</li></ol><p><strong>② 请求URL地址</strong></p><p>这里需要注意若使用相对路径，请求URL是<strong>相对于执行代码的当前页面</strong>。</p><p><strong>③ 同步请求与异步请求</strong></p><p>AJAX并非总是异步的，AJAX是避免页面在获取数据后刷新的一种技术，至于等待服务器响应的方式是同步还是异步，需要开发人员结合业务需求进行配置（虽然通常是异步的）。</p><h3 id="3-设置请求头"><a href="#3-设置请求头" class="headerlink" title="3. 设置请求头"></a>3. 设置请求头</h3><p>每个HTTP请求和响应都会带有一些与数据，收发者网络环境与状态相关的头部信息。XMLHttpRequest对象提供的<code>.setRequestHeader()</code>方法为开发者提供了一个操作这两种头部信息的方法，并允许开发者自定义请求头的头部信息。</p><p>默认情况下，当发送AJAX请求时，会附带以下头部信息：</p><ul><li><code>Accept</code>：浏览器能够处理的内容类型；</li><li><code>Accept-Charset</code>: 浏览器能够显示的字符集；</li><li><code>Accept-Encoding</code>：浏览器能够处理的压缩编码；</li><li><code>Accept-Language</code>：浏览器当前设置的语言；</li><li><code>Connection</code>：浏览器与服务器之间连接的类型；</li><li><code>Cookie</code>：当前页面设置的任何Cookie；</li><li><code>Host</code>：发出请求的页面所在的域；</li><li><code>Referer</code>：发出请求的页面URI；</li><li><code>User-Agent</code>：浏览器的用户代理字符串；</li></ul><p>部分浏览器不允许使用<code>.setRequestHeader()</code>方法重写默认请求头信息，因此自定义请求头信息是更加安全的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;myHeader&quot;</span>, <span class="string">&quot;MyValue&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-发送请求"><a href="#4-发送请求" class="headerlink" title="4. 发送请求"></a>4. 发送请求</h3><p>我们已经通过<code>.open()</code>方法确定了请求方式，等待响应的方式和请求地址，还通过<code>.setRequestHeader()</code>自定义了响应头，接下来需要使用<code>.send()</code>方法发送AJAX请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AJAX发送get请求</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;myHeader&quot;</span>, <span class="string">&quot;goodHeader&quot;</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AJAX发送post请求</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;myHeader&quot;</span>, <span class="string">&quot;bestHeader&quot;</span>)</span><br><span class="line">xhr.send(some_data)</span><br></pre></td></tr></table></figure><h3 id="5-处理响应"><a href="#5-处理响应" class="headerlink" title="5. 处理响应"></a>5. 处理响应</h3><p>处理一个同步的GET请求响应：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;myHeader&quot;</span>, <span class="string">&quot;goodHeader&quot;</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 由于是同步的AJAX请求，因此只有当服务器响应后才会继续执行下面的代码</span></span><br><span class="line"><span class="comment">// 因此xhr.status的值一定不为默认值</span></span><br><span class="line"><span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">    alert(xhr.responseText)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xhr<code>.status</code>属性存储着响应的HTTP状态，判断请求是否成功。如果成功，就将读取xhr<code>.responseText</code>属性中存储的返回值。但当请求为异步时，在<code>xhr.send(null)</code>语句被执行后，JavaScript引擎会紧接着执行下面的判断语句，而由于尚未来得及响应，此时会得到一个默认的xhr.status值，而不能获取到请求的资源。</p><p>所以我们需要通过为XMLHTTPRequest实例添加<code>onreadystatechange</code>事件处理程序（也可以直接使用DOM2级规范规定的<code>.addEventListener()</code>方法，但IE8不支持该方法）。</p><p>xhr实例的<code>readystatechange</code>事件会监听xhr<code>.readyState</code>属性的变化，你可以将这个属性想象为一个计数器，随着AJAX流程的推进而不断累加，其可取的值如下：</p><ul><li><strong>0</strong>：未初始化 – 尚未调用<code>.open()</code>方法；</li><li><strong>1</strong>：启动 – 已经调用<code>.open()</code>方法，但尚未调用<code>.send()</code>方法；</li><li><strong>2</strong>：发送 – 已经调用<code>.send()</code>方法，但尚未接收到响应；</li><li><strong>3</strong>：接收 – 已经接收到部分响应数据；</li><li><strong>4</strong>：完成 – 已经接收到全部响应数据，而且已经可以在客户端使用了；</li></ul><p>有了这个时间处理程序对AJAX进程做监听，剩下的事就简单多了，一个异步的GET请求代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readystate == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：为了确保跨浏览器的兼容性，必须要在调用<code>.open()</code>方法之前指定事件处理程序，毕竟<code>.open()</code>方法的执行也包含在该事件处理程序的监听范围之内。</p><hr><h3 id="6-取消异步请求"><a href="#6-取消异步请求" class="headerlink" title="6. 取消异步请求"></a>6. 取消异步请求</h3><p>有时可能要在接收到响应前取消异步请求，这时需要调用<code>.abort()</code>方法。该方法会令XHR对象实例停止触发事件，并且不再允许访问任何和响应有关的对象属性。当终止AJAX请求后，你需要手动对XHR对象实例进行解绑以释放内存空间。</p><h3 id="7-XMLHttpRequest-2级规范"><a href="#7-XMLHttpRequest-2级规范" class="headerlink" title="7. XMLHttpRequest 2级规范"></a>7. XMLHttpRequest 2级规范</h3><p>W3C提出了XMLHttpRequest 2级规范，虽然并非所有浏览器都实现了该规范所规定的内容。</p><h4 id="①-FormData-类型"><a href="#①-FormData-类型" class="headerlink" title="① FormData 类型"></a>① FormData 类型</h4><p>FormData是XMLHttpRequest 2级提供的新数据类型（构造函数），它能让POST请求伪装成表单进行提交的过程更加轻松，因为XHR对象能够识别传入的数据类型是FormData的实例，并自动配置适当的头部信息。</p><p>FormData的使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line"><span class="keyword">let</span> data1 = <span class="keyword">new</span> FormData()</span><br><span class="line">data1.append(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">xhr.send(data1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取表单数据</span></span><br><span class="line"><span class="keyword">let</span> data2 = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>])</span><br><span class="line">xhr.send(data2)</span><br></pre></td></tr></table></figure><p>FormData的另一个好处是相较于传统AJAX请求，它允许我们上传二进制数据（图片，视频，音频等），详情可查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects">链接</a>。</p><p>FormData的浏览器兼容性：</p><ul><li>桌面端：IE 10+ 与其他浏览器均支持</li><li>移动端：Android，Firefox Mobile，OperaMobile均支持，其余浏览器未知</li></ul><h4 id="②-超时设定"><a href="#②-超时设定" class="headerlink" title="② 超时设定"></a>② 超时设定</h4><p>为了避免发送AJAX请求后出现迟迟得不到服务器响应的情况，2级规范提供了一个额外的属性和事件监听事件：</p><ul><li><code>timeout</code>属性：设置超时时间，单位为毫秒；</li><li><code>timeout</code>事件：当响应时间超出实例对象timeout属性时被触发；</li></ul><p>使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当响应时间超过1秒时，请求中止，弹出提示框</span></span><br><span class="line">xhr.timeout = <span class="number">1000</span></span><br><span class="line">xhr.ontimeout = <span class="function">() =&gt;</span> &#123; alert(<span class="string">&quot;Request did not return in a second.&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>当请求终止时，会调用<code>ontimeout</code>事件处理程序，此时xhr的<code>readyState</code>属性的值可能已变为4，这意味着会继续调用<code>onreadystatechange</code>事件处理程序，但是当超时中止请求后再访问xhr的<code>status</code>属性会使浏览器抛出一个错误，因此需要将检查<code>status</code>属性的语句放入<code>try-catch</code>语句中。虽然这带来了一些麻烦，但却对XMLHttpRequest对象有了更多的控制。</p><p>浏览器兼容性：</p><ul><li>桌面端：IE 10+ 与其他浏览器均支持</li><li>移动端：IE Mobile 10+ 与其他浏览器均支持</li></ul><h4 id="③-overrideMimeType-方法"><a href="#③-overrideMimeType-方法" class="headerlink" title="③ overrideMimeType()方法"></a>③ overrideMimeType()方法</h4><p>响应返回的响应头里，描述了返回数据的MIME类型，浏览器通过识别该类型，告知XMLHttpRequest实例处理该数据的方式。如果我们想要以其它方式处理响应数据（例如将XML类型数据当做纯文本处理），可以使用<code>.overrideMimeType()</code>方法，该方法可以覆写响应头所描述数据的MIME类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.overrideMimeType(<span class="string">&quot;text/xml&quot;</span>) <span class="comment">// 强迫浏览器将响应数据以指定类型方式解读</span></span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>浏览器兼容性：</p><ul><li>桌面端：IE 7+ 与其他浏览器均支持</li><li>移动端：Firefox Mobile，Chrome for Android 均支持，其余浏览器未知</li></ul><h4 id="④-进度事件"><a href="#④-进度事件" class="headerlink" title="④ 进度事件"></a>④ 进度事件</h4><p>Progress Events规范是W3C制定的一个工作草案。该规范定义了客户端与服务器通信相关的一系列事件，这些事件监听了通信进程中的各个关键节点，使我们能够以更细的颗粒度掌控数据传输过程中的细节。目前共有6个进度事件，他们会随数据传输进展被顺序触发（除了error，abort事件），让我们看看他们的定义和浏览器兼容情况：</p><p><strong>loadstart</strong>：在接收到响应数据的第一个字节时触发；</p><ul><li>桌面端：除 Safari Mobile 未知外，其他浏览器均支持</li><li>移动端：除 Safari Mobile 未知外，其他浏览器均支持</li></ul><p><strong>progress</strong>：在接收响应期间持续不断地触发；</p><ul><li>桌面端：IE10+ 与其他浏览器均支持</li><li>移动端：均支持</li></ul><p><strong>error</strong>：在请求发生错误时触发；</p><ul><li>桌面端：所有浏览器均支持（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent">信息来源</a>）</li><li>移动端：除IE Mobile不支持外，其他浏览器均支持（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent">信息来源</a>）</li></ul><p><strong>abort</strong>：再因为调用abort()方法时触发；</p><ul><li>桌面端：未知</li><li>移动端：未知</li></ul><p><strong>load</strong>：在接收到完整的响应数据时触发；</p><ul><li>桌面端：IE7+ 与其他浏览器均支持</li><li>移动端：Chrome for Android，Edge，Firefox Mobile支持，其余浏览器未知</li></ul><p><strong>loadend</strong>：在通信完成或者触发error，abort 或 load 事件后触发；</p><ul><li>桌面端：所有浏览器不支持</li><li>移动端：所有浏览器不支持</li></ul><p>这里着重讲解以下两个事件：</p><p>① load事件</p><p>该事件帮助我们节省了<code>readstatechange</code>事件，我们不必在XHR对象实例上绑定该事件监听函数以追踪实例上<code>readState</code>属性的变化，而是可以直接使用以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt;<span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">        alert(xhr.responseText)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;Something wrong!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>② progress事件</p><p>该事件可以实现加载进度条效果。因为<code>onprogress</code>事件处理程序会接收到一个<code>event</code>对象，其<code>target</code>属性为XHR对象实例，但却额外包含着三个属性：</p><ul><li><code>lengthComputable</code>：表示进度信息是否可用的布尔值；</li><li><code>position</code>：表示目前接收的字节数；</li><li><code>totalSize</code>：表示根据Content-Length响应头部确定的预期字节数；</li></ul><p>显然加载进度条所需的一切资源都准备就绪，只需写出下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt;<span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">        alert(xhr.responseText)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;Something wrong!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载进度条</span></span><br><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> divStatus = <span class="built_in">document</span>.getElementById(<span class="string">&quot;status&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">        divStatus.innerHTML = <span class="string">`Received <span class="subst">$&#123;event.postion&#125;</span> of <span class="subst">$&#123;event.totalSize&#125;</span> bytes`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>要在<code>.open()</code>方法前调用<code>onprogress</code>事件处理程序。</p><h2 id="（三）jQuery-AJAX使用"><a href="#（三）jQuery-AJAX使用" class="headerlink" title="（三）jQuery AJAX使用"></a>（三）jQuery AJAX使用</h2><p>jQuery Ajax是对原生XHR的封装，除此以外还增添了对JSONP的支持。通过 jQuery AJAX 方法，能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON，同时还能把这些外部数据直接载入网页的被选元素中。</p><p>如果没有 jQuery，AJAX 编程还是有些难度的。编写常规的 AJAX 代码并不容易，因为不同的浏览器对 AJAX 的实现并不相同。这意味着必须编写额外的代码对浏览器进行测试。借助jQuery，只需要一行简单的代码就可以实现 AJAX 功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">   type: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">   url: url,</span><br><span class="line">   data: data,</span><br><span class="line">   dataType: dataType,</span><br><span class="line">   success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">   error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实例演示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../jquery/jquery-3.5.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">      $(<span class="built_in">document</span>).ready( <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;#b01&quot;</span>).click( <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          htmlobj = $.ajax(&#123; <span class="attr">url</span>: <span class="string">&quot;../code/02 CSS/index1-intro.html&quot;</span>, <span class="attr">async</span>: <span class="literal">false</span> &#125;);</span></span><br><span class="line"><span class="javascript">          $(<span class="string">&quot;#myDiv&quot;</span>).html(htmlobj.responseText);</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过 AJAX 改变文本<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;b01&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>改变内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而jQuery Ajax美中不足的是：</p><ul><li>本身是针对MVC的编程，不符合现在前端MVVM的浪潮</li><li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</li><li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常不合理（采取个性化打包的方案又不能享受CDN服务）</li></ul><p>尽管JQuery对前端的开发工作曾有着（现在也仍然有着）深远的影响，但随着VUE，REACT新一代框架的兴起，以及ES规范的完善，更多API的更新，JQuery这种大而全的JS库，未来的路会越走越窄。</p><h3 id="1-jQuery加载"><a href="#1-jQuery加载" class="headerlink" title="1. jQuery加载"></a>1. jQuery加载</h3><p>jQuery load() 方法从服务器加载数据，并把返回的数据放入被选元素中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).load(URL,data,callback);</span><br></pre></td></tr></table></figure><ul><li>必需的 <em>URL</em> 参数规定要加载的 URL。</li><li>可选的 <em>data</em> 参数规定与请求一同发送的查询字符串键/值对集合。</li><li>可选的 <em>callback</em> 参数是 load() 方法完成后所执行的回调函数。</li></ul><p>① 把文件 “demo_test.txt” 的内容加载到指定的</p><div>元素中：<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;);</span><br></pre></td></tr></table></figure><p>② 把 “demo_test.txt” 文件中 id=”p1” 的元素的内容，加载到指定的</p><div>元素中：<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#div1&quot;).load(&quot;demo_test.txt #p1&quot;);</span><br></pre></td></tr></table></figure><p>③ 可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数：</p><ul><li><em>responseTxt</em>：调用成功时的结果内容</li><li><em>statusTXT</em> ：调用的状态</li><li><em>xhr</em>：XMLHttpRequest 对象</li></ul><p>下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示“外部内容加载成功！”，而如果失败，则显示错误消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;#div1&quot;</span>).load(<span class="string">&quot;demo_test.txt&quot;</span>,<span class="function">(<span class="params">responseTxt,statusTxt,xhr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(statusTxt==<span class="string">&quot;success&quot;</span>)</span><br><span class="line">      alert(<span class="string">&quot;外部内容加载成功！&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(statusTxt==<span class="string">&quot;error&quot;</span>)</span><br><span class="line">      alert(<span class="string">&quot;Error: &quot;</span>+xhr.status+<span class="string">&quot;: &quot;</span>+xhr.statusText);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-jQuery-GET-POST"><a href="#2-jQuery-GET-POST" class="headerlink" title="2. jQuery GET/POST"></a>2. jQuery GET/POST</h3><p><strong>jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。</strong></p><ul><li><em>GET</em> - 从指定的资源请求数据</li><li><em>POST</em> - 向指定的资源提交要处理的数据</li></ul><p>GET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据。POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。</p><p><strong>jQuery $.get() 方法</strong></p><p>$.get() 方法通过 HTTP GET 请求从服务器上请求数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get(URL,callback);</span><br></pre></td></tr></table></figure><p>必需的 <em>URL</em> 参数规定您希望请求的 URL。可选的 <em>callback</em> 参数是请求成功后回调的函数。</p><p>下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $.get(<span class="string">&quot;demo_test.asp&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data,status</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;Data: &quot;</span> + data + <span class="string">&quot;\nStatus: &quot;</span> + status);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>$.get() 的第一个参数是我们希望请求的 URL（”demo_test.asp”）。第二个参数是回调函数。第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态。</p><p><strong>jQuery $.post() 方法</strong></p><p>$.post() 方法通过 HTTP POST 请求从服务器上请求数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.post(URL,data,callback);</span><br></pre></td></tr></table></figure><p>必需的 <em>URL</em> 参数规定您希望请求的 URL。可选的 <em>data</em> 参数规定连同请求发送的数据。可选的 <em>callback</em> 参数是回调函数。</p><p>下面的例子使用 $.post() 连同请求一起发送数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $.post(<span class="string">&quot;demo_test_post.asp&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    name:<span class="string">&quot;Donald Duck&quot;</span>,</span><br><span class="line">    city:<span class="string">&quot;Duckburg&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (data,status) =&gt; &#123;</span><br><span class="line">    alert(<span class="string">&quot;Data: &quot;</span> + data + <span class="string">&quot;\nStatus: &quot;</span> + status);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="（四）跨域获取同源资源"><a href="#（四）跨域获取同源资源" class="headerlink" title="（四）跨域获取同源资源"></a>（四）跨域获取同源资源</h2><p>AJAX技术使开发者能够专注于互联网中<strong>数据</strong>的传输，而不再拘泥于数据传输的<strong>载体</strong>。通过它，我们获取数据的方式变得更加灵活，可控和优雅。但AJAX技术并不是一把万能钥匙，互联网中的数据隐私和数据安全（例如银行账号和密码）非常重要，为了保护用户数据的隐私与安全，浏览器使用<strong>同源策略</strong>限制了AJAX技术获取数据的范围和能力。但有时我们不得不想办法绕过同源策略，实现跨域请求资源。因此跨域技术一直成为开发者们经久不衰的讨论话题。</p><h3 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1. 同源策略"></a>1. 同源策略</h3><p>互联网的数据要么存储在<strong>服务端</strong>（即服务器，如数据库、硬盘等）中，要么存储在<strong>客户端</strong>（即浏览器，如cookie，LocalStorage，sessionStorage）中。互联网数据的传输实际上就是客户端与服务端之间的交互。而所谓的数据隐私，说白了就是数据拥有者对数据索取者发出警告：“<strong>不是你的你别动</strong>”。如果你在客户端，想要获取服务端数据，首先需要通过服务器端的验证，证明你有权限获取数据；而如果你在服务端，想要获取客户端的某些数据，同样需要客户端通过某些方式验证你有资格获取相应的数据资源。</p><p>浏览器的同源策略是指：<strong>限制不同源之间执行特定操作</strong>。</p><p>① 一个<strong>源</strong>由<strong>协议</strong>，<strong>域名</strong>和<strong>端口</strong>三部分组成，这三者任意一个不同都会被浏览器识别为不同的源；</p><p>多数情况下，不同的源意味着它们在互联网中归属于不同的站点（或是不同的用途）。因此，它们可能是不同的项目，有不同的文件根目录，那么它们的数据自然不能共享，否则数据隐私和安全无法保障。</p><p>② 上文所提到的特定操作是指：</p><ul><li>读取 Cookie，LocalStorage 和 IndexDB；</li><li>获取 DOM 元素；</li><li>发送 AJAX 请求；</li></ul><p>假如浏览器允许我们执行这些特定操作，那会带来如下风险。<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004556040">cookie原理</a></p><p>首先，由于很多网站使用浏览器存储用户的账号和密码，那么便可以在A域中（在服务器上托管的网站）读取任意来访用户的所有Cookie信息（没有同源策略的保护，该用户所有网站的Cookie记录都是透明的），然后就能利用这些Cookie信息伪装成来访用户做任何事。正是出于同源政策的保护，我们只能访问用户该域下的Cookie信息，即服务端自己设置的Cookie信息。</p><p>其次，如果能够获取不同域下的DOM元素，我们就可以通过<code>&lt;iframe&gt;</code>标签在A域网站上引入B域网站，然后诱使用户在B域网站操作，由于我们能够跨域获取DOM元素，因此我们可以操作B域网站的DOM结构，用户输入的一切信息，以及用户操作的DOM元素都会被泄露。这正是同源策略想要规避的安全隐患。</p><p>当设置Cookie时，除了存放键值对形式的数据信息外，浏览器还会为Cookie的一些属性填充默认值（可手动修改属性值）。在这些属性中，domain代表域名，path代表路径，两者构成了一个确定这条Cookie何时被调用和访问的URL。与此同时，浏览器自己维护的Cookie文件中也会添加这一条新创建的Cookie数据。当在浏览器中发送HTTP请求时，浏览器首先会检查请求地址并在自己所维护的Cookie文件中寻找匹配的Cookie信息，将其添加到请求头中的<code>Cookie</code>属性内，然后向服务器发送请求。这个自动添加相应Cookie信息的过程是浏览器偷偷做的，即我们无法控制这个过程。当HTTP请求到达服务器时，服务器返回的响应中，响应头会原封不动返回浏览器发送给它的Cookie信息。我们虽然不能在发送请求前获得Cookie信息，但在发送请求后还是能够获得用户的Cookie！</p><p>再进一步解释一下这和AJAX的关系，假设我们在自己的服务器上托管了站点A，并在其中隐藏了一段脚本，每个登录站点A的人都会自动发送AJAX请求至站点B（假设站点B是一个银行），那么在没有浏览器同源策略的情况下，如果站点A中的访问者恰好有Cookie中保留站点B信息的用户，通过AJAX请求返回的响应头，我们一样可以拿到这位用户的站点B Cookie，从而伪装成用户在站点B登录，做一些违法乱纪的事情（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">CSRF</a>攻击即是利用了这个原理，只不过出于同源策略限制，并不能通过发起AJAX的方式）这也是为什么要禁止不同源的站点发送AJAX请求。<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004556040">https://segmentfault.com/a/1190000004556040</a>)</p><p>在浏览器同源策略的限制下，获取跨域Cookie，DOM结构和发送AJAX时的真实情况会是如下：</p><p>首先，我们在一个域下只能读取该域下的Cookie值。当我们在页面中使用<code>&lt;iframe&gt;</code>标签时，我们获取对应DOM节点下只有一个空空的<code>#document</code>节点，并没有额外的DOM信息。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210614230230.png" alt="image-20210330164155982" style="zoom:80%"><p>而对于AJAX，浏览器其实并没有阻止我们向不同域发送请求，其阻止的是这次请求的响应，也就是说服务端其实接收到了这次请求，只是响应被浏览器解析时被浏览器发现违背了同源策略而被拒绝，此时浏览器会在控制台中打印出一条错误信息。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/4/1601f323e28b9cd7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>另外对于XHR请求，实际上在请求报头也不会看到相应Cookie信息，因为CORS标准中规定默认情况下，浏览器在发送跨域请求时不能发送任何认证信息，比如<code>cookies</code>和<code>HTTP authentication schemes</code>。除非你显式地将<code>xhr</code>实例的<code>withCredentials</code>属性的值设置为<code>true</code>并且服务器端也允许客户端请求携带认证信息（即服务器端在响应头中设置了<code>Access-Control-Allow-Credentials: true</code>）。</p><h3 id="2-跨域请求资源方案"><a href="#2-跨域请求资源方案" class="headerlink" title="2. 跨域请求资源方案"></a>2. 跨域请求资源方案</h3><p>当我们拥有多个站点，并且这些站点又经常共享相同的数据，那么为每个站点存储一份数据看起来就蠢透了。更好的方案是，我们建设一台静态资源存储服务器，然后所有站点都从这一台服务器上获取资源。很理想的方案，但是现实中首要解决的问题便是浏览器的同源策略，不同域之间无法通过AJAX技术获取资源。这是需要跨域获取资源的主要情景。</p><p>主要介绍以下四种跨域请求资源的方案：</p><ol><li>野路子出身却好用的方式：JSONP；</li><li>官方推荐的跨域资源共享方案：CORS；</li><li>使用HTML5 API：postMessage；</li><li>抛弃HTTP，使用：Web Sockets；</li></ol><p><strong>无论是怎样的跨域资源获取方案，本质上都需要服务器端的支持</strong>。跨域获取资源之所以能够成功，本质是服务器默许了你有权限获取相应资源。下面所运用的种种方式，实际上是客户端和服务端互相配合，绕过同源策略进行数据交互的工作。</p><h4 id="①-JSONP"><a href="#①-JSONP" class="headerlink" title="① JSONP"></a>① JSONP</h4><p>正如标题所描述的那样，JSONP技术是早期的跨域资源获取方式，由于该技术的简单易用，逐渐变得流行，最终成为经典的跨域获取资源方案。JSONP是“JSON with padding”的简写，我将其翻译为“被包裹的JSON”。</p><p>首先，浏览器的同源策略<strong>只是阻止了通过AJAX技术跨域获取资源，而没有禁止跨域获取资源这件事本身</strong>，因此可以通过<code>&lt;link&gt;</code>标签<code>href</code>属性或<code>&lt;img&gt;</code>标签以及<code>&lt;script&gt;</code>标签中的<code>src</code>属性获取异域的CSS，JS资源和图片（其实并不能读取这些资源的内容）；其次，<code>&lt;script&gt;</code>标签通过<code>src</code>属性加载的JS资源，实际上只是将JS文件内容原封不动放置在<code>&lt;scritp&gt;</code>的标签内。</p><p>也就是说，如果sayHi.js文件只有这样一段代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sayHi.js</span></span><br><span class="line">alert(<span class="string">&#x27;Hi&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当我们在HTML文件中，成功加载sayHi.js文件时，浏览器只不过是做了如下操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 加载前 --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;sayHi.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 加载后 （为了方便阅读，我格式化了代码）--&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;sayHi.js&quot;</span>&gt;</span><br><span class="line">    alert(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这意味着被加载的文件与HTML文件下的其他JS文件共享一个全局作用域。也就是说，<code>&lt;scritp&gt;</code>标签加载到的资源是可以被全局作用域下的函数所使用。但如果<code>&lt;script&gt;</code>标签加载到的一些数据并不符合JavaScript语法规定的<strong>数据类型</strong>，JavaScript就无法处理这些错误，而且就算数据类型正常了，我们还应该将数据存储于一个<strong>变量</strong>内，然后调用这个变量。</p><p>但我们已经约定好了数据的格式为JSON，这是JavaScript可以处理的数据类型，并且JSON格式的数据可以承载大量信息。那么至于<strong>变量</strong>问题，我们则会通过向服务器传入一个函数的方式，将数据变为函数的参数，让我们直接看看JSONP的使用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">`You get the data : <span class="subst">$&#123;response&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">script.src = <span class="string">&#x27;http://somesite.com/json/?callback=handleResponse&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild)</span><br></pre></td></tr></table></figure><p>很容易看到，我们在1-3行中创建了一个函数，该函数用来处理我们将要获得的数据，该函数的参数<code>response</code>即是服务器响应的数据。在4-6行中我们所做的是利用JavaScript动态生成一个script标签，并将其插入HTML文档。但是注意第5行我们制定的src值，在URL末尾，我们有这样一段查询参数<code>callback=handleResponse</code>，callback的值正是我们先前创建的函数。</p><p>事情开始变得有些令人困惑了，究竟发生了什么呢？我们如何通过上述代码最终实现跨域获取资源？</p><p>答案就藏在服务端的代码中，当服务端支持JSONP技术时，会做如下一些设置：</p><ol><li>识别请求的URL，提取callback参数的值，并动态生成一个执行该参数值（一个函数）的JavaScript语句；</li><li>将需要返回的数据放入动态生成的函数中，等待其加在到页面时被执行；</li></ol><p>此时该文件内容看起来就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleResponse(response) <span class="comment">// response为被请求的JSON格式的数据</span></span><br></pre></td></tr></table></figure><p>因此，当资源加载到位，内容显示在script标签内时，浏览器引擎会执行这条语句，我们想要的数据就可以以任何想要的方式处理了。你现在知道为什么这项技术被命名为JSONP了吧？那个“padding”指的就是我们的“callback”函数，真是恰如其名。</p><p>最后，我们还要对JSONP技术再强调两点：</p><ol><li>JSONP技术与AJAX技术无关：虽然同样牵扯到跨域获取资源这个主题，但JSONP的本质是绕过AJAX获取资源的机制，使用原始的<code>src</code>属性获取异域资源；</li><li>JSONP技术存在三点缺陷：<ul><li>无法发送POST请求，也就是说JSONP技术只能用于请求异域资源，无法上传数据或修改异域数据；</li><li>无法监测JSONP请求是否失败；</li><li>可能存在安全隐患：JSONP之所以能成功获取异域服务器资源，靠的是服务器动态生成了回调函数，并在页面中执行，那么如果服务器在原有的回调函数下再添加些别的恶意JavaScript代码也会被执行！所以在使用JSONP技术时，一定要确保请求资源的服务器是值得信赖的；</li></ul></li></ol><p>虽然存在一些缺陷，但JSONP的浏览器兼容性却是非常好的，可以说是一种非常小巧高效的跨域资源获取技术。</p><hr><h4 id="②-CORS"><a href="#②-CORS" class="headerlink" title="② CORS"></a>② CORS</h4><p>CORS是W3C颁布的一个浏览器技术规范，其全称为“跨域资源共享”（Cross-origin resource sharing），它是由W3C官方推广的允许通过AJAX技术跨域获取资源的规范，因此相较于JSONP而言，功能更加强大，使用起来也没有了hack的味道。</p><p>关于CORS的具体细节，建议移步阮一峰的<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/04/cors.html">同主题博客</a>阅读。</p><p>如果想要绕过浏览器同源策略，通过AJAX技术跨域获取资源，这需要服务端和客户端的协同合作。而对于CORS标准而言，实现AJAX跨域获取资源，重点在于服务器端返回的响应是否清楚告知了浏览器此次跨域AJAX请求的合法性。</p><p>根据AJAX请求的复杂程度不同，服务器要向浏览器做出的说明程度也不同。</p><h5 id="简单的AJAX请求"><a href="#简单的AJAX请求" class="headerlink" title="简单的AJAX请求"></a>简单的AJAX请求</h5><ol><li>请求方法只属于<strong>HEAD</strong>，<strong>GET</strong>，<strong>POST</strong>请求的其中一种；</li><li>HTTP 的头信息只限于以下字段：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type（只能为<code>application/x-www-form-urlencoded</code>，<code>multipart/form-data</code>和<code>text/plain</code>其中一种）</li></ul></li></ol><p>而当浏览器检测到一个简单的跨域AJAX请求，浏览器会首先为我们添加一个头部信息：<code>Origin</code>。它的值为请求方所在的源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 ...</span><br></pre></td></tr></table></figure><p>而当这样的一条HTTP请求发送到服务端时，服务端会检测该请求报头中的<code>Origin</code>字段的值是否在许可范围内，如果的确是服务端认可的域，那么服务端会在响应报文中添加如下字段：</p><ul><li><code>Access-Control-Allow-Origin</code>（必须）：该字段用来告知浏览器服务端接受的能够发送跨域AJAX请求的域，它的值要么是该次AJAX请求报头中由浏览器自动添加的<code>Origin</code>值，要么是一个<code>*</code>号，表示可以接受任意的域名请求；</li><li><code>Access-Control-Allow-Credentials</code>（可选）：该字段用来告知浏览器是否允许客户端向服务端发送Cookie。默认情况下，CORS规范会阻止跨域AJAX向服务端发送Cookie，因此该字段默认值为<code>false</code>，当你显式的将该字段值设置为<code>true</code>时，则表示允许此次跨域AJAX向服务端发送Cookie；</li><li><code>Access-Control-Expose-Headers</code>（可选）：该字段用来向客户端暴露可获取的响应头。</li></ul><p>CORS规范规定，客户端<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：</p><ul><li><code>Cache-Control</code>：表示响应遵循的缓存机制；</li><li><code>Content-Language</code>：表示响应体的语言；</li><li><code>Content-Type</code>：表示响应体的MIME类型；</li><li><code>Expires</code>：表示文档的过期时间，到期不再缓存；</li><li><code>Last-Modified</code>：表示文档的最后改动时间；</li><li><code>Pragma</code>：用来包含特定的指令。如果客户端想获取额外的响应头字段时，就需要服务端通过在该字段后定义相应的客户端可获取的响应头字段名称。</li></ul><blockquote><p><strong>CORS规范中为什么默认不允许跨域AJAX请求携带Cookie ？</strong></p><p>在客户端与服务端数据传输的过程中，Cookie一直是以明文的形式伴随着数据的传输，只要客户端发送了Cookie到服务端，服务端就会至少返回该段Cookie。而大多数网站都使用Cookie短暂存储用户会话中的身份信息，因此将Cookie暴露在外是存在安全隐患的，CSRF攻击的目的便是获取用户的Cookie信息，因此在跨域AJAX请求中，为了减少Cookie泄露的风险，CORS规范默认禁止跨域AJAX请求携带Cookie。</p><p><strong>如果通过客户端与服务端相互配合，使得客户端能够携带Cookie信息？</strong></p><p>Ⅰ. 客户端：开发者需要在创建XMLHttpRequest对象实例时，手动配置<code>withCredentials</code>属性，将其值设置为<code>true</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>某些浏览器会默认允许在跨域AJAX请求中发送Cookie，此时如果不想要发送Cookie，只需要将其值设置为<code>false</code>。</p><p>Ⅱ. 服务端：对于服务端而言，除了要在响应报头设置<code>Access-Control-Allow-Credential</code>字段的值为<code>true</code>之外，为了保护客户端与服务端Cookie的隐私和安全，还需要为<code>Access-Control-Allow-Origin</code>字段设置一个明确的域，不可以再使用<code>*</code>号。</p></blockquote><h5 id="复杂的AJAX请求"><a href="#复杂的AJAX请求" class="headerlink" title="复杂的AJAX请求"></a>复杂的AJAX请求</h5><p>与简单AJAX跨域请求不同，复杂的AJAX跨域请求一共会发送两次HTTP请求，其中第一次为<strong>查询请求</strong>，第二次才是正式的<strong>AJAX跨域请求</strong>。当发送复杂的AJAX跨域请求时，浏览器拿到请求开始识别，然后发现这个请求不满足简单跨域AJAX请求标准，于是会询问服务端是否允许异域的客户端向它发送额外的请求信息，这即是第一次HTTP请求（查询请求）。而服务端会给出相应的回答，然后浏览器就会根据回答的结果决定是否继续发送该跨域AJAX请求。</p><p>一个复杂的AJAX跨域请求如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://another.com/cors&#x27;</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&#x27;put&#x27;</span>, url, <span class="literal">true</span>) <span class="comment">// 这里我们设置请求的方式为&#x27;put&#x27;</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;Value&#x27;</span>) <span class="comment">// 这里我们自定义了一个请求头字段</span></span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure><p>当浏览器识别到该请求不简单时，就会自动向服务器发送一个查询请求，其报头信息大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;thisOne.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: another.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0...</span><br></pre></td></tr></table></figure><p>注意这次查询请求使用了OPTIONS的请求方法，表明了这是一个查询请求。请求头部的信息说明了<strong>请求来源的域</strong>，<strong>请求使用的HTTP方法</strong>以及<strong>请求额外发送的头部字段</strong>。</p><p>当服务端接收到浏览器发来的查询请求后，如果允许接收客户端的请求，则会返回浏览器如下的响应报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache&#x2F;2.0.61（Unix）</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;thisOne.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header &#x2F;&#x2F; 该字段值为以“,”号分割的字符串</span><br><span class="line">Content-type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout&#x3D;2, max&#x3D;100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text&#x2F;plain</span><br></pre></td></tr></table></figure><ul><li><code>Access-Control-Allow-Origin</code>：向浏览器说明了发起AJAX请求的域是被服务器认可的（字段值也可以为一个“*”号）；</li><li><code>Access-Control-Allow-Methods</code>：说明了服务器接收跨域AJAX的请求方式；</li><li><code>Access-Control-Allow-Headers</code>：说明了服务器允许跨域AJAX额外发送的报头信息；</li></ul><p>当浏览器收到服务端同意请求的响应后，就会正常发送接下来的跨域AJAX请求，而服务器也会正常回应。在服务端与客户端整个跨域AJAX请求的交互中，<code>Access-Control-Allow-Origin</code>头信息自始至终都是必须携带的。</p><p>而如果服务器在收到查询请求后不同意该请求，则会返回一个正常的HTTP响应，报文中包含任何与CORS规范有关的报头字段，用来表示服务器拒绝接收客户端的跨域AJAX请求，因此浏览器会返回一个错误状态（可以被XML对象实例使用onerror回调函数捕获）并在控制台打印一条错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http:&#x2F;&#x2F;another.com</span><br><span class="line">Origin http:&#x2F;&#x2F;thisOne.com is not allowed by Access-Control-Allow-Origin</span><br></pre></td></tr></table></figure><p>对于复杂的跨域AJAX请求，浏览器会向服务器发送两次HTTP请求，但如果能够一次搞定，就无需每次请求都重复两次。对于服务器而言，一次搞定的方法就在于，在浏览器第一次发送复杂的跨域AJAX查询请求时，在响应报头中添加<code>Access-Control-Max-Age</code>字段，这是一个可选的字段，它用来指定本次查询请求的有效期，单位为秒。通过该字段，服务器拥有了告知浏览器“这个请求我准了，X秒以内不需要再向我确认”的能力。至此，接下来的跨域请求数由两次节约为一次。</p><h4 id="③-WebSocket"><a href="#③-WebSocket" class="headerlink" title="③ WebSocket"></a>③ WebSocket</h4><p>WebSocket是一种<strong>在单个TCP连接上进行全双工通讯的协议</strong>。HTML5标准之所以提出了这种新的互联网通信协议，是为了弥补在<strong>服务端与客户端的双向通信</strong>时使用HTTP协议通信的一些不足。但这并不意味WebSocket协议可以完全取代HTTP协议，两者都有各自擅长的领域，时不时还能一同协作解决难题。</p><p>当我们使用HTTP协议时，客户端与服务端的通信模式始终是由客户端向服务端发送请求，服务端只负责验证请求并返回响应。而客户端发送的每一个请求，对于服务端而言都是全新的，也即是说HTTP协议是<strong>无状态的</strong>。乍看似乎不合理，但这种设计却使服务器的工作变得简单可控，提升了服务器的工作效率。</p><p>但这样的设计仍然存在两个问题：</p><ol><li>每一个请求都需要身份验证，这对于用户而言意味着需要在每一次发送请求时输入身份信息；</li><li>当客户端所请求的资源是动态生成时，客户端无法在资源生成时得到通知；</li></ol><p>对于前者，可以使用<strong>Cookie</strong>解决，而对于后者，则轮到WebSocket大显身手。</p><p>在讨论WebSocket之前，让我们先稍微绕点路，谈谈“Cookie”是如何解决“每一个请求都需要身份验证”的问题的。</p><h5 id="Cookie：为HTTP协议添加状态"><a href="#Cookie：为HTTP协议添加状态" class="headerlink" title="Cookie：为HTTP协议添加状态"></a>Cookie：为HTTP协议添加状态</h5><p>HTTP协议下，客户端与服务端的通信是无状态的，即如果服务器中的某部分资源是由特定客户专属的，那么每当这个客户想要获取资源时，都需要先在浏览器中输入账号密码，然后再发送请求，并在被服务器识别身份信息成功后获取请求的资源。为了避免这般繁琐的操作，我们引入了Cookie：它既可以存储在浏览器，又会被浏览器发送HTTP请求时默认发送至服务端，并且还受浏览器同源策略保护，帮助我们提高发起一次请求的效率。</p><p>在有了Cookie后，我们可以在一次会话中（从用户登录到浏览器关闭）只输入一次账号密码，然后将其保存在Cookie中，在整个会话期间，Cookie都会伴随着HTTP请求的发送被服务器识别，从而避免了重复输入身份信息。</p><p>而且基于Cookie可以保存在浏览器内并在浏览器发送HTTP请求时默认携带的特性，服务端也可以操作Cookie。Cookie还可以帮助我们节省网络请求的发起数量。例如，在制作一个购物网站时，我们不希望用户在每添加一个商品到购物车就向服务器发送一个请求（请求数量越少，服务器压力就越小），此时我们可以将添加商品所导致的数据变动存储在Cookie内，然后等待下次发送请求时，一并发送给服务器处理。Cookie的出现，为无状态的HTTP协议通信添加了状态。</p><p>Cookie多数情况下都保存着用户的身份信息，因此对于Cookie的恶意攻击层出不穷。其本质上就是想要获得用户的Cookie，再利用其中的身份信息伪装成用户获取相应资源，而浏览器的同源策略本质上就是保护用户的Cookie信息不会泄露。</p><h5 id="WebSocket：让服务器也动起来"><a href="#WebSocket：让服务器也动起来" class="headerlink" title="WebSocket：让服务器也动起来"></a>WebSocket：让服务器也动起来</h5><p><strong>客户端无法获知请求的动态资源何时到位</strong>。有时候客户端想要请求的资源，服务器需要一定时间后才能返回（比如该资源依赖于其他服务器的计算返回结果），由于在HTTP协议下，网络通信是单向的，因此服务器并不具备当资源准备就绪时，通知浏览器的功能（要保障服务器的工作效率）。因此，基于HTTP协议通常的做法是，设置一个定时器，每隔一定时间由浏览器向服务器发送一次请求以探测资源是否到位。这种做法显然浪费了很多请求或者说带宽（每个请求都要携带Cookie和报头，这些都会占用带宽传输），低效且不够优雅。</p><p>我们希望当服务器资源到位时，能主动通知浏览器并返回相应资源。为了实现这一点，HTML5标准推出了WebSocket协议，使浏览器和服务器实现了双向通信。除了IE9及以下的IE浏览器，所有的浏览器都支持WebSocket协议。</p><p>客户端告知服务端要升级为WebSocket协议的报头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure><p>服务端向客户端返回的响应报头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><h5 id="客户端如何发起WebSocket请求"><a href="#客户端如何发起WebSocket请求" class="headerlink" title="客户端如何发起WebSocket请求"></a>客户端如何发起WebSocket请求</h5><p>像发起AJAX请求一样，发起WebSocket请求需要借助浏览器提供的<code>WebSocket</code>对象，该对象提供了用于创建和管理WebSocket连接，以及通过该连接收发数据的API。所有的浏览器都默认提供了WebSocket对象。</p><p>和使用<code>XHRHttpRequest</code>对象一样，我们首先要实例化一个<code>WebSocket</code>对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://echo.websocket.org&quot;</span>)</span><br></pre></td></tr></table></figure><p>传入的参数为响应WebSocket请求的地址。</p><p>与AJAX类似的是，<code>WebSocket</code>对象也有一个<code>readyState</code>属性，用来表示对象实例当前所处的链接状态，有四个值：</p><ul><li><strong>0</strong>：表示正在连接中（CONNECTING）；</li><li><strong>1</strong>：表示连接成功，可以通信（OPEN）；</li><li><strong>2</strong>：表示连接正在关闭（CLOSING）；</li><li><strong>3</strong>：表示连接已经关闭或打开连接失败（CLOSED）；</li></ul><p>可以通过判断这个值来执行相应的代码。</p><p>除此之外，<code>WebSocket</code>对象还提供一系列事件属性来控制连接过程中的通信行为：</p><ul><li><code>onopen</code>：用于指定连接成功后的回调函数；</li><li><code>onclose</code>：用于指定连接关闭后的回调函数；</li><li><code>onmessage</code>：用于指定收到服务器数据后的回调函数；</li><li><code>onerror</code>：用于指定报错时的回调函数；</li></ul><p>通过<code>.send()</code>方法，我们拥有了向服务器发送数据的能力（WebSocket还允许我们发送二进制数据）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">&#x27;Hi, server!&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>WebSocket</code>对象的<code>bufferedAmount</code>属性的返回值表示了还有多少字节的二进制数据没有发送出去，所以可以通过判断该值是否为0而确定数据是否发送结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1000000</span>)</span><br><span class="line">ws.send(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 还在发送</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebSocket是如何绕过浏览器的同源策略实现跨域资源共享，那就是<strong>当客户端与服务端创建WebSocket连接后，本身就可以天然的实现跨域资源共享</strong>，WebSocket协议本身就不受浏览器同源策略的限制（同源策略只限制了跨域的AJAX请求）。</p><p>但如果没有浏览器同源策略的限制，那么用户的Cookie安全又由谁来保护呢？Cookie的存在就是为了给无状态的HTTP协议通讯添加状态，因为Cookie是明文传输的，且通常包含用户的身份信息，所以非常受到网络攻击者的“关注”。但是想想WebSocket协议下的通讯机制，客户端和服务端一旦建立连接，就可以顺畅互发数据，因此WebSocket协议本身就是“<strong>有状态的</strong>”，不需要Cookie的帮忙，既然没有Cookie，自然也不需要同源策略去保护，因此其实这个问题也不成立。</p><h4 id="④-postMessage"><a href="#④-postMessage" class="headerlink" title="④ postMessage"></a>④ postMessage</h4><p>JSONP，CORS 与WebSocket 这些跨域技术都只适用于客户端请求异域服务端资源的情景。而有时候我们需要在异域的两个客户端之间共享数据，例如页面与内嵌iframe窗口通讯，页面与新打开异域页面通讯。</p><p>使用<code>postMessage</code>技术实现跨域的原理非常简单，一方面，主窗口通过<code>postMessage</code>API向异域的窗口发送数据，另一方面我们在异域的页面脚本中始终监听<code>message</code>事件，当获取主窗口数据时处理数据或者以同样的方式返回数据从而实现跨窗口的异域通讯。</p><p>让我们用具体的业务场景与代码进一步说明，假如我们的页面现在有两个窗口，窗口1命名为“window_1”， 窗口2命名为“window_2”，当然，窗口1与窗口2的“域”是不同的，我们的需求是由窗口1向窗口2发送数据，而当窗口2接收到数据时，将数据再返回给窗口1。先让我们看看窗口1<code>script</code>标签内的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window_1 域名为 http://winodow1.com:8080</span></span><br><span class="line"><span class="built_in">window</span>.postMessage(<span class="string">&quot;Hi, How are you!&quot;</span>, <span class="string">&quot;http://window2.com:8080&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到，<code>postMessage</code>函数接收两个参数，第一个为要发送的信息（可以是任何JavaScript类型数据，但部分浏览器只支持字符串格式），第二个为信息发送的目标地址。让我们再看看窗口2<code>script</code>标签内的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window_2 域名为 http://window2.com:8080</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;message&quot;</span>, receiveMessage, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对于Chorme，origin属性为originalEvent.origin属性</span></span><br><span class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin</span><br><span class="line">    <span class="keyword">if</span> (origin !== <span class="string">&quot;http://window1.com:8080&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.postMessage(<span class="string">&quot;I\&#x27;m ok&quot;</span>, <span class="string">&quot;http://window1.com:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在window上绑定了一个事件监听函数，监听<code>message</code>事件。一旦我们接收到其他域通过<code>postMessage</code>发送的信息，就会触发<code>receiveMessage</code>回调函数。该函数会首先检查发送信息的域是否是我们想要的，如果验证成功则会向窗口1发送一条消息。</p><p>一方发送信息，一方捕捉信息。但是所有跨域技术都需要关注安全问题。postMessage技术之所以能实现跨域资源共享，本质上依赖于客户端脚本设置了相应的<code>message</code>监听事件。因此只要有消息通过<code>postMessage</code>发送过来，我们的脚本都会接收并进行处理。由于任何域都可以通过<code>postMessage</code>发送跨域信息，因此对于设置了事件监听器的页面来说，判断到达页面的信息是否是安全的是非常重要的事，因为我们并不想要执行有危险的数据。</p><p>那么如何鉴别发送至页面的信息呢？答案是通过 <code>message</code>事件监听函数的事件对象，我们称它为<code>event</code>，该对象有三个属性：</p><ul><li><strong>data</strong>：值为其他window传递过来的对象；</li><li><strong>origin</strong>：值为消息发送方窗口的域名；</li><li><strong>source</strong>：值为对发送消息的窗口对象的引用；</li></ul><p>应该着重检测<code>event</code>对象的<code>origin</code>属性，建立一个白名单对<code>origin</code>属性进行检测通常是一个明智的做法。</p><p>最后，除了IE8以下的IE浏览器，所有的浏览器都支持postMessage方法！</p><h1 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h1><h2 id="（一）Fetch实现"><a href="#（一）Fetch实现" class="headerlink" title="（一）Fetch实现"></a>（一）Fetch实现</h2><p>fetch号称是ajax的替代品，它的API是基于Promise设计的，旧版本的浏览器不支持Promise，需要使用polyfill es6-promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        ajax(url, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            resolve(res);</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（二）Fetch实例"><a href="#（二）Fetch实例" class="headerlink" title="（二）Fetch实例"></a>（二）Fetch实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生XHR</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText)   <span class="comment">//从服务器获取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch</span></span><br><span class="line">fetch(url)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">            <span class="keyword">return</span> response.json(); <span class="comment">//服务器返回的是json格式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>由于Fetch底层是用Promise实现，可以直接用async来优化上面的代码，减少回调，使其更加语义化、容易理解。async/await是ES7的API，目前还在试验阶段，还需要使用babel进行转译成ES5代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（三）Fetch使用"><a href="#（三）Fetch使用" class="headerlink" title="（三）Fetch使用"></a>（三）Fetch使用</h2><p>两种调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, options)</span><br><span class="line">fetch(req, options)</span><br></pre></td></tr></table></figure><p>推荐使用第一种，一眼就可以看到url，更加直观。</p><p>options 是一个对象，可设置以下字段：</p><ol><li><strong>method</strong>：请求方法，默认GET；</li><li><strong>headers</strong>：请头信息，可以是简单的对象，也可以是 <code>Headers</code> 的实例；</li><li><strong>body</strong>：发送数据。<code>Blod</code>、<code>bufferSource</code>、<code>FormData</code>、<code>URLSearchParams</code>、<code>USVstring</code>（GET、HEAD 没有body）；</li><li><strong>mode</strong>：请求模式。<ul><li>cors：跨域请求；</li><li>no-cors：只允许使用<code>GET</code>、<code>HEAD</code>、<code>POST</code>；</li><li>same-origin：同源请求；</li><li>navigate：支持页面导航。</li></ul></li><li><strong>credentials</strong>：是否发送cookies<ul><li>omit：不发送，默认；</li><li>same-origin：同源发送；</li><li>include：发送。</li></ul></li><li><strong>cache</strong>：缓存策略：<ul><li>default：请求之前检查缓存；</li><li>no-cache：有缓存，发送一个查询请求，缓存失效，再发送正常请求；</li><li>no-store：不检查缓存，直接请求；</li><li>reload：忽略缓存，拿到响应后，更新缓存；</li><li>force-cache：强制读取缓存，缓存过期，再发送正常请求；</li><li>only-if-cached：读取缓存，过期就报网络错误。 mode 设置为 <code>same-origin</code> 时有效。</li></ul></li><li><strong>redirect</strong>：重定向时的处理方法：<ul><li>follow：跟随；</li><li>error：报错；</li><li>manual：用户手动跟随。</li></ul></li><li><strong>integrity</strong>：包含一个验证资源完整性的字符串。</li></ol><p>fetch是比较底层的API，很多情况下都需要我们再次封装。 比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jquery ajax</span></span><br><span class="line">$.post(url, &#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch</span></span><br><span class="line">fetch(url, &#123;</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    body: <span class="built_in">Object</span>.keys(&#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;).map(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">encodeURIComponent</span>(key) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(params[key]);</span><br><span class="line">    &#125;).join(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于fetch是比较底层的API，所以需要我们手动将参数拼接成’name=test’的格式，而jquery ajax已经封装好了。所以fetch并不是开箱即用的。</p><h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>Headers 用于构造请求头信息，构造函数接收一个对象，对象的<code>key-value</code>就是请求头的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> headers = <span class="keyword">new</span> Headers(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&#x27;content-type&#x27;</span>:<span class="string">&#x27;text/plain&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;content-length&#x27;</span>:data.toString().length</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">headers.append(<span class="string">&#x27;X-Custom-header&#x27;</span>,<span class="string">&#x27;AnotherValue&#x27;</span>); <span class="comment">//追加</span></span><br><span class="line">headers.has(<span class="string">&#x27;content-type&#x27;</span>); <span class="comment">//true 查询</span></span><br><span class="line">headers.get(<span class="string">&#x27;content-type&#x27;</span>); <span class="comment">//&#x27;text/plain&#x27; 获取</span></span><br><span class="line"><span class="comment">// headers.getAll(&#x27;content-type&#x27;); //[&#x27;text/plain&#x27;] getAll 被移除了</span></span><br><span class="line">headers.delete(<span class="string">&#x27;content-type&#x27;</span>); <span class="comment">//删除</span></span><br><span class="line">headers.set(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;json&#x27;</span>); <span class="comment">//重写</span></span><br></pre></td></tr></table></figure><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>请求对象。可以新建一个，也可以从已有的对象中继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Url = <span class="string">&#x27;/users&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> req = <span class="keyword">new</span> Request(Url, &#123;<span class="attr">method</span>:<span class="string">&#x27;GET&#x27;</span>, headers&#125;)</span><br><span class="line"><span class="comment">// 扩展 request</span></span><br><span class="line"><span class="keyword">let</span> postReq= <span class="keyword">new</span> Requset(req, &#123;<span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>Response 实例是 fertch 处理完 promise 之后的返回的。也可以手动创建，在<code>servoceWorkers</code> 中才真实有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = <span class="keyword">new</span> Response(body, init)</span><br></pre></td></tr></table></figure><p>body 可以是<code>Blob</code>、<code>BufferSource</code>、<code>FormData</code>、<code>URLSearchParams</code>、<code>USVString</code> 这些值。</p><p>init 是一个对象，可包含以下字段：</p><ul><li>status：响应状态码；</li><li>statusText：状态文本；</li><li>headers：头部信息，普通对象或Headers 的实例。</li></ul><p>response 的实例还有一些可读属性：</p><ul><li>ok：请求是否成功，状态码为 2xx 都为 <code>true</code> ；</li><li>status：状态码；</li><li>statusText：状态文本；</li><li>bodyUsed：响应数据是否被用过；</li><li>headers：头部信息；</li><li>url：响应地址；</li><li>type：响应类型：<ul><li>basic：同源；</li><li>cors：跨域；</li><li>error：出错；</li><li>opaque：Request mode 设置为 <code>no-cors</code> 的响应。</li></ul></li></ul><blockquote><p>当发起一个Fetch请求时，返回的response响应会自带一个response.type属性（basic、cors、opaque）。response.type属性说明了异步资源的来源和其相应的处理方式。</p><p>当我们发起一个同源请求时，response.type为basic，我们可以从response读取全部信息。</p><p>当访问一个非同源域名，并且有返回相应的CORs响应头时，那么该请求类型是cors。在cors响应里无法访问<code>Cache-Control</code>，<code>Content-Language</code>，<code>Content-Type</code>，<code>Expires</code>，<code>Last-Modified</code>和<code>Pragma</code>。</p><p>当对一个不同源的域名发起请求时，如果返回的响应头部没有CORS信息，那么这个response对应的类型就是opaque类型。一个opaque响应是无法读取返回的数据、状态，甚至无法确定这个请求是否成功。</p><p>我们可以自定义Fetch请求的模式，要求返回对应类型的响应，有以下几种响应：</p><ol><li>same-origin 只返回同源请求，其他类型会被reject</li><li>cors 接收同源、非同源请求，返回有CORs头部的响应</li><li>cors-with-forced-preflight 在发出请求前会先做一次安全性检查</li><li>no-cors 用来发起没有CORS头部并且非同源请求，并且会返回opaque响应。但是目前这种类型只能在Service Worker里使用，在window.fetch里不能用</li></ol></blockquote><p>response 有一些方法来 reslove 响应信息。</p><ul><li>json，解析响应信息为对象，resolve promise；</li><li>text</li><li>blob</li><li>formData</li><li>arrayBuffer</li></ul><h2 id="（四）Fetch缺点"><a href="#（四）Fetch缺点" class="headerlink" title="（四）Fetch缺点"></a>（四）Fetch缺点</h2><ul><li>当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时才会标记为 reject；</li><li>默认情况下，fetch 不会从服务端发送或接收任何 cookies，如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）；</li><li>POST 的数据需要转为JSON;</li><li>不能设置超时和取消请求，可以通过<code>Promise.race</code>，模拟两者；</li><li>文件上传和下载获取不到进度。response.body 是可读流，具有<code>getReader</code>，可根据这个来获取下载进度；</li><li>不能直接获取到响应数据，需要调用响应方法，resolve 一下；</li></ul><h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>axios是Vue官方推荐使用的，它也是对原生XHR的封装。它有以下几大特性：</p><ul><li>可以在node.js中使用</li><li>提供了并发请求的接口</li><li>支持Promise API</li></ul><h2 id="（一）Axios使用"><a href="#（一）Axios使用" class="headerlink" title="（一）Axios使用"></a>（一）Axios使用</h2><h3 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1. 发送请求"></a>1. 发送请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  url:<span class="string">&#x27;http://bit.ly/2mTM3nY&#x27;</span>,</span><br><span class="line">  responseType:<span class="string">&#x27;stream&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.data.pipe(fs.createWriteStream(<span class="string">&#x27;ada_lovelace.jpg&#x27;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>axios 的用法与 jQuery 的 <code>ajax</code> 方法非常类似，两者都返回一个 Promise 对象（在这里也可以使用成功回调函数，但更推荐使用 <code>Promise</code> 或 <code>await</code>），然后再进行后续操作。</p><h3 id="2-添加拦截器函数"><a href="#2-添加拦截器函数" class="headerlink" title="2. 添加拦截器函数"></a>2. 添加拦截器函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个请求拦截器。注意，这里面有两个函数：分别是成功和失败时的回调函数，这样设计的原因会在之后介绍</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 发起请求前执行一些处理任务</span></span><br><span class="line">    <span class="keyword">return</span> config; <span class="comment">// 返回配置信息</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 请求错误时的处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理响应数据</span></span><br><span class="line">    <span class="keyword">return</span> response; <span class="comment">// 返回响应数据</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 响应出错后所做的处理工作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>发送请求之前，我们可以对请求的配置参数（<code>config</code>）做处理；在请求得到响应之后，我们可以对返回数据做处理。当请求或响应失败时，我们还能指定对应的错误处理函数。</p><h3 id="3-撤销-HTTP-请求"><a href="#3-撤销-HTTP-请求" class="headerlink" title="3. 撤销 HTTP 请求"></a>3. 撤销 HTTP 请求</h3><p>在开发与搜索相关的模块时，我们经常要频繁地发送数据查询请求。一般来说，当发送下一个请求时，需要撤销上个请求。因此，能撤销相关请求的功能非常有用。axios 撤销请求的示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子一</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求撤销了&#x27;</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子二</span></span><br><span class="line">axios.post(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  name: <span class="string">&#x27;新名字&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销请求 (信息参数是可选的)</span></span><br><span class="line">source.cancel(<span class="string">&#x27;用户撤销了请求&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在 axios 中，使用基于 <code>CancelToken</code> 的撤销请求方案。然而该提案现已撤回，详情 <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-cancelable-promises">点这里</a>。具体的撤销请求的实现方法，将在后面的源代码分析的中解释。</p><h2 id="（二）Axios-核心模块"><a href="#（二）Axios-核心模块" class="headerlink" title="（二）Axios 核心模块"></a>（二）Axios 核心模块</h2><p>下面将根据模块分析 axios 的设计和实现。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20210614225916.png" alt="image-20210409195435367" style="zoom:67%"><h3 id="HTTP-请求模块"><a href="#HTTP-请求模块" class="headerlink" title="HTTP 请求模块"></a>HTTP 请求模块</h3><p>请求模块的代码放在了 <code>core/dispatchRequest.js</code> 文件中，这里只展示了一些关键代码来简单说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    throwIfCancellationRequested(config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他源码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认适配器是一个模块，可以根据当前环境选择使用 Node 或者 XHR 发送请求。</span></span><br><span class="line">    <span class="keyword">var</span> adapter = config.adapter || defaults.adapter; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adapter(config).then(<span class="function"><span class="keyword">function</span> <span class="title">onAdapterResolution</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        throwIfCancellationRequested(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他源码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> <span class="title">onAdapterRejection</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isCancel(reason)) &#123;</span><br><span class="line">            throwIfCancellationRequested(config);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其他源码</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们能够知道 <code>dispatchRequest</code> 方法是通过 <code>config.adapter</code> 获得发送请求模块的。可以通过传递符合规范的适配器函数来替代原来的模块（一般不会这样做，但它是一个松散耦合的扩展点）。</p><p>在 <code>defaults.js</code> 文件中，我们可以看到相关适配器的选择逻辑——根据当前容器的一些独特属性和构造函数，来确定使用哪个适配器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDefaultAdapter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> adapter;</span><br><span class="line">    <span class="comment">// 只有在 Node.js 中包含 process 类型对象时，才使用它的请求模块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> process !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(process) === <span class="string">&#x27;[object process]&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// Node.js 请求模块</span></span><br><span class="line">        adapter = <span class="built_in">require</span>(<span class="string">&#x27;./adapters/http&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 浏览器请求模块</span></span><br><span class="line">        adapter = <span class="built_in">require</span>(<span class="string">&#x27;./adapters/xhr&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>axios 中的 XHR 模块相对简单，它是对 <code>XMLHTTPRequest</code> 对象的封装，源码位于 <code>adapters/xhr.js</code> 文件中。</p><h3 id="拦截器模块"><a href="#拦截器模块" class="headerlink" title="拦截器模块"></a>拦截器模块</h3><p>现在让我们看看 axios 是如何处理请求和响应拦截器函数的。这就涉及到了 axios 中的统一接口 ——<code>request</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他源码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">        promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数是 axios 发送请求的接口。因为函数实现代码相当长，这里简单讨论相关设计思想：</p><ol><li><code>chain</code> 是一个执行队列。队列的初始值是一个携带配置（<code>config</code>）参数的 Promise 对象。</li><li>在执行队列中，初始函数 <code>dispatchRequest</code> 用来发送请求，为了与 <code>dispatchRequest</code>对应，我们添加了一个 <code>undefined</code>。添加 <code>undefined</code> 的原因是需要给 Promise 提供成功和失败的回调函数，从<code>promise = promise.then(chain.shift(), chain.shift());</code> 就能看出来。因此，函数 <code>dispatchRequest</code> 和 <code>undefiend</code> 可以看成是一对函数。</li><li>在执行队列 <code>chain</code> 中，发送请求的 <code>dispatchReqeust</code> 函数处于中间位置。它前面是请求拦截器，使用 <code>unshift</code> 方法插入；它后面是响应拦截器，使用 <code>push</code> 方法插入，在 <code>dispatchRequest</code> 之后。需要注意的是，这些函数都是成对的，也就是一次会插入两个。</li></ol><h3 id="撤销请求模块"><a href="#撤销请求模块" class="headerlink" title="撤销请求模块"></a>撤销请求模块</h3><p>与撤销请求相关的模块位于 <code>Cancel/</code> 文件夹下，现在我们来看下相关核心代码。</p><p>首先，我们来看下基础 <code>Cancel</code> 类。它是一个用来记录撤销状态的类，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cancel</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cancel.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Cancel&#x27;</span> + (<span class="built_in">this</span>.message ? <span class="string">&#x27;: &#x27;</span> + <span class="built_in">this</span>.message : <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Cancel.prototype.__CANCEL__ = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>使用 <code>CancelToken</code> 类时，需要向它传递一个 Promise 方法，用来实现 HTTP 请求的撤销，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CancelToken</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> executor !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;executor must be a function.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resolvePromise;</span><br><span class="line">    <span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">promiseExecutor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        resolvePromise = resolve;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> token = <span class="built_in">this</span>;</span><br><span class="line">    executor(<span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (token.reason) &#123;</span><br><span class="line">            <span class="comment">// 已经被撤销了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        token.reason = <span class="keyword">new</span> Cancel(message);</span><br><span class="line">        resolvePromise(token.reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CancelToken.source = <span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cancel;</span><br><span class="line">    <span class="keyword">var</span> token = <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        cancel = c;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        token: token,</span><br><span class="line">        cancel: cancel</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>adapters/xhr.js</code> 文件中，撤销请求的地方是这样写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line">    <span class="comment">// 等待撤销</span></span><br><span class="line">    config.cancelToken.promise.then(<span class="function"><span class="keyword">function</span> <span class="title">onCanceled</span>(<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.abort();</span><br><span class="line">        reject(cancel);</span><br><span class="line">        <span class="comment">// 重置请求</span></span><br><span class="line">        request = <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的撤销 HTTP请求的例子，让我们简要地讨论一下相关的实现逻辑：</p><ol><li>在需要撤销的请求中，调用 <code>CancelToken</code> 类的 <code>source</code> 方法类进行初始化，会得到一个包含 <code>CancelToken</code> 类实例 A 和 <code>cancel</code> 方法的对象。</li><li>当 source 方法正在返回实例 A 的时候，一个处于 pending 状态的 <code>promise</code> 对象初始化完成。在将实例 A 传递给 axios 之后，<code>promise</code> 就可以作为撤销请求的触发器使用了。</li><li>当调用通过 <code>source</code> 方法返回的 <code>cancel</code> 方法后，实例 A 中 <code>promise</code> 状态从 pending 变成 fulfilled，然后立即触发 <code>then</code> 回调函数。于是 axios 的撤销方法——<code>request.abort()</code> 被触发了。</li></ol><h2 id="axios-这样设计的好处是什么？"><a href="#axios-这样设计的好处是什么？" class="headerlink" title="axios 这样设计的好处是什么？"></a>axios 这样设计的好处是什么？</h2><h3 id="发送请求函数的处理逻辑"><a href="#发送请求函数的处理逻辑" class="headerlink" title="发送请求函数的处理逻辑"></a>发送请求函数的处理逻辑</h3><p>如前几章所述，axios 不将用来发送请求的 <code>dispatchRequest</code> 函数看做一个特殊函数。实际上，<code>dispatchRequest</code> 会被放在队列的中间位置，以便保证队列处理的一致性和代码的可读性。</p><h3 id="适配器的处理逻辑"><a href="#适配器的处理逻辑" class="headerlink" title="适配器的处理逻辑"></a>适配器的处理逻辑</h3><p>在适配器的处理逻辑上，<code>http</code> 和 <code>xhr</code> 模块（一个是在 Node.js 中用来发送请求的，一个是在浏览器里用来发送请求的）并没有在 <code>dispatchRequest</code> 函数中使用，而是各自作为单独的模块，默认通过 <code>defaults.js</code> 文件中的配置方法引入的。因此，它不仅确保了两个模块之间的低耦合，而且还为将来的用户提供了定制请求发送模块的空间。</p><h3 id="撤销-HTTP-请求的逻辑"><a href="#撤销-HTTP-请求的逻辑" class="headerlink" title="撤销 HTTP 请求的逻辑"></a>撤销 HTTP 请求的逻辑</h3><p>在撤销 HTTP 请求的逻辑中，axios 设计使用 Promise 来作为触发器，将 <code>resolve</code> 函数暴露在外面，并在回调函数里使用。它不仅确保了内部逻辑的一致性，而且还确保了在需要撤销请求时，不需要直接更改相关类的样例数据，以避免在很大程度上入侵其他模块。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JavaScript/" rel="tag"># JavaScript</a> <a href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag"># 异步</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E8%BE%B9%E6%A1%86%E6%97%8B%E8%BD%AC/" rel="prev" title="css实现只旋转边框，内含文字不转动"><i class="fa fa-chevron-left"></i> css实现只旋转边框，内含文字不转动</a></div><div class="post-nav-item"><a href="/%E6%B1%89%E5%A0%A1%E8%8F%9C%E5%8D%95/" rel="next" title="汉堡菜单按钮的实现">汉堡菜单按钮的实现 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></div></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){const e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">mohui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">116k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">1:45</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>