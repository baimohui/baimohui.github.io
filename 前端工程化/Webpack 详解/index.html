<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"baimohui.github.io",root:"/",images:"/images",scheme:"Muse",version:"8.2.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12},copycode:!1,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"}}</script><meta name="description" content="前端开发已经模块化，它改进了代码库的封装和结构。打包工具已经成为了一个项目必不可少的部分，如今这儿有几种可能的选择，例如webpack，grunt，gulp等。webpack因为他的功能和扩展性在过去的几年中，受到非常大的欢迎。   不像大多数的模块打包机，webpack 是把项目当作一个整体，通过一个给定的的主文件，webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders"><meta property="og:type" content="article"><meta property="og:title" content="Webpack 详解"><meta property="og:url" content="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/Webpack%20%E8%AF%A6%E8%A7%A3/index.html"><meta property="og:site_name" content="白抹灰"><meta property="og:description" content="前端开发已经模块化，它改进了代码库的封装和结构。打包工具已经成为了一个项目必不可少的部分，如今这儿有几种可能的选择，例如webpack，grunt，gulp等。webpack因为他的功能和扩展性在过去的几年中，受到非常大的欢迎。   不像大多数的模块打包机，webpack 是把项目当作一个整体，通过一个给定的的主文件，webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173720.png"><meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/5/16d003f3b01c273c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/5/16d003fa8e2cc44a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><meta property="article:published_time" content="2021-11-06T08:45:25.379Z"><meta property="article:modified_time" content="2022-02-28T15:06:28.477Z"><meta property="article:author" content="mohui"><meta property="article:tag" content="浏览器"><meta property="article:tag" content="Webpack"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173720.png"><link rel="canonical" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/Webpack%20%E8%AF%A6%E8%A7%A3/"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Webpack 详解 | 白抹灰</title><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">白抹灰</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89webpack-%E4%BD%9C%E7%94%A8"><span class="nav-text">（一）webpack 作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-text">（二）模块打包运行原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89sourceMap"><span class="nav-text">（三）sourceMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89webpack%E4%BD%BF%E7%94%A8"><span class="nav-text">（四）webpack使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#install"><span class="nav-text">install</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Entry"><span class="nav-text">Entry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Output"><span class="nav-text">Output</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Loader"><span class="nav-text">Loader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Plugins"><span class="nav-text">Plugins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A7%E5%93%81%E9%98%B6%E6%AE%B5%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="nav-text">产品阶段的构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%8F%92%E4%BB%B6"><span class="nav-text">优化插件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89Plugin"><span class="nav-text">（五）编写自定义Plugin</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-plugin"><span class="nav-text">实现一个 plugin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%8F%92%E4%BB%B6"><span class="nav-text">一个简单的插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%B8%85%E9%99%A4%E6%96%87%E4%BB%B6%E6%8F%92%E4%BB%B6"><span class="nav-text">一个简单的清除文件插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">mohui</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">58</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">58</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://baimohui.github.io/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/Webpack%20%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="mohui"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="白抹灰"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Webpack 详解</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-06 16:45:25" itemprop="dateCreated datePublished" datetime="2021-11-06T16:45:25+08:00">2021-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-02-28 23:06:28" itemprop="dateModified" datetime="2022-02-28T23:06:28+08:00">2022-02-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/" itemprop="url" rel="index"><span itemprop="name">模块打包</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>15k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>前端开发已经模块化，它改进了代码库的封装和结构。打包工具已经成为了一个项目必不可少的部分，如今这儿有几种可能的选择，例如webpack，grunt，gulp等。webpack因为他的功能和扩展性在过去的几年中，受到非常大的欢迎。</p><img src="https://cdn.jsdelivr.net/gh/baimohui/FigureBed/img/20211106173720.png" alt="image-20210325155353232" style="zoom:67%"><p><strong>不像大多数的模块打包机，webpack 是把项目当作一个整体，通过一个给定的的主文件，webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders 处理它们，最后打包成一个或多个浏览器可识别的js文件。</strong><a id="more"></a></p><h2 id="（一）webpack-作用"><a href="#（一）webpack-作用" class="headerlink" title="（一）webpack 作用"></a>（一）webpack 作用</h2><ul><li><strong>模块打包</strong>。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。</li><li><strong>编译兼容</strong>。在前端发展早期阶段，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大弱化了，通过<code>webpack</code>的<code>Loader</code>机制，不仅仅可以帮助我们对代码做<code>polyfill</code>，还可以编译转换诸如<code>.less, .vue, .jsx</code>这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。</li><li><strong>能力扩展</strong>。通过<code>webpack</code>的<code>Plugin</code>机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。</li></ul><h2 id="（二）模块打包运行原理"><a href="#（二）模块打包运行原理" class="headerlink" title="（二）模块打包运行原理"></a>（二）模块打包运行原理</h2><p><code>Webpack</code>究竟是如何把这些模块合并到一起，并且保证其正常工作的。首先我们应了解<code>webpack</code>的整个打包流程：</p><ol><li>读取<code>webpack</code>的配置参数；</li><li>启动<code>webpack</code>，创建<code>Compiler</code>对象并开始解析项目；</li><li>从入口文件（<code>entry</code>）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；</li><li>对不同文件类型的依赖模块文件使用对应的<code>Loader</code>进行编译，最终转为<code>Javascript</code>文件；</li><li>整个过程中<code>webpack</code>会通过发布订阅模式，向外抛出一些<code>hooks</code>，而<code>webpack</code>的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。</li></ol><p>其中文件的解析与构建是一个比较复杂的过程，在<code>webpack</code>源码中主要依赖于<code>compiler</code>和<code>compilation</code>两个核心对象实现。</p><ul><li><code>compiler</code>对象是一个全局单例，它负责把控整个<code>webpack</code>打包的构建流程。</li><li><code>compilation</code>对象是每一次构建的上下文对象，它包含了当次构建所需要的所有信息，每次热更新和重新构建，<code>compiler</code>都会重新生成一个新的<code>compilation</code>对象，负责此次更新的构建过程。</li></ul><p>而每个模块间的依赖关系，则依赖于<code>AST</code>抽象语法树。每个模块文件在通过<code>Loader</code>解析完成之后，会通过<code>acorn</code>库生成模块代码的<code>AST</code>语法树，通过语法树就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。最终<code>Webpack</code>打包出来的<code>bundle</code>文件是一个<code>IIFE</code>（立即调用函数表达式）的执行函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack 5 打包的bundle文件内容</span></span><br><span class="line"></span><br><span class="line">(<span class="function">() =&gt;</span> &#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line">    <span class="keyword">var</span> __webpack_modules__ = (&#123;</span><br><span class="line">        <span class="string">&#x27;file-A-path&#x27;</span>: (<span class="function">(<span class="params">modules</span>) =&gt;</span> &#123; <span class="comment">// ... &#125;)</span></span><br><span class="line">        <span class="string">&#x27;index-file-path&#x27;</span>: (<span class="function">(<span class="params">__unused_webpack_module, __unused_webpack_exports, __webpack_require__</span>) =&gt;</span> &#123; <span class="comment">// ... &#125;)</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The module cache</span></span><br><span class="line">    <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The require function</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Check if module is in cache</span></span><br><span class="line">        <span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];</span><br><span class="line">        <span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">module</span> = __webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">                <span class="comment">// no module.id needed</span></span><br><span class="line">                <span class="comment">// no module.loaded needed</span></span><br><span class="line">                <span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Execute the module function</span></span><br><span class="line">        __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the exports of the module</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// startup</span></span><br><span class="line">    <span class="comment">// Load entry module and return exports</span></span><br><span class="line">    <span class="comment">// This entry module can&#x27;t be inlined because the eval devtool is used.</span></span><br><span class="line">    <span class="keyword">var</span> __webpack_exports__ = __webpack_require__(<span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="（三）sourceMap"><a href="#（三）sourceMap" class="headerlink" title="（三）sourceMap"></a>（三）sourceMap</h2><p><code>sourceMap</code>是一项将编译、打包、压缩后的代码映射回源代码的技术，由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中<code>debug</code>问题会带来非常糟糕的体验，<code>sourceMap</code>可以帮助我们快速定位到源代码的位置，提高我们的开发效率。<code>sourceMap</code>并非<code>Webpack</code>特有的功能，像<code>JQuery</code>也支持<code>sourceMap</code>。</p><p>既然是一种源码的映射，那必然就需要有一份映射的文件，来标记混淆代码里对应的源码的位置，通常这份映射文件以<code>.map</code>结尾，里边的数据结构大概长这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span> : <span class="number">3</span>,                          <span class="comment">// Source Map版本</span></span><br><span class="line">  <span class="string">&quot;file&quot;</span>: <span class="string">&quot;out.js&quot;</span>,                       <span class="comment">// 输出文件（可选）</span></span><br><span class="line">  <span class="string">&quot;sourceRoot&quot;</span>: <span class="string">&quot;&quot;</span>,                       <span class="comment">// 源文件根目录（可选）</span></span><br><span class="line">  <span class="string">&quot;sources&quot;</span>: [<span class="string">&quot;foo.js&quot;</span>, <span class="string">&quot;bar.js&quot;</span>],        <span class="comment">// 源文件列表</span></span><br><span class="line">  <span class="string">&quot;sourcesContent&quot;</span>: [<span class="literal">null</span>, <span class="literal">null</span>],         <span class="comment">// 源内容列表（可选，和源文件列表顺序一致）</span></span><br><span class="line">  <span class="string">&quot;names&quot;</span>: [<span class="string">&quot;src&quot;</span>, <span class="string">&quot;maps&quot;</span>, <span class="string">&quot;are&quot;</span>, <span class="string">&quot;fun&quot;</span>], <span class="comment">// mappings使用的符号名称列表</span></span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: <span class="string">&quot;A,AAAB;;ABCDE;&quot;</span>            <span class="comment">// 带有编码映射数据的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>mappings</code>数据有如下规则：</p><ul><li>生成文件中的一行的每个组用“;”分隔；</li><li>每一段用“,”分隔；</li><li>每个段由1、4或5个可变长度字段组成；</li></ul><p>有了这份映射文件，我们只需要在压缩代码的最末端加上这句注释，即可让sourceMap生效：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//# sourceURL=/path/to/file.js.map</span></span><br></pre></td></tr></table></figure><p>有了这段注释后，浏览器就会通过<code>sourceURL</code>去获取这份映射文件，通过解释器解析后，实现源码和混淆代码之间的映射。因此sourceMap其实也是一项需要浏览器支持的技术。</p><p>如果我们仔细查看webpack打包出来的bundle文件，就可以发现在默认的<code>development</code>开发模式下，每个<code>_webpack_modules__</code>文件模块的代码最末端，都会加上<code>//# sourceURL=webpack://file-path?</code>，从而实现对sourceMap的支持。</p><h2 id="（四）webpack使用"><a href="#（四）webpack使用" class="headerlink" title="（四）webpack使用"></a>（四）webpack使用</h2><h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><p>首先添加我们即将使用的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><p>webpack是我们需要的模块打包机，webpack-dev-server用来创建本地服务器，监听你的代码修改，并自动刷新修改后的结果。这些是webpack.config.js文件中有关devServer的配置。</p><ul><li><code>contentBase</code>：为文件提供本地服务器</li><li><code>port</code>：监听端口，默认8080</li><li><code>inline</code>：设置为true，源文件发生改变自动刷新页面</li><li><code>historyApiFallback</code>：依赖HTML5 history API，如果设置为true，所有的页面跳转指向index.html</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exemple</span></span><br><span class="line">devServer:&#123;</span><br><span class="line">    contentBase: <span class="string">&#x27;./src&#x27;</span> <span class="comment">//本地服务器所加载的页面所在的目录</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>, <span class="comment">//不跳转</span></span><br><span class="line">    inline: <span class="literal">true</span> <span class="comment">// 实时刷新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在&#39;package.json&#39;添加两个命令用于本地开发和生产发布</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用webpack命令的时候，他将接受webpack的配置文件，除非我们使用其他的操作</p><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>entry: 用来写入口文件，它将是整个依赖关系的根</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baseConfig = &#123;</span><br><span class="line">	entry: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要多个入口文件的时候，可以把entry写成一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baseConfig = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">    	main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我建议使用后面一种方法，因为他的规模会随你的项目增大而变得繁琐</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>output: 即使入口文件有多个，但是只有一个输出配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> baseConfig = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">    	main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">    	filename: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">        path: path.resolve(<span class="string">&#x27;./build&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = baseConfig</span><br></pre></td></tr></table></figure><p>如果你定义的入口文件有多个，那么我们需要使用占位符来确保输出文件的唯一性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    path: path.resolve(<span class="string">&#x27;./build&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如今这么少的配置，就能够让你运行一个服务器并在本地使用命令npm start或者npm run build来打包我们的代码进行发布</p><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p><code>Webpack</code>最后打包出来的成果是一份<code>Javascript</code>代码，实际上在<code>Webpack</code>内部默认也只能够处理<code>JS</code>模块代码，在打包过程中，会默认把所有遇到的文件都当作 <code>JavaScript</code>代码进行解析，因此当项目存在非<code>JS</code>类型文件时，我们需要先对其进行必要的转换，才能继续执行打包任务，这也是<code>Loader</code>机制存在的意义。</p><p><strong>loader 的作用</strong>：</p><ol><li><p>实现对不同格式的文件的处理，比如说将 scss 转换为 css，或者 typescript 转化为 js</p></li><li><p>转换这些文件，从而使其能够被添加到依赖图中</p></li></ol><p>loader 是 webpack 最重要的部分之一，通过使用不同的 Loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理， loader 需要在 webpack.config.js 里边单独用 module 进行配置，配置如下：</p><ul><li>test：匹配所处理文件的扩展名的正则表达式（必须）</li><li>loader： loader的名称（必须）</li><li>include/exclude：手动添加处理的文件，屏蔽不需要处理的文件（可选）</li><li>query：为 loaders 提供额外的设置选项</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exemple </span></span><br><span class="line"><span class="keyword">var</span> baseConfig = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="comment">/*匹配文件后缀名的正则*/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                	loader: <span class="comment">/*loader名字*/</span>,</span><br><span class="line">                	query: <span class="comment">/*额外配置*/</span></span><br><span class="line">                ]</span><br><span class="line">    		&#125;</span><br><span class="line">    	]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使 loader 工作，我们需要一个正则表达式来标识我们要修改的文件，然后用一个数组表示我们即将使用的 Loader，当然我们需要的loader 需要通过 npm 进行安装。例如我们需要解析 less 的文件，那么 webpack.config.js 的配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baseConfig = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        path: path.resolve(<span class="string">&#x27;./build&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">&#x27;./src&#x27;</span>,</span><br><span class="line">        historyApiFallBack: <span class="literal">true</span>,</span><br><span class="line">        inline: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;<span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">loader</span>: <span class="string">&#x27;less-loader&#x27;</span>&#125;</span><br><span class="line">                ],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>babel-loader：让下一代的js文件转换成现代浏览器能够支持的JS文件。</li><li>babel：有些复杂，所以大多数都会新建一个<code>.babelrc</code> 进行配置</li><li>css-loader，style-loader：两个建议配合使用，用来解析css文件，能够解释<code>@import url()</code>，如果需要解析less就在后面加一个less-loader</li><li>file-loader：生成的文件名就是文件内容的MD5哈希值，并会保留所引用资源的原始扩展名</li><li>url-loader：功能类似 file-loader，但是文件大小低于指定的限制时，可以返回一个<code>DataURL</code>。事实上，在使用less,scss,stylus时，npm会提示你差什么插件，差什么你安上就行了</li></ul><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>如果说<code>Loader</code>负责文件转换，那么<code>Plugin</code>便是负责功能扩展。<code>Loader</code>和<code>Plugin</code>作为<code>Webpack</code>的两个重要组成部分，承担着两部分不同的职责。上文已经说过，<code>webpack</code>基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务，从而实现自己想要的功能。</p><p>既然基于发布订阅模式，那么知道<code>Webpack</code>到底提供了哪些事件钩子供插件开发者使用是非常重要的，上文提到过<code>compiler</code>和<code>compilation</code>是<code>Webpack</code>两个非常核心的对象，其中<code>compiler</code>暴露了和 <code>Webpack</code>整个生命周期相关的钩子（<a target="_blank" rel="noopener" href="https://webpack.js.org/api/compiler-hooks/">compiler-hooks</a>），而<code>compilation</code>则暴露了与模块和依赖有关的粒度更小的事件钩子（<a target="_blank" rel="noopener" href="https://webpack.js.org/api/compilation-hooks/">Compilation Hooks</a>）。</p><p><code>Webpack</code>的事件机制基于<code>webpack</code>自己实现的一套<code>Tapable</code>事件流方案（<a target="_blank" rel="noopener" href="https://github.com/webpack/tapable">github</a>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tapable的简单使用</span></span><br><span class="line"><span class="keyword">const</span> &#123; SyncHook &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 在this.hooks中定义所有的钩子事件</span></span><br><span class="line">        <span class="built_in">this</span>.hooks = &#123;</span><br><span class="line">            accelerate: <span class="keyword">new</span> SyncHook([<span class="string">&quot;newSpeed&quot;</span>]),</span><br><span class="line">            brake: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">            calculateRoutes: <span class="keyword">new</span> AsyncParallelHook([<span class="string">&quot;source&quot;</span>, <span class="string">&quot;target&quot;</span>, <span class="string">&quot;routesList&quot;</span>])</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCar = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="comment">// 通过调用tap方法即可增加一个消费者，订阅对应的钩子事件了</span></span><br><span class="line">myCar.hooks.brake.tap(<span class="string">&quot;WarningLampPlugin&quot;</span>, <span class="function">() =&gt;</span> warningLamp.on());</span><br></pre></td></tr></table></figure><p><code>Plugin</code>的开发和开发<code>Loader</code>一样，需要遵循一些开发上的规范和原则：</p><ul><li>插件必须是一个函数或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例；</li><li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，若在一个插件中修改了它们的属性，会影响后面的插件;</li><li>异步的事件需要在插件处理完任务时调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住;</li></ul><p>了解了以上这些内容，想要开发一个 <code>Webpack Plugin</code>，其实也并不困难。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    <span class="comment">// 找到合适的事件钩子，实现自己的插件功能</span></span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// compilation: 当前打包构建流程的上下文</span></span><br><span class="line">        <span class="built_in">console</span>.log(compilation);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>loaders 负责的是处理源文件的如 css、jsx，一次处理一个文件。而 plugins 并不是直接操作单个文件，</strong>它直接对整个构建过程起作用。下面列举了一些我们常用的plugins和对应用法。</p><p><strong><code>ExtractTextWebpackPlugin</code></strong>:</p><p>它会将入口中引用的 css 文件，都打包在独立的 css 文件中，而不是内嵌在 js 打包文件中。应用如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">&#x27;extract-text-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> lessRules = &#123;</span><br><span class="line">    use: [</span><br><span class="line">        &#123;<span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">loader</span>: <span class="string">&#x27;less-loader&#x27;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baseConfig = &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#123;<span class="attr">test</span>: <span class="regexp">/\.less$/</span>, use: ExtractTextPlugin.extract(lessRules)&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">&#x27;main.css&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>HtmlWebpackPlugin</code></strong></p><p>依据一个简单的index.html模版，生成一个自动引用你打包后的 js 文件的新 index.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HTMLWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> baseConfig = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HTMLWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>HotModuleReplacementPlugin</code></strong></p><p>它允许在修改组件代码时自动进行刷新，以实时预览修改后的结果。注意不要在生产环境中使用HMR（一般情况分为开发环境，测试环境，生产环境）。用法为： <code>new webpack.HotModuleReplacementPlugin()</code></p><p><strong>webpack.config.js的全部内容示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">&#x27;extract-text-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> lessRules = &#123;</span><br><span class="line">    use: [</span><br><span class="line">        &#123;<span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">loader</span>: <span class="string">&#x27;less-loader&#x27;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        path: path.resolve(<span class="string">&#x27;./build&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">&#x27;/src&#x27;</span>,</span><br><span class="line">        historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">        inline: <span class="literal">true</span>,</span><br><span class="line">        hot: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;<span class="attr">test</span>: <span class="regexp">/\.less$/</span>, use: ExtractTextPlugin.extract(lessRules)&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">&#x27;main.css&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="产品阶段的构建"><a href="#产品阶段的构建" class="headerlink" title="产品阶段的构建"></a>产品阶段的构建</h3><p>目前为止，在开发阶段的东西已经基本完成。但在产品阶段还需要对资源进行别的处理，例如压缩，优化，缓存，分离 CSS 和 JS。首先我们来定义产品环境：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ENV = process.env.NODE_ENV</span><br><span class="line"><span class="keyword">var</span> baseConfig = &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            <span class="string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="built_in">JSON</span>.stringify(ENV)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后还需要修改script命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">	&quot;start&quot;: &quot;NODE_ENV&#x3D;development webpack-dev-server&quot;,</span><br><span class="line">	&quot;build&quot;: &quot;NODE_ENV&#x3D;production webpack&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>process.env.NODE_ENV</code> 将被一个字符串替代，它运行压缩器排除那些不可到达的开发代码分支。<br>当你引入那些不会进行生产的代码，下面这个代码将非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">&#x27;这个警告会在生产阶段消失&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化插件"><a href="#优化插件" class="headerlink" title="优化插件"></a>优化插件</h3><p>下面介绍几个插件用来优化代码</p><ul><li><code>OccurrenceOrderPlugin</code>：为组件分配 ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，然后为它们分配最小的 ID</li><li><code>UglifyJsPlugin</code>：压缩代码</li></ul><p>下面是他们的使用方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baseConfig = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">     <span class="keyword">new</span> webpack.optimize.OccurenceOrderPlugin()</span><br><span class="line">     <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我们使用npm run build会发现代码是压缩的。</p><h2 id="（五）编写自定义Plugin"><a href="#（五）编写自定义Plugin" class="headerlink" title="（五）编写自定义Plugin"></a>（五）编写自定义Plugin</h2><p>插件是 webpack 的支柱功能。<code>webpack</code> 自身也是构建于，你在 <code>webpack</code> 配置中用到的相同的插件系统之上！插件目的在于解决 <code>loader</code> 无法实现的其他事。 要想写好插件就要知道<code>Webpack</code>中的两个比较核心的概念<code>compiler</code>、<code>compilation</code>、<code>tapable</code>。在<a href="">webpack 编译流程</a>已经都要记录。 <code>Webpack</code> 通过 <code>Plugin</code> 机制让其更加灵活，以适应各种应用场景。 在 <code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过 <code>Webpack</code> 提供的 <code>API</code> 改变输出结果。</p><h3 id="实现一个-plugin"><a href="#实现一个-plugin" class="headerlink" title="实现一个 plugin"></a>实现一个 plugin</h3><hr><p>一个 webpack plugin 基本包含以下几步：</p><ol><li>一个 JavaScript 函数或者类</li><li>在函数原型（prototype）中定义一个注入<code>compiler</code>对象的<code>apply</code>方法。</li><li><code>apply</code>函数中通过<code>compiler</code>插入指定的事件钩子，在钩子回调中拿到<code>compilation</code>对象</li><li>使用<code>compilation</code>操纵修改<code>webapack</code>内部实例数据。</li><li>异步插件，数据处理完后使用<code>callback</code>回调</li></ol><p>最后会实现一个简单的<code>clean-webpack-plugin</code>。</p><h3 id="一个简单的插件"><a href="#一个简单的插件" class="headerlink" title="一个简单的插件"></a>一个简单的插件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebpackCleanupPlugin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;WebpackCleanupPlugin&quot;</span>, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 应用函数</span></span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(compiler);</span><br><span class="line">    <span class="comment">// 绑定钩子事件</span></span><br><span class="line">    compiler.plugin(<span class="string">&quot;done&quot;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(compilation);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何使用在 webpack.config.js 中引入并且使用如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="comment">// 引入自己的插件</span></span><br><span class="line"><span class="keyword">const</span> WebpackCleanupPlugin = <span class="built_in">require</span>(<span class="string">&quot;./WebpackCleanupPlugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">  mode: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">    chunk1: <span class="string">&quot;./src/chunk1.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;[name].[chunkhash].js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">&quot;css-loader&quot;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 提取css插件</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// both options are optional</span></span><br><span class="line">      filename: <span class="string">&quot;[name].[contenthash].css&quot;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 使用自己的插件</span></span><br><span class="line">    <span class="keyword">new</span> WebpackCleanupPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>自己写的插件如下执行：</p><ul><li><code>webpack</code> 启动后，在读取配置的过程中会先执行 <code>new WebpackCleanupPlugin()</code> ，初始化一个 <code>WebpackCleanupPlugin</code> 。</li><li>在初始化 <code>compiler</code> 对象后，再调用 <code>WebpackCleanupPlugin.apply(compiler)</code> 给插件实例传入 <code>compiler</code> 对象。</li><li>插件实例在获取到 <code>compiler</code> 对象后，就可以通过 <code>compiler.plugin</code>(事件名称, 回调函数) 监听到 <code>Webpack</code> 广播出来的事件。</li><li>并且可以通过 <code>compiler</code> 对象去操作 <code>webpack</code>。</li></ul><p><strong>Compiler、Compilation</strong></p><ul><li><strong>Compiler 对象包含了 Webpack 环境所有的的配置信息</strong>，包含 <code>options</code>，<code>hook</code>，<code>loaders</code>，<code>plugins</code> 这些信息，这个对象在 <code>Webpack</code> 启动时候被实例化，它是<strong>全局唯一</strong>的，可以简单地把它理解为 <code>Webpack</code> 实例；<code>Compiler</code>中包含的东西如下所示：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/9/5/16d003f3b01c273c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="webpacl-plugin"></p><ul><li><strong>Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等</strong>。当 <code>Webpack</code> 以开发模式运行时，每当检测到一个文件变化，一次新的 <code>Compilation</code> 将被创建。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。通过 <code>Compilation</code> 也能读取到 <code>Compiler</code> 对象。</li></ul><p><code>Compilation</code>中包含的东西如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/5/16d003fa8e2cc44a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="webpacl-plugin"></p><blockquote><p><strong>Compiler 和 Compilation 的区别在于</strong>：<code>Compiler</code> 代表了整个 <code>Webpack</code> 从启动到关闭的生命周期，而 <code>Compilation</code> 只是代表了一次新的编译。</p></blockquote><p><a target="_blank" rel="noopener" href="https://www.webpackjs.com/api/compiler-hooks/">Compiler 钩子</a>和<a target="_blank" rel="noopener" href="https://www.webpackjs.com/api/compilation-hooks/">compilation 钩子</a></p><h3 id="一个简单的清除文件插件"><a href="#一个简单的清除文件插件" class="headerlink" title="一个简单的清除文件插件"></a>一个简单的清除文件插件</h3><hr><p>每次打包如果文件有修改会生成新的文件，文件的<strong>hash</strong>也会跟着变化，那么这个改变了的文件，他以前的文件就是无效的了，要把以前的文件清除掉，我们使用比较多的就是<code>clean-webpack-plugin</code>，这里自己实现一个简单的文件清除。如果不知道<a href="">hash、contenthash、chunkhash</a>的区别可以看这一片文章。</p><p>大致分为以下几步：</p><ul><li>获取<code>output</code>路径，也就是出口路径一般为<code>dist</code></li><li>绑定钩子事件 <code>compiler.plugin(&#39;done&#39;, (stats) =&gt; &#123;&#125;)</code></li><li>编译文件，与原来文件对比，删除未匹配文件 （同时可以 options 设置要忽略的文件）</li></ul><p>代码实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> recursiveReadSync = <span class="built_in">require</span>(<span class="string">&quot;recursive-readdir-sync&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> minimatch = <span class="built_in">require</span>(<span class="string">&quot;minimatch&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> union = <span class="built_in">require</span>(<span class="string">&quot;lodash.union&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFiles</span>(<span class="params">fromPath, exclude = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = recursiveReadSync(fromPath).filter(<span class="function"><span class="params">file</span> =&gt;</span></span><br><span class="line">    exclude.every(</span><br><span class="line">      excluded =&gt;</span><br><span class="line">        !minimatch(path.relative(fromPath, file), path.join(excluded), &#123;</span><br><span class="line">          dot: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// console.log(files);</span></span><br><span class="line">  <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebpackCleanupPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 配置文件</span></span><br><span class="line">    <span class="built_in">this</span>.options = options;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取output路径</span></span><br><span class="line">    <span class="keyword">const</span> outputPath = compiler.options.output.path;</span><br><span class="line">    <span class="comment">// 绑定钩子事件</span></span><br><span class="line">    compiler.plugin(<span class="string">&quot;done&quot;</span>, <span class="function"><span class="params">stats</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        compiler.outputFileSystem.constructor.name !== <span class="string">&quot;NodeOutputFileSystem&quot;</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取编译完成 文件名</span></span><br><span class="line">      <span class="keyword">const</span> assets = stats.toJson().assets.map(<span class="function"><span class="params">asset</span> =&gt;</span> asset.name);</span><br><span class="line">      <span class="built_in">console</span>.log(assets);</span><br><span class="line">      <span class="comment">// 多数组合并并且去重</span></span><br><span class="line">      <span class="keyword">const</span> exclude = union(<span class="built_in">this</span>.options.exclude, assets);</span><br><span class="line">      <span class="built_in">console</span>.log(exclude);</span><br><span class="line">      <span class="comment">// console.log(&#x27;outputPath&#x27;, outputPath);</span></span><br><span class="line">      <span class="comment">// 获取未匹配文件</span></span><br><span class="line">      <span class="keyword">const</span> files = getFiles(outputPath, exclude);</span><br><span class="line">      <span class="comment">// const files = [];</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;files&quot;</span>, files);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.options.preview) &#123;</span><br><span class="line">        <span class="comment">// console.log(&#x27;%s file(s) would be deleted:&#x27;, files.length);</span></span><br><span class="line">        <span class="comment">// 输出文件</span></span><br><span class="line">        files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;    %s&quot;</span>, file));</span><br><span class="line">        <span class="comment">// console.log();</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 删除未匹配文件</span></span><br><span class="line">        files.forEach(fs.unlinkSync);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.options.quiet) &#123;</span><br><span class="line">        <span class="comment">// console.log(&#x27;\nWebpackCleanupPlugin: %s file(s) deleted.&#x27;, files.length);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = WebpackCleanupPlugin;</span><br></pre></td></tr></table></figure><p>上面的这个插件实现了一个清除编译文件的效果。在这里就不做实验了，如果有兴趣可以自己把代码 copy 到本地，运行一下看一下结果。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在上面大致知道怎么写一个简单的清除文件的<code>webpack</code>的<strong>插件</strong>，其实还可以做更多的事情如下：</p><ul><li>读取输出资源、代码块、模块及其依赖（在 <code>emit</code> 事件发生）</li><li>监听文件变化 <code>watch-run</code></li><li>修改输出资源 <code>compilation.assets</code></li></ul><p>具体实现可以看一下一下<a target="_blank" rel="noopener" href="http://webpack.wuhaolin.cn/5%E5%8E%9F%E7%90%86/5-4%E7%BC%96%E5%86%99Plugin.html">webpack 深入浅出</a></p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag"># 浏览器</a> <a href="/tags/Webpack/" rel="tag"># Webpack</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E6%A1%86%E6%9E%B6/Uniapp/uniapp%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" rel="prev" title="uniapp 开发app日志"><i class="fa fa-chevron-left"></i> uniapp 开发app日志</a></div><div class="post-nav-item"><a href="/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2/CSS/CSS%20%E8%B6%85%E8%AF%A6%E8%A7%A3/" rel="next" title="CSS 核心">CSS 核心 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){const e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">mohui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">501k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">7:35</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>